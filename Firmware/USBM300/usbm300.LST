CCS PCM C Compiler, Version 3.173, 19978

               Filename: usbm300.LST

               ROM used: 5334 (65%)
                         Largest free fragment is 2048
               RAM used: 101 (58%) at main() level
                         122 (70%) worst case
               Stack:    10 worst case (4 in main + 6 for interrupts)

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   03A
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.0
0020:  GOTO   023
0021:  BTFSC  0C.0
0022:  GOTO   03D
0023:  BTFSS  0B.5
0024:  GOTO   027
0025:  BTFSC  0B.2
0026:  GOTO   040
0027:  MOVF   22,W
0028:  MOVWF  04
0029:  MOVF   23,W
002A:  MOVWF  77
002B:  MOVF   24,W
002C:  MOVWF  78
002D:  MOVF   25,W
002E:  MOVWF  79
002F:  MOVF   26,W
0030:  MOVWF  7A
0031:  MOVF   27,W
0032:  MOVWF  7B
0033:  MOVF   20,W
0034:  MOVWF  0A
0035:  SWAPF  21,W
0036:  MOVWF  03
0037:  SWAPF  7F,F
0038:  SWAPF  7F,W
0039:  RETFIE
003A:  BSF    0A.3
003B:  BCF    0A.4
003C:  GOTO   000
003D:  BCF    0A.3
003E:  BCF    0A.4
003F:  GOTO   763
0040:  BCF    0A.3
0041:  BCF    0A.4
0042:  GOTO   752
....................  //  
.................... // Put in file header comments  
.................... //  
....................   
.................... #if defined(__PCM__)  
....................   
.................... #include <16c67.h> 
....................  //////// Standard Header file for the PIC16C67 device ////////////////  
.................... #device PIC16C67  
.................... #list  
....................  
....................   
.................... // BUGBUG Change these fuses in release!  
.................... #fuses HS,NOWDT,PROTECT,PUT,BROWNOUT  
....................   
.................... //  
.................... // Setup the clock base time and RS-232 Baud rate  
.................... //  
.................... #use delay(clock=20000000)  
*
06D3:  MOVLW  AC
06D4:  MOVWF  04
06D5:  MOVF   00,W
06D6:  BTFSC  03.2
06D7:  GOTO   6E5
06D8:  MOVLW  06
06D9:  MOVWF  78
06DA:  CLRF   77
06DB:  DECFSZ 77,F
06DC:  GOTO   6DB
06DD:  DECFSZ 78,F
06DE:  GOTO   6DA
06DF:  MOVLW  7B
06E0:  MOVWF  77
06E1:  DECFSZ 77,F
06E2:  GOTO   6E1
06E3:  DECFSZ 00,F
06E4:  GOTO   6D8
06E5:  RETLW  00
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)  
.................... #endif  
....................   
.................... //  
.................... // Turn off the compiler's caching (virtual port) auto data direction crap  
.................... //  
.................... #use fast_io(A)  
.................... #use fast_io(B)  
.................... #use fast_io(C)  
.................... #use fast_io(D)  
.................... #use fast_io(E)  
....................   
.................... //  
.................... // Memory (port) defines so we can use them in 'C'  
.................... #byte PORT_B=6  
.................... #byte PORT_C=7  
.................... #byte PORT_D=8  
.................... #byte PORT_E=9  
.................... #byte SSPSTAT=0x14  
.................... #byte SSPCON=0x14  
....................   
.................... //  
.................... // EEPROM access routine defines  
.................... //  
.................... #define EEPROM_SELECT PIN_B0  
.................... #define EEPROM_DI     PIN_C5  
.................... #define EEPROM_DO     PIN_C4  
.................... #define EEPROM_CLK    PIN_C3  
....................   
.................... #define EEPROM_ADDRESS byte  
.................... #define EEPROM_SIZE    256  
....................   
.................... //  
.................... // EEPROM Locations  
.................... //  
.................... #define EEPROM_MOD_ADDRESS      0x00  
.................... #define EEPROM_DIR_PORT1        0x02  
.................... #define EEPROM_DIR_PORT2        0x03  
.................... #define EEPROM_POD_PORT1        0x06  
.................... #define EEPROM_POD_PORT2        0x07  
.................... #define EEPROM_EXPANDER_FLAG    0x08  
.................... #define EEPROM_POD_DA_MSB_CH0   0x09  
.................... #define EEPROM_POD_DA_LSB_CH0   0x0A  
.................... #define EEPROM_POD_DA_MSB_CH1   0x0B  
.................... #define EEPROM_POD_DA_LSB_CH1   0x0C  
.................... #define EEPROM_AD_SAMPLE_CLK    0x0D  
....................   
.................... //  
.................... // SPI device chip select lines  
.................... // PORTA  
.................... //  
.................... #define AD_CS           PIN_A0  
.................... #define EEPROM_CS       PIN_A1  
.................... #define USB_CS          PIN_A2  
.................... #define RTC_CS          PIN_A3  
.................... #define DAC_CS          PIN_A5  
....................   
.................... //  
.................... // LED defines  
.................... // PORTC  
.................... //  
.................... #define LED_RED         PIN_C1  
.................... #define LED_GREEN       PIN_C0  
....................   
.................... //  
.................... // Global variable declarations  
.................... //  
.................... #define EXPANDER_FLAG   1  
.................... #define SLOW_ADC_CLOCK  2  
....................   
.................... int8    EEFlags = 0;  
*
100B:  CLRF   29
....................   
.................... int8    ADCNibble[8];       // EEPROM locations 0x11 to 0x18  
....................   
.................... #define SPI_USB         1  
.................... #define SPI_ADC_FAST    2  
.................... #define SPI_EEPROM      2  
.................... #define SPI_DAC         2  
.................... #define SPI_ADC_SLOW    3  
....................   
.................... int8    SpiMode = 0;        // 0 Guarantees that setup_spi_mode() will be called the first time  
100C:  CLRF   32
....................   
.................... int8    StreamFlag = 0;  
100D:  CLRF   33
....................   
.................... int8    LedGreenFlag = 1;  
100E:  MOVLW  01
100F:  MOVWF  34
.................... int8    LedCount = 0;  
1010:  CLRF   35
....................   
.................... int8    Port1_Dir = 0;  
1011:  CLRF   36
.................... int8    Port2_Dir = 0;  
1012:  CLRF   37
.................... int16   DAC_CH0 = 0;  
1013:  CLRF   38
1014:  CLRF   39
.................... int16   DAC_CH1 = 0;  
1015:  CLRF   3A
1016:  CLRF   3B
....................   
.................... int32   PulseCount = 0;  
1017:  CLRF   3C
1018:  CLRF   3D
1019:  CLRF   3E
101A:  CLRF   3F
....................   
.................... int8    CommandBuffer[8];  
.................... int8    ResponseBuffer[10];  
....................   
.................... //  
.................... // Constant table definitions  
.................... //  
.................... const int8 BIN_TO_HEX_TBL[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};  
....................   
.................... //  
.................... // Forward function declarations  
.................... //  
.................... #separate  
.................... trigger_led_red(void);  
.................... led_on_green(void);  
....................   
.................... #include "string.h" 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STRING  
.................... #define _STRING  
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
.................... #include <ctype.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _CTYPE  
.................... #define _CTYPE  
....................   
.................... #define islower(x)  isamoung(x,"abcdefghijklmnopqrstuvwxyz")  
.................... #define isupper(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")  
.................... #define isalnum(x)  isamoung(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isalpha(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isdigit(x)  isamoung(x,"0123456789")  
.................... #define isspace(x)  (x==' ')  
.................... #define isxdigit(x) isamoung(x,"0123456789ABCDEFabcdef")  
.................... #define iscntrl(x)  (x<' ')  
.................... #define isprint(x)  (x>=' ')  
.................... #define isgraph(x)  (x>' ')  
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x))  
....................   
.................... #endif  
....................   
....................  
....................   
....................   
....................   
.................... //////////////////////////////////////////////  
.................... //// Uncomment the following define to    ////  
.................... //// allow some functions to use a        ////  
.................... //// quicker algorithm, but use more ROM  ////  
.................... ////                                      ////  
.................... //// #define FASTER_BUT_MORE_ROM          ////  
.................... //////////////////////////////////////////////  
....................   
....................   
....................   
.................... /*Copying functions*/  
.................... /* standard template:  
....................    void *memmove(void *s1, void *s2, size_t n).  
....................    Copies max of n characters safely (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *memmove(void *s1,char *s2,size_t n)  
.................... {  
....................    char *sc1;  
....................    char *sc2;  
....................    sc1=s1;  
....................    sc2=s2;  
....................    if(sc2<sc1 && sc1 <sc2 +n)  
....................       for(sc1+=n,sc2+=n;0<n;--n)  
....................          *--sc1=*--sc2;  
....................    else  
....................       for(;0<n;--n)  
....................          *sc1++=*sc2++;  
....................   return s1;  
....................   }  
.................... /*    Standard template: char *strcpy(char *s1, const char *s2)  
.................... copies the string s2 including the null character to s1*/  
....................   
.................... char *strcpy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved?? 
....................    Standard template: char *strcpy(char *s1, const char *s2)  
....................    copies the string s2 including the null character to s1*/  
....................   
.................... char *strcopy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
....................   
.................... /* standard template:  
....................    char *strncpy(char *s1, const char *s2, size_t n).  
....................    Copies max of n characters (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *strncpy(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(s1);  
.................... }  
.................... /***********************************************************/  
....................   
.................... /*concatenation functions*/  
.................... /* standard template: char *strcat(char *s1, const char *s2)  
.................... appends s2 to s1*/  
....................   
.................... char *strcat(char *s1, char *s2)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0')  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)  
.................... appends not more than n characters from s2 to s1*/  
....................   
.................... char *strncat(char *s1, char *s2, size_t n)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0' && 0<n)  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................       --n;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
....................   
.................... /***********************************************************/  
....................   
.................... /*comparison functions*/  
.................... /* standard template: signed int memcmp(void *s1, void *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int memcmp(void * s1,char *s2,size_t n)  
.................... {  
.................... char *su1, su2;  
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)  
.................... {  
....................    if(*su1!=*su2)  
....................       return ((*su1<*su2)??1:+1);  
.................... }  
.................... return 0;  
.................... }  
.................... /* standard template: int strcmp(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcmp(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
.................... /* standard template: int strcoll(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcoll(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
.................... /* standard template:  
....................    int strncmp(const char *s1, const char *s2, size_t n).  
....................    Compares max of n characters (not following 0) from s1 to s2;  
....................    returns same as strcmp */  
....................   
.................... signed int strncmp(char *s1, char *s2, size_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
....................       if (*s1 != *s2)  
....................          return((*s1 <*s2) ??-1: 1);  
....................       else if (*s1 == '\0')  
....................          return(0);  
....................    return(0);  
.................... }  
.................... /* standard template:  
....................    int strxfrm(const char *s1, const char *s2, size_t n).  
....................    transforms maximum of n characters from s2 and places them into s1*/  
.................... size_t strxfrm(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   int n1;  
....................   n1=n;  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(n1);  
.................... }  
....................   
....................   
....................   
....................   
....................   
.................... /***********************************************************/  
.................... /*Search functions*/  
.................... /* standard template: void *memchr(const char *s, int c).  
....................    Finds first occurrence of c in n characters of s */  
....................   
.................... char *memchr(void *s,int c,size_t n)  
.................... {  
....................    char uc;  
....................    char *su;  
....................    uc=c;  
....................    for(su=s;0<n;++su,--n)  
....................       if(*su==uc)  
....................       return su;  
....................    return NULL;  
.................... }  
....................   
.................... /* standard template: char *strchr(const char *s, int c).  
....................    Finds first occurrence of c in s */  
....................   
.................... char *strchr(char *s, int c)  
.................... {  
....................    for (; *s != c; s++)  
....................       if (*s == '\0')  
....................          return(0);  
....................    return(s);  
.................... }  
.................... /* standard template:  
....................    size_t strcspn(const char *s1, const char *s2).  
....................    Computes length of max initial segment of s1 that  
....................    consists entirely of characters NOT from s2*/  
....................   
.................... int *strcspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1 - s1);  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strpbrk(const char *s1, const char *s2).  
....................    Locates first occurence of any character from s2 in s1;  
....................    returns s1 if s2 is empty string */  
....................   
.................... char *strpbrk(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1);  
....................    return(0);  
.................... }  
....................   
....................   
.................... /* standard template: char *strrchr(const char *s, int c).  
....................    Finds last occurrence of c in s */  
....................   
.................... char *strrchr(char *s, int c)  
.................... {  
....................    char *p;  
....................   
....................    for (p = 0; ; s++)  
....................    {  
....................       if (*s == c)  
....................          p = s;  
....................       if (*s == '\0')  
....................          return(p);  
....................    }  
.................... }  
.................... /* computes length of max initial segment of s1 consisting  
....................    entirely of characters from s2 */  
....................   
.................... int *strspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; ; sc2++)  
.................... 	 if (*sc2 == '\0')  
.................... 	    return(sc1 - s1);  
....................          else if (*sc1 == *sc2)  
....................             break;  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strstr(const char *s1, const char *s2);  
....................    Locates first occurence of character sequence s2 in s1;  
....................    returns 0 if s2 is empty string  
....................   
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the  
....................    file to use the faster algorithm */  
.................... char *strstr(char *s1, char *s2)  
.................... {  
.................... 	char *s, *t;  
....................   
....................    #ifdef FASTER_BUT_MORE_ROM  
....................    if (*s2 == '\0')  
....................          return(s1);  
....................    #endif  
....................   
.................... 	while (*s1)  
....................    {  
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t);  
....................   
.................... 		if (*t == '\0')  
.................... 			return s1;  
....................       ++s1;  
....................       #ifdef FASTER_BUT_MORE_ROM  
....................          while(*s1 != '\0' && *s1 != *s2)  
....................             ++s1;  
....................       #endif  
.................... 	}  
.................... 	return 0;  
.................... }  
....................   
.................... /* standard template: char *strtok(char *s1, const char *s2).  
....................   
....................    Finds next token in s1 delimited by a character from separator  
....................    string s2 (which can be different from call to call).  First call  
....................    starts at beginning of s1 searching for first character NOT  
....................    contained in s2; returns 0 if none is found.  
....................    If one is found, it is the start of first token (return value).  
....................    Function then searches from there for a character contained in s2.  
....................    If none is found, current token extends to end of s1, and subsequent  
....................    searches for a token will return 0.  If one is found, it is  
....................    overwritten by '\0', which terminates current token.  Function saves  
....................    pointer to following character from which next search will start.  
....................    Each subsequent call, with 0 as first argument, starts searching  
....................    from saved pointer */  
....................   
.................... char *strtok(char *s1, char *s2)  
.................... {  
....................    char *beg, *end;  
....................    static char *save;  
101B:  CLRF   52
....................   
....................    beg = (s1)??s1: save;  
....................    beg += strspn(beg, s2);  
....................    if (*beg == '\0')  
....................    {  
....................       *save = ' ';  
....................       return(0);  
....................    }  
....................    end = strpbrk(beg, s2);  
....................    if (*end != '\0')  
....................    {  
....................       *end = '\0';  
....................       end++;  
....................    }  
....................    save = end;  
....................    return(beg);  
.................... }  
....................   
.................... /*****************************************************************/  
.................... /*Miscellaneous functions*/  
.................... /* standard template  
.................... maps error number in errnum to an error message string  
.................... Returns: Pointer to string  
.................... */  
.................... #ifdef _ERRNO  
.................... char * strerror(int errnum)  
.................... {  
.................... char s[15];  
.................... switch( errnum)  
.................... {  
.................... case 0:  
....................    strcpy(s,"no errors");  
....................    return s;  
.................... case EDOM :  
....................    strcpy(s,"domain error");  
....................    return s;  
.................... case ERANGE:  
....................    strcpy(s,"range error");  
....................    return s;  
.................... }  
.................... }  
.................... #ENDIF  
.................... /* standard template: size_t strlen(const char *s).  
....................    Computes length of s1 (preceding terminating 0) */  
....................   
.................... int *strlen(char *s)  
.................... {  
....................    char *sc;  
....................   
....................    for (sc = s; *sc != 0; sc++);  
*
0CB5:  BSF    03.5
0CB6:  MOVF   22,W
0CB7:  MOVWF  23
0CB8:  MOVF   23,W
0CB9:  MOVWF  04
0CBA:  MOVF   00,F
0CBB:  BTFSC  03.2
0CBC:  GOTO   4BF
0CBD:  INCF   23,F
0CBE:  GOTO   4B8
....................    return(sc - s);  
0CBF:  MOVF   22,W
0CC0:  SUBWF  23,W
0CC1:  MOVWF  78
.................... }  
0CC2:  BCF    03.5
0CC3:  RETLW  00
....................   
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).  
....................    Compares s1 to s2 ignoring case (upper vs. lower) */  
....................   
.................... signed int stricmp(char *s1, char *s2)  
.................... {  
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));  
....................     s1++, s2++)  
....................     if (*s1 == '\0')  
....................        return(0);  
....................  return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
....................   
.................... /* standard template: char *strlwr(char *s).  
....................    Replaces uppercase letters by lowercase;  
....................    returns pointer to new string s */  
....................   
.................... char *strlwr(char *s)  
.................... {  
....................    char *p;  
....................   
....................    for (p = s; *p != '\0'; p++)  
....................       if (*p >= 'A' && *p <='Z')  
....................          *p += 'a' - 'A';  
....................    return(s);  
.................... }  
....................   
....................   
.................... /************************************************************/  
....................   
....................   
.................... #endif  
....................  
....................   
....................   
.................... setup_spi_adc_fast()  
.................... {  
....................     #asm  
....................     movlw  0x04  
*
01BC:  MOVLW  04
....................     movwf  0x12  
01BD:  MOVWF  12
....................     movlw  0x02  
01BE:  MOVLW  02
....................     bsf    0x03,5  
01BF:  BSF    03.5
....................     movwf  0x12  
01C0:  MOVWF  12
....................     bcf    0x03,5  
01C1:  BCF    03.5
....................   
....................     bcf    0x14,5  
01C2:  BCF    14.5
....................     movlw  0x33  
01C3:  MOVLW  33
....................     movwf  0x14  
01C4:  MOVWF  14
....................     movlw  0xC0  
01C5:  MOVLW  C0
....................     bsf    0x03,5  
01C6:  BSF    03.5
....................     movwf  0x14  
01C7:  MOVWF  14
....................     bcf    0x03,5  
01C8:  BCF    03.5
....................     #endasm  
....................     return;  
.................... }  
01C9:  RETLW  00
....................   
.................... setup_spi_clk16()  
.................... {  
....................     #asm  
....................     bcf    0x14,5  
....................     movlw  0x31  
....................     movwf  0x14  
....................     movlw  0xC0  
....................     bsf    0x03,5  
....................     movwf  0x14  
....................     bcf    0x03,5  
....................     #endasm  
....................     return;  
.................... }  
....................   
.................... setup_spi_clk64()  
.................... {  
....................     #asm  
....................     bcf    0x14,5  
01CA:  BCF    14.5
....................     movlw  0x32  
01CB:  MOVLW  32
....................     movwf  0x14  
01CC:  MOVWF  14
....................     movlw  0xC0  
01CD:  MOVLW  C0
....................     bsf    0x03,5  
01CE:  BSF    03.5
....................     movwf  0x14  
01CF:  MOVWF  14
....................     bcf    0x03,5  
01D0:  BCF    03.5
....................     #endasm  
....................     return;  
.................... }  
01D1:  RETLW  00
....................   
.................... #separate  
.................... setup_spi_mode(int8 mode)  
.................... {  
....................     if (mode == SPI_USB) {  
01D2:  BSF    03.5
01D3:  DECFSZ 3A,W
01D4:  GOTO   1E1
....................         setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_16);  
01D5:  BCF    03.5
01D6:  BCF    14.5
01D7:  MOVLW  21
01D8:  MOVWF  14
01D9:  MOVLW  00
01DA:  BSF    03.5
01DB:  MOVWF  14
....................         SpiMode = SPI_USB;  
01DC:  MOVLW  01
01DD:  BCF    03.5
01DE:  MOVWF  32
....................         return;  
01DF:  GOTO   1EF
01E0:  BSF    03.5
....................     }  
....................   
....................     // SPI_EEPROM, SPI_ADC_FAST, SPI_DAC  
....................     if (mode == SPI_EEPROM) {  
01E1:  MOVF   3A,W
01E2:  SUBLW  02
01E3:  BTFSS  03.2
01E4:  GOTO   1EB
....................         setup_spi_adc_fast();  
01E5:  BCF    03.5
01E6:  CALL   1BC
....................         SpiMode = SPI_EEPROM;  
01E7:  MOVLW  02
01E8:  MOVWF  32
....................         return;  
01E9:  GOTO   1EF
01EA:  BSF    03.5
....................     }  
....................   
....................     // SPI_ADC_SLOW  
....................     setup_spi_clk64();  
01EB:  BCF    03.5
01EC:  CALL   1CA
....................     SpiMode = SPI_ADC_SLOW;  
01ED:  MOVLW  03
01EE:  MOVWF  32
....................     return;  
.................... }  
01EF:  RETLW  00
....................   
....................   
....................   
.................... //  
.................... // Include the USB code  
.................... //  
.................... #include <usbn9603.c> 
....................    
....................   
....................   
.................... //  
.................... // USB Device desriptor defines  
.................... //  
.................... #ifndef __USB_DESCRIPTORS__  
....................    #include "USBM300_desc.h" 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... //  
.................... //  USBM300_DESC.H  
.................... //  
.................... //  USB descriptors for the Integrity Instruments, Inc.  
.................... //  Model: USBM300 I/O Module  
.................... //  
....................   
.................... #define __USB_DESCRIPTORS__  
....................   
.................... //  
.................... // Note: Endpoint 0 doesnt count here since all devices have an EP0 for control  
.................... //  
.................... #define USB_NUM_ENDPOINTS      4  
....................   
....................   
.................... #define USB_NUM_CLASSES        0  
....................   
.................... //  
.................... // Standard request codes  
.................... //  
.................... #define GET_STATUS          0  
.................... #define CLEAR_FEATURE       1  
.................... #define SET_FEATURE         3  
.................... #define SET_ADDRESS         5  
.................... #define GET_DESCRIPTOR      6  
.................... #define SET_DESCRIPTOR      7  
.................... #define GET_CONFIGURATION   8  
.................... #define SET_CONFIGURATION   9  
.................... #define GET_INTERFACE       10  
.................... #define SET_INTERFACE       11  
.................... #define SYNCH_FRAME         12  
....................   
.................... //  
.................... // Descriptor types  
.................... //  
.................... #define USB_DEVICE_DESC_KEY      0x01  
.................... #define USB_CONFIG_DESC_KEY      0x02  
.................... #define USB_STRING_DESC_KEY      0x03  
.................... #define USB_INTERFACE_DESC_KEY   0x04  
.................... #define USB_ENDPOINT_DESC_KEY    0x05  
....................   
....................   
.................... #define USB_MAX_EP0_PACKET_LENGTH   8  
....................   
.................... //  
.................... // Descriptor lengths. Specific to our configuration  
.................... //  
.................... #define USB_DEVICE_DESC_LEN         18  
.................... #define USB_CONFIG_DESC_LEN         9  
.................... #define USB_CONFIG_DESC_TOTAL_LEN   46  
.................... #define USB_INTERFACE_DESC_LEN      9  
.................... #define USB_ENDPOINT_DESC_LEN       7  
....................   
.................... //  
.................... // Device descriptor  
.................... //  
.................... const int8 USB_DEVICE_DESC[USB_DEVICE_DESC_LEN] = {  
....................     USB_DEVICE_DESC_LEN,        // the length of this report  
....................     USB_DEVICE_DESC_KEY,        // constant DEVICE (0x01)  
....................     0x10,0x01,                  // usb version in bcd  
....................     0x00,                       // class code (if 0, interface defines class.  FF is vendor defined)  
....................     0x00,                       // subclass code  
....................     0x00,                       // protocol code  
....................     8,                          // max packet size for endpoint 0  
....................     0xEF,0x10,                  // vendor id = 0x10EF   Integrity Instruments, Inc.  
....................     0x03,0x00,                  // product id  
....................     0x00,0x00,                  // device release number  
....................     0x01,                       // index of string description of manufacturer. therefore we point to string_1 array (see below)  
....................     0x02,                       // index of string descriptor of the product  
....................     0x00,                       // NOT USED: index of string descriptor of serial number  
....................     1                           // number of possible configurations  
.................... };  
....................   
.................... //  
.................... // Configuration descriptor  
.................... //  
.................... int8 const USB_CONFIG_DESC[USB_CONFIG_DESC_TOTAL_LEN] = {  
....................     // Config_descriptor for config index 1  
....................     USB_CONFIG_DESC_LEN,        // length of descriptor size  
....................     USB_CONFIG_DESC_KEY,        // constant CONFIGURATION (0x02)  
....................     USB_CONFIG_DESC_TOTAL_LEN,0,// size of all data returned for this config  
....................     0x01,                       // number of interfaces this device supports  
....................     0x01,                       // identifier for this configuration.  (IF we had more than one configurations)  
....................     0x00,                       // index of string descriptor for this configuration  
....................     0x40,                       // bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 reserved and bit7=1  
....................     0x00,                       // maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  
....................   
....................     // Interface descriptor 0 alt 0  
....................     USB_INTERFACE_DESC_LEN,     // length of descriptor  
....................     USB_INTERFACE_DESC_KEY,     // constant INTERFACE (0x04)  
....................     0x00,                       // number defining this interface (IF we had more than one interface)  
....................     0x00,                       // alternate setting  
....................     USB_NUM_ENDPOINTS,          // number of endpoints, except 0.  
....................     0xFF,                       // class code, FF = vendor defined  
....................     0xFF,                       // subclass code, FF = vendor  
....................     0xFF,                       // protocol code, FF = vendor  
....................     0x00,                       // index of string descriptor for interface  
....................   
....................     // Endpoint descriptor EP1 - IN (to the Host)  
....................     // WDM "PIPE0"  
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor  
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05)  
....................     0x81,                       // endpoint number and direction (0x81 = EPC1 IN)  
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt)  
....................     0x40,0x00,                  // maximum packet size supported  
....................     0xFF,                       // polling interval in ms. (for interrupt transfers ONLY)  
....................   
....................     // Endpoint descriptor EP2 - OUT (from the Host)  
....................     // WDM "PIPE1"  
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor  
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05)  
....................     0x02,                       // endpoint number and direction (0x02 = EPC2 OUT)  
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt)  
....................     0x40,0x00,                  // maximum packet size supported  
....................     0xFF,                       // polling interval in ms. (for interrupt transfers ONLY)  
....................   
....................     // Endpoint descriptor EP3 - IN (to the Host)  
....................     // WDM "PIPE2"  
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor  
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05)  
....................     0x83,                       // endpoint number and direction (0x83 = EPC3 IN)  
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt)  
....................     0x40,0x00,                  // maximum packet size supported  
....................     0xFF,                       // polling interval in ms. (for interrupt transfers ONLY)  
....................   
....................     // Endpoint descriptor EP4 - IN (to the Host)  
....................     // WDM "PIPE3"  
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor  
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05)  
....................     0x84,                       // endpoint number and direction (0x84 = EPC5 IN)  
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt)  
....................     0x40,0x00,                  // maximum packet size supported  
....................     0xFF                        // polling interval in ms. (for interrupt transfers ONLY)  
.................... };   
....................   
....................   
.................... //  
.................... // String descriptors and string lengths  
.................... //  
.................... #define USB_STRING_0_LEN    4  
.................... #define USB_STRING_1_LEN    54  
.................... #define USB_STRING_2_LEN    50  
.................... #define USB_STRING_3_LEN    46  
.................... #define USB_STRING_4_LEN    46  
....................   
.................... int8 const USB_STRING_0[USB_STRING_0_LEN] = {    
....................                                 // string index 0 is special  
....................          USB_STRING_0_LEN,      // length of string index  
....................          0x03,                  // descriptor type 0x03 (STRING)  
....................          0x09,0x04              // Microsoft Defined for US-English  
.................... };  
....................   
.................... int8 const USB_STRING_1[USB_STRING_1_LEN] = {    
....................                                 // we defined string index 1 earlier as manuf string  
....................          USB_STRING_1_LEN,      // length of string index  
....................          0x03,                  // descriptor type 0x03 (STRING)  
....................          'I',0,  
....................          'n',0,  
....................          't',0,  
....................          'e',0,  
....................          'g',0,  
....................          'r',0,  
....................          'i',0,  
....................          't',0,  
....................          'y',0,  
....................          ' ',0,  
....................          'I',0,  
....................          'n',0,  
....................          's',0,  
....................          't',0,  
....................          'r',0,  
....................          'u',0,  
....................          'm',0,  
....................          'e',0,  
....................          'n',0,  
....................          't',0,  
....................          's',0,  
....................          ' ',0,  
....................          'I',0,  
....................          'n',0,  
....................          'c',0,  
....................          '.',0  
.................... };  
....................   
.................... int8 const USB_STRING_2[USB_STRING_2_LEN] = {    
....................                                 // we defined string index 2 as description of product  
....................          USB_STRING_2_LEN,      // length of string index  
....................          0x03,                  // descriptor type 0x03 (STRING)  
....................          'U',0,  
....................          'S',0,  
....................          'B',0,  
....................          'M',0,  
....................          '3',0,  
....................          '0',0,  
....................          '0',0,  
....................          ' ',0,  
....................          'D',0,  
....................          'a',0,  
....................          't',0,  
....................          'a',0,  
....................          ' ',0,  
....................          'A',0,  
....................          'c',0,  
....................          'q',0,  
....................          'u',0,  
....................          'i',0,  
....................          's',0,  
....................          'i',0,  
....................          't',0,  
....................          'i',0,  
....................          'o',0,  
....................          'n',0  
.................... };  
....................   
.................... int8 const USB_STRING_3[USB_STRING_3_LEN] = {    
....................                                 // we defined string index 3 as Interface Description  
....................          USB_STRING_3_LEN,      // length of string index  
....................          0x03,                  // descriptor type 0x03 (STRING)  
....................          'S',0,  
....................          't',0,  
....................          'a',0,  
....................          'n',0,  
....................          'd',0,  
....................          'a',0,  
....................          'r',0,  
....................          'd',0,  
....................          ' ',0,  
....................          'C',0,  
....................          'o',0,  
....................          'n',0,  
....................          'f',0,  
....................          'i',0,  
....................          'g',0,  
....................          'u',0,  
....................          'r',0,  
....................          'a',0,  
....................          't',0,  
....................          'i',0,  
....................          'o',0,  
....................          'n',0  
.................... };  
....................   
.................... int8 const USB_STRING_4[USB_STRING_4_LEN] = {    
....................                                 // we defined string index 3 as Interface Description  
....................          USB_STRING_4_LEN,      // length of string index  
....................          0x03,                  // descriptor type 0x03 (STRING)  
....................          'U',0,  
....................          'S',0,  
....................          'B',0,  
....................          'M',0,  
....................          '3',0,  
....................          '0',0,  
....................          '0',0,  
....................          ' ',0,  
....................          'I',0,  
....................          'n',0,  
....................          't',0,  
....................          'e',0,  
....................          'r',0,  
....................          'f',0,  
....................          'a',0,  
....................          'c',0,  
....................          'e',0,  
....................          ' ',0,  
....................          '1',0,  
....................          '.',0,  
....................          '0',0,  
....................          '0',0  
.................... };  
....................  
.................... #endif  
....................   
....................   
.................... #define USB_MAX_ENDPOINTS 5     // number of bidrectional endpoints.  960x has 1 control port and 6 individual endpoints = 4 bidrectional endpoints  
....................   
.................... //  
.................... // USBN9603 register defines  
.................... //  
.................... #include "usbn9603_reg.h" 
....................  /*----------------------------------------------------------------------------  
....................  *  Copyright (c) 2001 by National Semiconductor Corporation  
....................  *  National Semiconductor Corporation  
....................  *  2900 Semiconductor Drive  
....................  *  Santa Clara, California 95051  
....................  *  
....................  *  All rights reserved  
....................  *  
....................  *<<<-------------------------------------------------------------------------  
....................  * File Contents:  
....................  *	usb_reg.c - USB related definitions  
....................  *  
....................  *  Project: USB firmware  
....................  *  Author : Lev Solar  
....................  *  Date   : Jan 2001  
....................  *----------------------------------------------------------------------->>>*/  
.................... #ifndef __usb_reg_h__  
.................... #define __usb_reg_h__  
....................   
.................... /*--------------------------------------------------------------------------*/  
.................... /*-----------------------   Configuration Registers   ----------------------*/  
.................... /*--------------------------------------------------------------------------*/  
.................... #define MCNTRL     0x00                 /*Main control register   */  
.................... #define CCONF      0x01                 /*Clk. config. register   */      
.................... #define RID        0x03                 /*Rev. ID      register   */    
.................... #define FAR        0x04                 /*Func address register   */    
.................... #define NFSR       0x05                 /*Node func st register   */     
.................... #define MAEV       0x06                 /*Main event   register   */    
.................... #define MAMSK      0x07                 /*Main mask    register   */    
.................... #define ALTEV      0x08                 /*Alt. event   register   */    
.................... #define ALTMSK     0x09                 /*ALT  mask    register   */    
.................... #define TXEV       0x0A                 /*TX   event   register   */   
.................... #define TXMSK      0x0B                 /*TX   mask    register   */     
.................... #define RXEV       0x0C                 /*RX   event   register   */   
.................... #define RXMSK      0x0D                 /*RX   mask    register   */     
.................... #define NAKEV      0x0E                 /*NAK  event   register   */    
.................... #define NAKMSK     0x0F                 /*NAK  mask    register   */    
.................... #define FWEV       0x10                 /*FIFO warning register   */     
.................... #define FWMSK      0x11                 /*FIFO warning mask       */    
.................... #define FNH        0x12                 /*Frame nbr hi register   */     
.................... #define FNL        0x13                 /*Frame nbr lo register   */    
.................... #define DMACNTRL   0x14                 /*DMA  control register   */    
.................... #define DMAEV	   0x15					/*DMA  event   register	  */  
.................... #define DMAMSK	   0x16					/*DMA  mask	   register   */  
.................... #define DMACNT	   0x18				    /*DMA  count   register   */  
.................... #define DMAERR	   0x19					/*DMA  error counnt register */   
.................... #define WKUP	   0x1b  
....................    
.................... #define EPC0       0x20                 /*Endpoint0    register   */     
.................... #define TXD0       0x21                 /*TX   data    register 0 */    
.................... #define TXS0       0x22                 /*TX   status  register 0 */   
.................... #define TXC0       0x23                 /*TX   command register 0 */    
....................    
.................... #define RXD0       0x25                 /*RX   data    register 0 */     
.................... #define RXS0       0x26                 /*RX   status  register 0 */     
.................... #define RXC0       0x27                 /*RX   command register 0 */     
....................    
.................... #define EPC1       0x28                 /*Endpoint1    register   */     
.................... #define TXD1       0x29                 /*TX   data    register 1 */    
.................... #define TXS1       0x2A                 /*TX   status  register 1 */   
.................... #define TXC1       0x2B                 /*TX   command register 1 */    
....................    
.................... #define EPC2       0x2C                 /*Endpoint2    register   */     
.................... #define RXD1       0x2D                 /*RX   data    register 1 */     
.................... #define RXS1       0x2E                 /*RX   status  register 1 */     
.................... #define RXC1       0x2F                 /*RX   command register 1 */     
....................    
.................... #define EPC3       0x30                 /*Endpoint3    register   */     
.................... #define TXD2       0x31                 /*TX   data    register 2 */    
.................... #define TXS2       0x32                 /*TX   status  register 2 */   
.................... #define TXC2       0x33                 /*TX   command register 2 */    
....................    
.................... #define EPC4       0x34                 /*Endpoint4    register   */     
.................... #define RXD2       0x35                 /*RX   data    register 2 */     
.................... #define RXS2       0x36                 /*RX   status  register 2 */     
.................... #define RXC2       0x37                 /*RX   command register 2 */     
....................    
.................... #define EPC5       0x38                 /*Endpoint5    register   */     
.................... #define TXD3       0x39                 /*TX   data    register 3 */    
.................... #define TXS3       0x3A                 /*TX   status  register 3 */   
.................... #define TXC3       0x3B                 /*TX   command register 3 */    
....................    
.................... #define EPC6       0x3C                 /*Endpoint6    register   */     
.................... #define RXD3       0x3D                 /*RX   data    register 3 */     
.................... #define RXS3       0x3E                 /*RX   status  register 3 */     
.................... #define RXC3       0x3F                 /*RX   command register 3 */     
....................    
.................... /*--------------------------------------------------------------------*/  
.................... /*-------------------   Configuration Register Bitmaps   -------------*/  
.................... /*--------------------------------------------------------------------*/  
....................   
.................... /*-------------------------------- MCNTRL ------------------------*/  
.................... #define SRST       0x01                 /*software reset          */     
.................... #define DBG        0x02                 /*debug mode              */    
.................... #define VGE        0x04                 /*voltage regulator enable*/      
.................... #define NAT        0x08                 /*node attached           */    
.................... #define INT_DIS    0x00                 /*interrupts disabled     */    
.................... #define INT_L_O    0x40                 /*act lo ints, open drain */    
.................... #define INT_H_P    0x80                 /*act hi in	ts, push pull  */    
.................... #define INT_L_P    0xC0                 /*act lo ints, push pull  */    
....................    
.................... /*---------------------------------- FAR -------------------------*/  
.................... #define AD_EN      0x80                 /*address enable          */     
....................    
.................... /*--------------------------------- EPCX -------------------------*/  
.................... #define DEF        0x40                 /*force def. adr (0 only) */     
.................... #define STALL      0x80                 /*force stall handshakes  */    
.................... #define ISO        0x20                 /*set for isochr. (1-3)   */   
.................... #define EP_EN      0x10                 /*enables endpt.  (1-3)   */    
....................    
.................... /*--------------------------------- NFSR -------------------------*/  
.................... #define RST_ST     0x00                 /*reset       state       */     
.................... #define RSM_ST     0x01                 /*resume      state       */    
.................... #define OPR_ST     0x02                 /*operational state       */    
.................... #define SUS_ST     0x03                 /*suspend     state       */    
....................    
.................... /*---------------------------- MAEV, MAMSK -----------------------*/  
.................... #define WARN       0x01                 /*warning bit has been set*/     
.................... #define ALT        0x02                 /*alternate event         */    
.................... #define TX_EV      0x04                 /*transmit event          */    
.................... #define FRAME      0x08                 /*SOF packet received     */    
.................... #define NAK        0x10                 /*NAK event               */    
.................... #define ULD        0x20                 /*unlock locked detected  */     
.................... #define RX_EV      0x40                 /*receive event           */     
.................... #define INTR_E     0x80                 /*master interrupt enable */    
....................    
.................... /*---------------------------- ALTEV, ALTMSK ---------------------*/  
.................... #define ALT_DMA	   0x04					/*DMA event				  */  
.................... #define ALT_EOP    0x08                 /*end of packet           */     
.................... #define ALT_SD3    0x10                 /*3 ms suspend            */    
.................... #define ALT_SD5    0x20                 /*5 ms suspend            */    
.................... #define ALT_RESET  0x40                 /*reset  detected         */    
.................... #define ALT_RESUME 0x80                 /*resume detected         */   
....................    
.................... /*---------------------------- TXEV, TXMSK -----------------------*/  
.................... #define TX_FIFO0    0x01                 /*TX_DONE, FIFO 0         */     
.................... #define TX_FIFO1    0x02                 /*TX_DONE, FIFO 1         */     
.................... #define TX_FIFO2    0x04                 /*TX_DONE, FIFO 2         */     
.................... #define TX_FIFO3    0x08                 /*TX_DONE, FIFO 3         */     
.................... #define TX_UDRN0    0x10                 /*TX_URUN, FIFO 0         */     
.................... #define TX_UDRN1    0x20                 /*TX_URUN, FIFO 1         */    
.................... #define TX_UDRN2    0x40                 /*TX_URUN, FIFO 2         */    
.................... #define TX_UDRN3    0x80                 /*TX_URUN, FIFO 3         */    
....................    
.................... /*---------------------------- RXEV, RXMSK -----------------------*/  
.................... #define RX_FIFO0    0x01                 /*RX_DONE, FIFO 0         */     
.................... #define RX_FIFO1    0x02                 /*RX_DONE, FIFO 1         */     
.................... #define RX_FIFO2    0x04                 /*RX_DONE, FIFO 2         */     
.................... #define RX_FIFO3    0x08                 /*RX_DONE, FIFO 3         */     
.................... #define RX_OVRN0    0x10                 /*RX_OVRN, FIFO 0         */     
.................... #define RX_OVRN1    0x20                 /*RX_OVRN, FIFO 1         */    
.................... #define RX_OVRN2    0x40                 /*RX_OVRN, FIFO 2         */    
.................... #define RX_OVRN3    0x80                 /*RX_OVRN, FIFO 3         */    
....................    
.................... /*-------------------------- NAKEV, NAKMSK -----------------------*/  
.................... #define NAK_IN0		0x01                 /*IN  NAK, FIFO 0         */     
.................... #define NAK_IN1     0x02                 /*IN  NAK, FIFO 1         */    
.................... #define NAK_IN2     0x04                 /*IN  NAK, FIFO 2         */    
.................... #define NAK_IN3     0x08                 /*IN  NAK, FIFO 3         */    
.................... #define NAK_OUT0	0x10                 /*OUT NAK, FIFO 0         */    
.................... #define NAK_OUT1    0x20                 /*OUT NAK, FIFO 1         */   
.................... #define NAK_OUT2    0x40                 /*OUT NAK, FIFO 2         */   
.................... #define NAK_OUT3    0x80                 /*OUT NAK, FIFO 3         */   
....................   
.................... /*-------------------------- DMAEV, DMAMSK ------------------------*/  
.................... #define DMA_DSHLT	0x01				 /*DMA Software Halt	   */  
.................... #define DMA_DERR	0x02				 /*DMA Error			   */  
.................... #define DMA_DCNT	0x04				 /*DMA Count			   */  
.................... #define DMA_DSIZ	0x08				 /*DMA Size				   */  
.................... #define DMA_NTGL	0x20				 /*Next Toggle			   */  
....................    
.................... /*------------------------------ DMACNTRL -------------------------*/  
.................... #define DMA_DMOD	0x08				 /*DMA Mode				   */  
.................... #define DMA_ADMA	0x10				 /*Automatic DMA		   */  
.................... #define DMA_DTGL	0x20				 /*DMA Toggle			   */  
.................... #define IGNRXTGL	0x40				 /*Ignore RX Toggle		   */  
.................... #define	DMA_DEN		0x80				 /*DMA Enable			   */  
....................   
.................... /*------------------------------ DMAERR ---------------------------*/  
.................... #define DMA_AEH		0x80				 /*Automatic Error Handling*/   
....................   
.................... /*------------------------------- TXC0 ---------------------------*/  
.................... #define IGN_IN     0x10                 /*ignore in  tokens       */     
....................   
.................... /*------------------------------- TXCx ---------------------------*/  
.................... #define TX_EN      	0x01                /*transmit enable         */     
.................... #define TX_LAST    	0x02                /*specifies last byte     */   
.................... #define TX_TOGL    	0x04                /*specifies PID used      */   
.................... #define FLUSH      	0x08                /*flushes all FIFO data   */  
.................... #define RFF		  	0x10				/*refill FIFO			  */  
.................... #define IGN_ISOMSK	0x80				/*ignore ISO Mask		  */  
....................   
.................... /*------------------------------- TXS0 ---------------------------*/  
.................... #define TX_EBYTES  0x1F					/*available empty bytes   */  
.................... #define TX_DONE    0x20                 /*transmit done           */     
.................... #define ACK_STAT   0x40                 /*ack status of xmission  */  
....................    
.................... /*------------------------------- RXC0 ---------------------------*/  
.................... #define RX_EN      0x01                 /*receive  enable         */     
.................... #define IGN_OUT    0x02                 /*ignore out tokens       */     
.................... #define IGN_SETUP  0x04                 /*ignore setup tokens     */    
....................   
.................... /*------------------------------- RXSx ---------------------------*/  
.................... #define RX_LAST    0x10                 /*indicates RCOUNT valid  */     
.................... #define RX_TOGL    0x20                 /*last pkt was DATA1 PID  */     
.................... #define SETUP_R    0x40                 /*setup packet received   */    
.................... #define RX_ERR     0x80                 /*last packet had an error*/     
....................   
....................   
.................... #endif __usb_reg_h__  
....................  
....................   
.................... //  
.................... // Forward function declarations  
.................... //  
.................... void usb_init(void);  
.................... int8 usbn_get_version(void);  
....................   
.................... //  
.................... // ISR prototypes and associated handlers  
.................... //  
.................... void usb_isr(void);  
.................... void handle_warn(void);  
.................... void handle_alt(void);  
.................... void handle_txev(void);  
.................... void handle_frame(void);  
.................... void handle_uld(void);  
.................... void handle_rxev(void);  
....................   
.................... //  
.................... // Functions that change with SPI vs. Memory Mapped interfaces  
.................... //  
.................... void usbn_write(int8 address, int8 data);  
.................... int8 usbn_read(int8 address);  
....................   
.................... //  
.................... // USBN9603 endpoints           EP Addressing  
.................... // -----------------------------------------------  
.................... // EP0  TX/RX   8 byte FIFO  
.................... // EP1  TX      64 byte FIFO    bulk 1          WDM "PIPE0"  
.................... // EP2  RX      64 byte FIFO    bulk 2          WDM "PIPE1"  
.................... // EP3  TX      64 byte FIFO    not used  
.................... // EP4  RX      64 byte FIFO    not used  
.................... // EP5  TX      64 byte FIFO    not used  
.................... // EP6  RX      64 byte FIFO    not used  
....................   
.................... //DONT CHANGE THE FOLLOWING 3 CONSTANT ARRAYS  
.................... const char EPCx[]=    {EPC0, EPC1, EPC2, EPC3, EPC4, EPC5, EPC6};   // epc_address[x] finds the constant EPCx  
.................... const char TX_FIFOx[]={TXD0, TXD1, 0,    TXD2, 0,    TXD3, 0};      // ecp0,ecp1,ecp3,ecp5 have tx_fifos  
.................... const char RX_FIFOx[]={RXD0, 0,    RXD1, 0,    RXD2, 0,    RXD3};   // ecp0,ecp2,ecp4,ecp6 have rx_fifos  
....................   
....................   
.................... /// BEGIN User Functions  
....................   
.................... int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];  
.................... int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];  
....................   
....................   
.................... //  
.................... // Types of Xfer's supported in control EP0  
.................... //  
.................... #define     NO_XFER         0  
.................... #define     DEVICE_DESC     1  
.................... #define     CONFIG_DESC     2  
.................... #define     STRING_DESC     3  
.................... #define     ZERO_LEN_XFER   4  
....................   
....................   
.................... struct {  
....................     int8    nXferType;  
....................     int8    nCurPosition;  
....................     int8    nLength;  
....................     int8    nStrIndex;  
.................... } XferEP0;  
....................   
....................   
.................... struct {  
....................     int8    toggle_bit;  
....................     int8    FIFO_status;  
.................... } endpoint_stat[USB_MAX_ENDPOINTS];  
....................   
....................   
.................... typedef enum {  
.................... 		EMPTY,  
.................... 		FULL,  
.................... 		WAIT_FOR_ACK  
.................... } FIFO_status_t;  
....................   
....................   
.................... //  
.................... //  
.................... int8 alt_mask;  
.................... int8 setaddress = 0;  
*
101C:  CLRF   72
....................   
.................... // Bits 0-6 correspond to each endpoint. Bit set = stalled  
.................... // Written by Set/Clear Feature, Read by Get Status  
.................... int8 stalld;  
....................   
.................... // Current USB configuration (only 1 here)  
.................... int8 usb_cfg;  
....................   
.................... void endpoint_status_init(void)  
.................... {  
.................... 	int8 i;  
....................   
.................... 	for(i=0; i<USB_MAX_ENDPOINTS; i++)  
*
06E6:  BSF    03.5
06E7:  CLRF   2C
06E8:  MOVF   2C,W
06E9:  SUBLW  04
06EA:  BTFSS  03.0
06EB:  GOTO   703
....................     {  
....................         endpoint_stat[i].FIFO_status = EMPTY;  
06EC:  BCF    03.0
06ED:  RLF    2C,W
06EE:  ADDLW  01
06EF:  ADDLW  67
06F0:  MOVWF  04
06F1:  CLRF   00
....................         if (i == 0)  
....................         {  
06F2:  MOVF   2C,F
06F3:  BTFSS  03.2
06F4:  GOTO   6FC
....................             //  
....................             // control endpoint - EP0  
....................             //  
....................             endpoint_stat[i].toggle_bit = 0x01;  
06F5:  BCF    03.0
06F6:  RLF    2C,W
06F7:  ADDLW  67
06F8:  MOVWF  04
06F9:  MOVLW  01
06FA:  MOVWF  00
....................         } else {  
06FB:  GOTO   701
....................             //  
....................             // tx & rx data endpoints  
....................             //  
....................             endpoint_stat[i].toggle_bit = 0x00;  
06FC:  BCF    03.0
06FD:  RLF    2C,W
06FE:  ADDLW  67
06FF:  MOVWF  04
0700:  CLRF   00
....................         }  
.................... 	}  
0701:  INCF   2C,F
0702:  GOTO   6E8
....................     return;  
.................... }  
0703:  BCF    03.5
0704:  RETLW  00
....................   
....................   
.................... void reset_usb(void)  
.................... {  
.................... 	usbn_write(EPC0, 0x00);                 // Default addres 0x00 for EP0  
0705:  MOVLW  20
0706:  BSF    03.5
0707:  MOVWF  38
0708:  CLRF   39
0709:  BCF    03.5
070A:  CALL   225
....................     usbn_write(FAR, 0x00);  
070B:  MOVLW  04
070C:  BSF    03.5
070D:  MOVWF  38
070E:  CLRF   39
070F:  BCF    03.5
0710:  CALL   225
....................   
.................... //	usbn_write(FAR, AD_EN | 0x00); // Default device addres in FAR  
.................... //	usbn_write(FAR, usbn_read(FAR) | AD_EN);// Enable FAR addressing  
....................   
....................     usbn_write(TXC0, FLUSH);         // flush fifos  
0711:  MOVLW  23
0712:  BSF    03.5
0713:  MOVWF  38
0714:  MOVLW  08
0715:  MOVWF  39
0716:  BCF    03.5
0717:  CALL   225
....................     usbn_write(TXC1, FLUSH);  
0718:  MOVLW  2B
0719:  BSF    03.5
071A:  MOVWF  38
071B:  MOVLW  08
071C:  MOVWF  39
071D:  BCF    03.5
071E:  CALL   225
....................     usbn_write(TXC2, FLUSH);  
071F:  MOVLW  33
0720:  BSF    03.5
0721:  MOVWF  38
0722:  MOVLW  08
0723:  MOVWF  39
0724:  BCF    03.5
0725:  CALL   225
....................     usbn_write(TXC3, FLUSH);  
0726:  MOVLW  3B
0727:  BSF    03.5
0728:  MOVWF  38
0729:  MOVLW  08
072A:  MOVWF  39
072B:  BCF    03.5
072C:  CALL   225
....................     usbn_write(RXC0, FLUSH);  
072D:  MOVLW  27
072E:  BSF    03.5
072F:  MOVWF  38
0730:  MOVLW  08
0731:  MOVWF  39
0732:  BCF    03.5
0733:  CALL   225
....................     usbn_write(RXC1, FLUSH);  
0734:  MOVLW  2F
0735:  BSF    03.5
0736:  MOVWF  38
0737:  MOVLW  08
0738:  MOVWF  39
0739:  BCF    03.5
073A:  CALL   225
....................     usbn_write(RXC2, FLUSH);  
073B:  MOVLW  37
073C:  BSF    03.5
073D:  MOVWF  38
073E:  MOVLW  08
073F:  MOVWF  39
0740:  BCF    03.5
0741:  CALL   225
....................     usbn_write(RXC3, FLUSH);  
0742:  MOVLW  3F
0743:  BSF    03.5
0744:  MOVWF  38
0745:  MOVLW  08
0746:  MOVWF  39
0747:  BCF    03.5
0748:  CALL   225
....................   
.................... //    usbn_write(EPC0, 0x40);        //  Default address on EP0  
....................   
.................... //    memset(ep0_rx_buffer, 0, USB_MAX_EP0_PACKET_LENGTH);  
.................... //    memset(ep0_tx_buffer, 0, USB_MAX_EP0_PACKET_LENGTH);  
.................... 	endpoint_status_init();  
0749:  CALL   6E6
....................   
.................... 	// Enable the receiver - EP0  
.................... 	usbn_write(RXC0, RX_EN);  
074A:  MOVLW  27
074B:  BSF    03.5
074C:  MOVWF  38
074D:  MOVLW  01
074E:  MOVWF  39
074F:  BCF    03.5
0750:  CALL   225
....................   
....................     return;  
.................... }  
0751:  RETLW  00
....................   
....................   
.................... /*******************************************************************************  
.................... /* usb_init()  
.................... /*  
.................... /* Summary: Resets and initalizes USB code and USBN device.  You must call this  
.................... /*          first before using code.  
.................... /*  
.................... /*          NOTE: this enables interrupts.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_init(void)  
.................... {  
....................     int8  temp;  
....................   
....................     usb_cfg = 0;  
*
110D:  CLRF   74
110E:  CLRF   28
110F:  BTFSC  0B.7
1110:  BSF    28.7
1111:  BCF    0B.7
....................   
....................     usbn_write(MCNTRL, SRST);               // Force the chip to RESET  
1112:  BSF    03.5
1113:  CLRF   38
1114:  MOVLW  01
1115:  MOVWF  39
1116:  BCF    0A.4
1117:  BCF    03.5
1118:  CALL   225
1119:  BSF    0A.4
111A:  BTFSC  28.7
111B:  BSF    0B.7
....................     while (usbn_read(MCNTRL) & SRST);       // and wait for reset to complete  
111C:  CLRF   28
111D:  BTFSC  0B.7
111E:  BSF    28.7
111F:  BCF    0B.7
1120:  BSF    03.5
1121:  CLRF   36
1122:  BCF    0A.4
1123:  BCF    03.5
1124:  CALL   1F0
1125:  BSF    0A.4
1126:  BTFSC  28.7
1127:  BSF    0B.7
1128:  BTFSC  78.0
1129:  GOTO   11C
....................   
....................     usbn_write(CCONF, 0x80);                // Disable clock output  
112A:  CLRF   28
112B:  BTFSC  0B.7
112C:  BSF    28.7
112D:  BCF    0B.7
112E:  MOVLW  01
112F:  BSF    03.5
1130:  MOVWF  38
1131:  MOVLW  80
1132:  MOVWF  39
1133:  BCF    0A.4
1134:  BCF    03.5
1135:  CALL   225
1136:  BSF    0A.4
1137:  BTFSC  28.7
1138:  BSF    0B.7
1139:  CLRF   28
113A:  BTFSC  0B.7
113B:  BSF    28.7
113C:  BCF    0B.7
....................   
....................     usbn_write(MCNTRL, INT_L_P | VGE);      // Active low interrupts + VGE  
113D:  BSF    03.5
113E:  CLRF   38
113F:  MOVLW  C4
1140:  MOVWF  39
1141:  BCF    0A.4
1142:  BCF    03.5
1143:  CALL   225
1144:  BSF    0A.4
1145:  BTFSC  28.7
1146:  BSF    0B.7
1147:  CLRF   28
1148:  BTFSC  0B.7
1149:  BSF    28.7
114A:  BCF    0B.7
....................   
....................     usbn_write(MAMSK, 0x00);                // Mask all interrupt events  
114B:  MOVLW  07
114C:  BSF    03.5
114D:  MOVWF  38
114E:  CLRF   39
114F:  BCF    0A.4
1150:  BCF    03.5
1151:  CALL   225
1152:  BSF    0A.4
1153:  BTFSC  28.7
1154:  BSF    0B.7
1155:  CLRF   28
1156:  BTFSC  0B.7
1157:  BSF    28.7
1158:  BCF    0B.7
....................     usbn_write(NAKMSK, NAK_OUT0);               // NAK mask  
1159:  MOVLW  0F
115A:  BSF    03.5
115B:  MOVWF  38
115C:  MOVLW  10
115D:  MOVWF  39
115E:  BCF    0A.4
115F:  BCF    03.5
1160:  CALL   225
1161:  BSF    0A.4
1162:  BTFSC  28.7
1163:  BSF    0B.7
1164:  CLRF   28
1165:  BTFSC  0B.7
1166:  BSF    28.7
1167:  BCF    0B.7
....................     usbn_write(TXMSK, TX_FIFO0 | TX_FIFO1 | TX_FIFO2 | TX_FIFO3);     // TX mask  | TX_FIFO2 | TX_FIFO3  
1168:  MOVLW  0B
1169:  BSF    03.5
116A:  MOVWF  38
116B:  MOVLW  0F
116C:  MOVWF  39
116D:  BCF    0A.4
116E:  BCF    03.5
116F:  CALL   225
1170:  BSF    0A.4
1171:  BTFSC  28.7
1172:  BSF    0B.7
1173:  CLRF   28
1174:  BTFSC  0B.7
1175:  BSF    28.7
1176:  BCF    0B.7
....................     usbn_write(RXMSK, RX_FIFO0 | RX_FIFO1);     // RX mask  | RX_FIFO2 | RX_FIFO3  
1177:  MOVLW  0D
1178:  BSF    03.5
1179:  MOVWF  38
117A:  MOVLW  03
117B:  MOVWF  39
117C:  BCF    0A.4
117D:  BCF    03.5
117E:  CALL   225
117F:  BSF    0A.4
1180:  BTFSC  28.7
1181:  BSF    0B.7
....................     alt_mask = ALT_SD3 | ALT_RESET;  
1182:  MOVLW  50
1183:  MOVWF  71
1184:  CLRF   28
1185:  BTFSC  0B.7
1186:  BSF    28.7
1187:  BCF    0B.7
....................     usbn_write(ALTMSK, alt_mask);               // ALT mask  
1188:  MOVLW  09
1189:  BSF    03.5
118A:  MOVWF  38
118B:  MOVF   71,W
118C:  MOVWF  39
118D:  BCF    0A.4
118E:  BCF    03.5
118F:  CALL   225
1190:  BSF    0A.4
1191:  BTFSC  28.7
1192:  BSF    0B.7
1193:  CLRF   28
1194:  BTFSC  0B.7
1195:  BSF    28.7
1196:  BCF    0B.7
....................   
....................     usbn_write(MAMSK, INTR_E | RX_EV | NAK | TX_EV | ALT);  // Enable node interrupts  
1197:  MOVLW  07
1198:  BSF    03.5
1199:  MOVWF  38
119A:  MOVLW  D6
119B:  MOVWF  39
119C:  BCF    0A.4
119D:  BCF    03.5
119E:  CALL   225
119F:  BSF    0A.4
11A0:  BTFSC  28.7
11A1:  BSF    0B.7
11A2:  CLRF   28
11A3:  BTFSC  0B.7
11A4:  BSF    28.7
11A5:  BCF    0B.7
....................   
....................     usbn_write(WKUP,0x0C);  
11A6:  MOVLW  1B
11A7:  BSF    03.5
11A8:  MOVWF  38
11A9:  MOVLW  0C
11AA:  MOVWF  39
11AB:  BCF    0A.4
11AC:  BCF    03.5
11AD:  CALL   225
11AE:  BSF    0A.4
11AF:  BTFSC  28.7
11B0:  BSF    0B.7
11B1:  CLRF   28
11B2:  BTFSC  0B.7
11B3:  BSF    28.7
11B4:  BCF    0B.7
....................   
....................     usbn_write(0x1F,0x40);                          // 3.3V regulator work around  
11B5:  MOVLW  1F
11B6:  BSF    03.5
11B7:  MOVWF  38
11B8:  MOVLW  40
11B9:  MOVWF  39
11BA:  BCF    0A.4
11BB:  BCF    03.5
11BC:  CALL   225
11BD:  BSF    0A.4
11BE:  BTFSC  28.7
11BF:  BSF    0B.7
11C0:  CLRF   28
11C1:  BTFSC  0B.7
11C2:  BSF    28.7
11C3:  BCF    0B.7
....................   
.................... //    usbn_write(FWMSK, FWMSK_ENABLES);  
....................   
....................     reset_usb();                                    // Reset USB interface  
11C4:  BCF    0A.4
11C5:  CALL   705
11C6:  BSF    0A.4
11C7:  BTFSC  28.7
11C8:  BSF    0B.7
....................   
....................     ext_int_edge(H_TO_L);                           // Enable the PIC interrupts  
11C9:  BSF    03.5
11CA:  BCF    01.6
....................     enable_interrupts(int_ext);  
11CB:  BCF    03.5
11CC:  BSF    0B.4
....................     enable_interrupts(global);  
11CD:  MOVLW  C0
11CE:  IORWF  0B,F
11CF:  CLRF   28
11D0:  BTFSC  0B.7
11D1:  BSF    28.7
11D2:  BCF    0B.7
....................   
....................     delay_ms(5);                                    // Wait for the 3.3 V regulator to stabilize  
11D3:  MOVLW  05
11D4:  BSF    03.5
11D5:  MOVWF  2C
11D6:  BCF    0A.4
11D7:  BCF    03.5
11D8:  CALL   6D3
11D9:  BSF    0A.4
11DA:  BTFSC  28.7
11DB:  BSF    0B.7
11DC:  CLRF   28
11DD:  BTFSC  0B.7
11DE:  BSF    28.7
11DF:  BCF    0B.7
....................     usbn_write(FAR, AD_EN);  
11E0:  MOVLW  04
11E1:  BSF    03.5
11E2:  MOVWF  38
11E3:  MOVLW  80
11E4:  MOVWF  39
11E5:  BCF    0A.4
11E6:  BCF    03.5
11E7:  CALL   225
11E8:  BSF    0A.4
11E9:  BTFSC  28.7
11EA:  BSF    0B.7
11EB:  CLRF   28
11EC:  BTFSC  0B.7
11ED:  BSF    28.7
11EE:  BCF    0B.7
....................     usbn_write(EPC0, 0);  
11EF:  MOVLW  20
11F0:  BSF    03.5
11F1:  MOVWF  38
11F2:  CLRF   39
11F3:  BCF    0A.4
11F4:  BCF    03.5
11F5:  CALL   225
11F6:  BSF    0A.4
11F7:  BTFSC  28.7
11F8:  BSF    0B.7
11F9:  CLRF   28
11FA:  BTFSC  0B.7
11FB:  BSF    28.7
11FC:  BCF    0B.7
....................     usbn_write(NFSR, OPR_ST);	                    // Go operational  
11FD:  MOVLW  05
11FE:  BSF    03.5
11FF:  MOVWF  38
1200:  MOVLW  02
1201:  MOVWF  39
1202:  BCF    0A.4
1203:  BCF    03.5
1204:  CALL   225
1205:  BSF    0A.4
1206:  BTFSC  28.7
1207:  BSF    0B.7
1208:  CLRF   28
1209:  BTFSC  0B.7
120A:  BSF    28.7
120B:  BCF    0B.7
....................     usbn_write(RXC0, RX_EN);  
120C:  MOVLW  27
120D:  BSF    03.5
120E:  MOVWF  38
120F:  MOVLW  01
1210:  MOVWF  39
1211:  BCF    0A.4
1212:  BCF    03.5
1213:  CALL   225
1214:  BSF    0A.4
1215:  BTFSC  28.7
1216:  BSF    0B.7
1217:  CLRF   28
1218:  BTFSC  0B.7
1219:  BSF    28.7
121A:  BCF    0B.7
....................     usbn_write(MCNTRL, usbn_read(MCNTRL) | NAT);    // Attach node  
121B:  BSF    03.5
121C:  CLRF   36
121D:  BCF    0A.4
121E:  BCF    03.5
121F:  CALL   1F0
1220:  BSF    0A.4
1221:  BTFSC  28.7
1222:  BSF    0B.7
1223:  MOVF   78,W
1224:  IORLW  08
1225:  BSF    03.5
1226:  MOVWF  24
1227:  BCF    03.5
1228:  CLRF   28
1229:  BTFSC  0B.7
122A:  BSF    28.7
122B:  BCF    0B.7
122C:  BSF    03.5
122D:  CLRF   38
122E:  MOVF   24,W
122F:  MOVWF  39
1230:  BCF    0A.4
1231:  BCF    03.5
1232:  CALL   225
1233:  BSF    0A.4
1234:  BTFSC  28.7
1235:  BSF    0B.7
....................     return;  
.................... }  
....................   
....................   
....................   
....................   
.................... /**********************************************************************/  
.................... /* Transmit on USB endpoint 0                                         */  
.................... /*   Must setup structure XP0 before calling this function            */  
.................... /**********************************************************************/  
.................... void XmitOnUSB0(void) {  
.................... 	int8    i = 0;  
*
024B:  BSF    03.5
024C:  CLRF   34
....................     int8    j, Len;  
....................   
....................     //  
....................     //  
....................     j = XferEP0.nCurPosition;  
024D:  BCF    03.5
024E:  MOVF   64,W
024F:  BSF    03.5
0250:  MOVWF  35
....................     if (j > 0x80) {  
0251:  MOVF   35,W
0252:  SUBLW  80
0253:  BTFSC  03.0
0254:  GOTO   257
....................       i = 9;  
0255:  MOVLW  09
0256:  MOVWF  34
....................     }  
....................   
.................... //    memset(ep0_tx_buffer, 0, 8);  
....................   
.................... 	//switch on descriptor type in location 3 (high order of wValue)  
.................... 	switch (XferEP0.nXferType){  
0257:  BCF    03.5
0258:  MOVF   63,W
0259:  MOVWF  77
025A:  MOVF   77,F
025B:  BTFSC  03.2
025C:  GOTO   26E
025D:  MOVLW  01
025E:  SUBWF  77,W
025F:  BTFSC  03.2
0260:  GOTO   272
0261:  MOVLW  02
0262:  SUBWF  77,W
0263:  BTFSC  03.2
0264:  GOTO   295
0265:  MOVLW  03
0266:  SUBWF  77,W
0267:  BTFSC  03.2
0268:  GOTO   2B8
0269:  MOVLW  04
026A:  SUBWF  77,W
026B:  BTFSC  03.2
026C:  GOTO   363
026D:  GOTO   369
....................         case NO_XFER:                   // No xfer - ERROR!  
....................             i = 99;  
026E:  MOVLW  63
026F:  BSF    03.5
0270:  MOVWF  34
....................             break;  
0271:  GOTO   36B
.................... 		case DEVICE_DESC:               // DEVICE descriptor  
.................... 	        // Load the buffer  
....................             for (i=0; i<8; i++) {  
0272:  BSF    03.5
0273:  CLRF   34
0274:  MOVF   34,W
0275:  SUBLW  07
0276:  BTFSS  03.0
0277:  GOTO   294
....................                 if (j > USB_DEVICE_DESC_LEN)  
....................                    i = 9;  
0278:  MOVF   35,W
0279:  SUBLW  12
027A:  BTFSC  03.0
027B:  GOTO   27E
027C:  MOVLW  09
027D:  MOVWF  34
....................   
....................                 ep0_tx_buffer[i] = USB_DEVICE_DESC[j];  
027E:  MOVLW  5B
027F:  ADDWF  34,W
0280:  MOVWF  04
0281:  MOVF   35,W
0282:  BCF    03.5
0283:  CALL   057
0284:  MOVWF  78
0285:  MOVWF  00
....................                 j++;  
0286:  BSF    03.5
0287:  INCF   35,F
....................                 XferEP0.nLength--;  
0288:  BCF    03.5
0289:  DECFSZ 65,F
....................                 if(XferEP0.nLength == 0) {  
028A:  GOTO   291
....................                     XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
028B:  MOVLW  04
028C:  MOVWF  63
....................                     i++;  
028D:  BSF    03.5
028E:  INCF   34,F
....................                     break;  
028F:  GOTO   294
0290:  BCF    03.5
....................                 }  
....................             }  
0291:  BSF    03.5
0292:  INCF   34,F
0293:  GOTO   274
.................... 			break;  
0294:  GOTO   36B
.................... 		case CONFIG_DESC:               // CONFIGURATION descriptor includes INTERFACE and ENDPOINT descriptors  
....................             // Load the buffer  
....................             for (i=0; i<8; i++) {  
0295:  BSF    03.5
0296:  CLRF   34
0297:  MOVF   34,W
0298:  SUBLW  07
0299:  BTFSS  03.0
029A:  GOTO   2B7
....................                 if (j > USB_CONFIG_DESC_TOTAL_LEN)  
....................                     i = 9;  
029B:  MOVF   35,W
029C:  SUBLW  2E
029D:  BTFSC  03.0
029E:  GOTO   2A1
029F:  MOVLW  09
02A0:  MOVWF  34
....................   
....................                 ep0_tx_buffer[i] = USB_CONFIG_DESC[j];  
02A1:  MOVLW  5B
02A2:  ADDWF  34,W
02A3:  MOVWF  04
02A4:  MOVF   35,W
02A5:  BCF    03.5
02A6:  CALL   06D
02A7:  MOVWF  78
02A8:  MOVWF  00
....................                 j++;  
02A9:  BSF    03.5
02AA:  INCF   35,F
....................                 XferEP0.nLength--;  
02AB:  BCF    03.5
02AC:  DECFSZ 65,F
....................                 if(XferEP0.nLength == 0) {  
02AD:  GOTO   2B4
....................                     XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
02AE:  MOVLW  04
02AF:  MOVWF  63
....................                     i++;  
02B0:  BSF    03.5
02B1:  INCF   34,F
....................                     break;  
02B2:  GOTO   2B7
02B3:  BCF    03.5
....................                 }  
....................             }  
02B4:  BSF    03.5
02B5:  INCF   34,F
02B6:  GOTO   297
.................... 			break;  
02B7:  GOTO   36B
....................         case STRING_DESC:               // STRING descriptor  
....................             switch (XferEP0.nStrIndex ) {  
02B8:  MOVF   66,W
02B9:  MOVWF  77
02BA:  MOVF   77,F
02BB:  BTFSC  03.2
02BC:  GOTO   2CE
02BD:  MOVLW  01
02BE:  SUBWF  77,W
02BF:  BTFSC  03.2
02C0:  GOTO   2EB
02C1:  MOVLW  02
02C2:  SUBWF  77,W
02C3:  BTFSC  03.2
02C4:  GOTO   308
02C5:  MOVLW  03
02C6:  SUBWF  77,W
02C7:  BTFSC  03.2
02C8:  GOTO   325
02C9:  MOVLW  04
02CA:  SUBWF  77,W
02CB:  BTFSC  03.2
02CC:  GOTO   342
02CD:  GOTO   360
....................                 case 0:                 // Language ID string  
....................                     // Load the buffer  
....................                     for (i=0; i<8; i++)  {  
02CE:  BSF    03.5
02CF:  CLRF   34
02D0:  MOVF   34,W
02D1:  SUBLW  07
02D2:  BTFSS  03.0
02D3:  GOTO   2EA
....................                         ep0_tx_buffer[i] = USB_STRING_0[j];  
02D4:  MOVLW  5B
02D5:  ADDWF  34,W
02D6:  MOVWF  04
02D7:  MOVF   35,W
02D8:  BCF    03.5
02D9:  CALL   09F
02DA:  MOVWF  78
02DB:  MOVWF  00
....................                         j++;  
02DC:  BSF    03.5
02DD:  INCF   35,F
....................                         XferEP0.nLength--;  
02DE:  BCF    03.5
02DF:  DECFSZ 65,F
....................                         if(XferEP0.nLength == 0) {  
02E0:  GOTO   2E7
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
02E1:  MOVLW  04
02E2:  MOVWF  63
....................                             i++;  
02E3:  BSF    03.5
02E4:  INCF   34,F
....................                             break;  
02E5:  GOTO   2EA
02E6:  BCF    03.5
....................                         }  
....................                     }  
02E7:  BSF    03.5
02E8:  INCF   34,F
02E9:  GOTO   2D0
....................                     break;  
02EA:  GOTO   362
....................                 case 1:                 // Manufacturer string  
....................                     // Load the buffer  
....................                     for (i=0; i<8; i++) {  
02EB:  BSF    03.5
02EC:  CLRF   34
02ED:  MOVF   34,W
02EE:  SUBLW  07
02EF:  BTFSS  03.0
02F0:  GOTO   307
....................                         ep0_tx_buffer[i] = USB_STRING_1[j];  
02F1:  MOVLW  5B
02F2:  ADDWF  34,W
02F3:  MOVWF  04
02F4:  MOVF   35,W
02F5:  BCF    03.5
02F6:  CALL   0A7
02F7:  MOVWF  78
02F8:  MOVWF  00
....................                         j++;  
02F9:  BSF    03.5
02FA:  INCF   35,F
....................                         XferEP0.nLength--;  
02FB:  BCF    03.5
02FC:  DECFSZ 65,F
....................                         if(XferEP0.nLength == 0) {  
02FD:  GOTO   304
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
02FE:  MOVLW  04
02FF:  MOVWF  63
....................                             i++;  
0300:  BSF    03.5
0301:  INCF   34,F
....................                             break;  
0302:  GOTO   307
0303:  BCF    03.5
....................                         }  
....................                     }  
0304:  BSF    03.5
0305:  INCF   34,F
0306:  GOTO   2ED
....................                     break;  
0307:  GOTO   362
....................                 case 2:                 // Device Description string  
....................                     // Load the buffer  
....................                     for (i=0; i<8; i++) {  
0308:  BSF    03.5
0309:  CLRF   34
030A:  MOVF   34,W
030B:  SUBLW  07
030C:  BTFSS  03.0
030D:  GOTO   324
....................                         ep0_tx_buffer[i] = USB_STRING_2[j];  
030E:  MOVLW  5B
030F:  ADDWF  34,W
0310:  MOVWF  04
0311:  MOVF   35,W
0312:  BCF    03.5
0313:  CALL   0E1
0314:  MOVWF  78
0315:  MOVWF  00
....................                         j++;  
0316:  BSF    03.5
0317:  INCF   35,F
....................                         XferEP0.nLength--;  
0318:  BCF    03.5
0319:  DECFSZ 65,F
....................                         if(XferEP0.nLength == 0) {  
031A:  GOTO   321
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
031B:  MOVLW  04
031C:  MOVWF  63
....................                             i++;  
031D:  BSF    03.5
031E:  INCF   34,F
....................                             break;  
031F:  GOTO   324
0320:  BCF    03.5
....................                         }  
....................                     }  
0321:  BSF    03.5
0322:  INCF   34,F
0323:  GOTO   30A
....................                     break;  
0324:  GOTO   362
....................                 case 3:                 // Configuration string  
....................                     // Load the buffer  
....................                     for (i=0; i<8; i++) {  
0325:  BSF    03.5
0326:  CLRF   34
0327:  MOVF   34,W
0328:  SUBLW  07
0329:  BTFSS  03.0
032A:  GOTO   341
....................                         ep0_tx_buffer[i] = USB_STRING_3[j];  
032B:  MOVLW  5B
032C:  ADDWF  34,W
032D:  MOVWF  04
032E:  MOVF   35,W
032F:  BCF    03.5
0330:  CALL   11A
0331:  MOVWF  78
0332:  MOVWF  00
....................                         j++;  
0333:  BSF    03.5
0334:  INCF   35,F
....................                         XferEP0.nLength--;  
0335:  BCF    03.5
0336:  DECFSZ 65,F
....................                         if(XferEP0.nLength == 0) {  
0337:  GOTO   33E
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
0338:  MOVLW  04
0339:  MOVWF  63
....................                             i++;  
033A:  BSF    03.5
033B:  INCF   34,F
....................                             break;  
033C:  GOTO   341
033D:  BCF    03.5
....................                         }  
....................                     }  
033E:  BSF    03.5
033F:  INCF   34,F
0340:  GOTO   327
....................                     break;  
0341:  GOTO   362
....................                 case 4:                 // Interface string  
....................                     // Load the buffer  
....................                     for (i=0; i<8; i++) {  
0342:  BSF    03.5
0343:  CLRF   34
0344:  MOVF   34,W
0345:  SUBLW  07
0346:  BTFSS  03.0
0347:  GOTO   35E
....................                         ep0_tx_buffer[i] = USB_STRING_4[j];  
0348:  MOVLW  5B
0349:  ADDWF  34,W
034A:  MOVWF  04
034B:  MOVF   35,W
034C:  BCF    03.5
034D:  CALL   14C
034E:  MOVWF  78
034F:  MOVWF  00
....................                         j++;  
0350:  BSF    03.5
0351:  INCF   35,F
....................                         XferEP0.nLength--;  
0352:  BCF    03.5
0353:  DECFSZ 65,F
....................                         if(XferEP0.nLength == 0) {  
0354:  GOTO   35B
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer  
0355:  MOVLW  04
0356:  MOVWF  63
....................                             i++;  
0357:  BSF    03.5
0358:  INCF   34,F
....................                             break;  
0359:  GOTO   35E
035A:  BCF    03.5
....................                         }  
....................                     }  
035B:  BSF    03.5
035C:  INCF   34,F
035D:  GOTO   344
....................                     break;  
035E:  GOTO   362
035F:  BCF    03.5
....................                 default:                // Error - unknown string  
....................                     break;  
0360:  BSF    03.5
0361:  GOTO   362
....................             }  
....................             break;  
0362:  GOTO   36B
....................         case ZERO_LEN_XFER:             // Zero length xfer - Sent after other descriptors are sent  
....................             i = j = 0;  
0363:  BSF    03.5
0364:  CLRF   35
0365:  MOVF   35,W
0366:  MOVWF  34
....................             break;  
0367:  GOTO   36B
0368:  BCF    03.5
.................... 		default:  
.................... 			break;  
0369:  BSF    03.5
036A:  GOTO   36B
.................... 	}  
....................   
....................     //  
....................     // Adjust current position for next write  
....................     //  
....................     XferEP0.nCurPosition += i;  
036B:  MOVF   34,W
036C:  BCF    03.5
036D:  ADDWF  64,F
....................     for (j=0; j<i; j++) {  
036E:  BSF    03.5
036F:  CLRF   35
0370:  MOVF   34,W
0371:  SUBWF  35,W
0372:  BTFSC  03.0
0373:  GOTO   382
....................        usbn_write(TXD0, ep0_tx_buffer[j]);  
0374:  MOVLW  5B
0375:  ADDWF  35,W
0376:  MOVWF  04
0377:  MOVF   00,W
0378:  MOVWF  37
0379:  MOVLW  21
037A:  MOVWF  38
037B:  MOVF   37,W
037C:  MOVWF  39
037D:  BCF    03.5
037E:  CALL   225
....................     }  
037F:  BSF    03.5
0380:  INCF   35,F
0381:  GOTO   370
....................   
....................     return;  
.................... }  
0382:  BCF    03.5
0383:  RETLW  00
....................   
....................   
.................... /**********************************************************************/  
.................... /* The GET_DESCRIPTOR request is done here                            */  
.................... /**********************************************************************/  
.................... void getdescriptor(int8 *buf) {  
....................     int8 i;  
....................     //  
....................     // Set the information for sending this descriptor over multiple packets  
....................     //  
....................     XferEP0.nCurPosition = 0;  
*
0463:  BCF    03.5
0464:  CLRF   64
....................     XferEP0.nXferType = buf[3];  
0465:  MOVLW  03
0466:  BSF    03.5
0467:  ADDWF  32,W
0468:  MOVWF  04
0469:  MOVF   00,W
046A:  BCF    03.5
046B:  MOVWF  63
....................     XferEP0.nStrIndex = buf[2];  
046C:  MOVLW  02
046D:  BSF    03.5
046E:  ADDWF  32,W
046F:  MOVWF  04
0470:  MOVF   00,W
0471:  BCF    03.5
0472:  MOVWF  66
....................   
.................... 	//switch on descriptor type in location 3 (high order of wValue)  
.................... 	switch (XferEP0.nXferType){  
0473:  MOVF   63,W
0474:  MOVWF  77
0475:  MOVLW  01
0476:  SUBWF  63,W
0477:  BTFSC  03.2
0478:  GOTO   482
0479:  MOVLW  02
047A:  SUBWF  77,W
047B:  BTFSC  03.2
047C:  GOTO   485
047D:  MOVLW  03
047E:  SUBWF  77,W
047F:  BTFSC  03.2
0480:  GOTO   488
0481:  GOTO   4AF
.................... 		case DEVICE_DESC:               // DEVICE descriptor  
.................... 			XferEP0.nLength = USB_DEVICE_DESC_LEN;  
0482:  MOVLW  12
0483:  MOVWF  65
.................... 			break;  
0484:  GOTO   4B4
.................... 		case CONFIG_DESC:               // CONFIGURATION descriptor includes INTERFACE abd ENDPOINT descriptors  
.................... 			XferEP0.nLength = USB_CONFIG_DESC_TOTAL_LEN;  
0485:  MOVLW  2E
0486:  MOVWF  65
.................... 			break;  
0487:  GOTO   4B4
....................         case STRING_DESC:               // STRING descriptor  
....................                                         // index in location 2 (low order of wValue)  
....................             switch (XferEP0.nStrIndex) {  
0488:  MOVF   66,W
0489:  MOVWF  77
048A:  MOVF   77,F
048B:  BTFSC  03.2
048C:  GOTO   49E
048D:  MOVLW  01
048E:  SUBWF  77,W
048F:  BTFSC  03.2
0490:  GOTO   4A1
0491:  MOVLW  02
0492:  SUBWF  77,W
0493:  BTFSC  03.2
0494:  GOTO   4A4
0495:  MOVLW  03
0496:  SUBWF  77,W
0497:  BTFSC  03.2
0498:  GOTO   4A7
0499:  MOVLW  04
049A:  SUBWF  77,W
049B:  BTFSC  03.2
049C:  GOTO   4AA
049D:  GOTO   4AD
....................                 case 0:                 // Language ID string  
.................... 		            XferEP0.nLength = USB_STRING_0_LEN;  
049E:  MOVLW  04
049F:  MOVWF  65
....................                     break;  
04A0:  GOTO   4AE
....................                 case 1:                 // Manufacturer string  
....................                     XferEP0.nLength = USB_STRING_1_LEN;  
04A1:  MOVLW  36
04A2:  MOVWF  65
....................                     break;  
04A3:  GOTO   4AE
....................                 case 2:                 // Device Description string  
....................                     XferEP0.nLength = USB_STRING_2_LEN;  
04A4:  MOVLW  32
04A5:  MOVWF  65
....................                     break;  
04A6:  GOTO   4AE
....................                 case 3:                 // Configuration string  
....................                     XferEP0.nLength = USB_STRING_3_LEN;  
04A7:  MOVLW  2E
04A8:  MOVWF  65
....................                     break;  
04A9:  GOTO   4AE
....................                 case 4:                 // Interface string  
....................                     XferEP0.nLength = USB_STRING_4_LEN;  
04AA:  MOVLW  2E
04AB:  MOVWF  65
....................                     break;  
04AC:  GOTO   4AE
....................   
....................                 default:                // Error - unknown string  
....................                     return;  
04AD:  GOTO   4C7
....................             }  
....................             break;  
04AE:  GOTO   4B4
.................... 		default:  
....................            i =9 ;  
04AF:  MOVLW  09
04B0:  BSF    03.5
04B1:  MOVWF  33
.................... 			return;  
04B2:  BCF    03.5
04B3:  GOTO   4C7
.................... 	}  
....................   
....................     //  
....................     // Limit the number of bytes to the request length  
....................     //  
.................... 	if(XferEP0.nLength > buf[6])  
....................         XferEP0.nLength = buf[6];  
04B4:  MOVLW  06
04B5:  BSF    03.5
04B6:  ADDWF  32,W
04B7:  MOVWF  04
04B8:  MOVF   00,W
04B9:  BCF    03.5
04BA:  SUBWF  65,W
04BB:  BTFSC  03.2
04BC:  GOTO   4C6
04BD:  BTFSS  03.0
04BE:  GOTO   4C6
04BF:  MOVLW  06
04C0:  BSF    03.5
04C1:  ADDWF  32,W
04C2:  MOVWF  04
04C3:  MOVF   00,W
04C4:  BCF    03.5
04C5:  MOVWF  65
....................   
.................... 	// Start to transmit  
.................... 	XmitOnUSB0();  
04C6:  CALL   24B
.................... }  
....................   
.................... void clrfeature(void)  
.................... {  
....................     switch (ep0_rx_buffer[0]&0x03)      // Find the request target  
....................     {  
*
03AA:  BCF    03.5
03AB:  MOVF   53,W
03AC:  ANDLW  03
03AD:  MOVWF  77
03AE:  MOVF   77,F
03AF:  BTFSC  03.2
03B0:  GOTO   3BA
03B1:  MOVLW  01
03B2:  SUBWF  77,W
03B3:  BTFSC  03.2
03B4:  GOTO   3BB
03B5:  MOVLW  02
03B6:  SUBWF  77,W
03B7:  BTFSC  03.2
03B8:  GOTO   3BC
03B9:  GOTO   454
....................         case 0:                         // DEVICE  
....................             break;  
03BA:  GOTO   455
....................   
....................         case 1:                         // INTERFACE  
....................             break;  
03BB:  GOTO   455
....................   
....................         case 2:                         // ENDPOINT  
....................             //  
....................             // Find the endpoint. Strip off direction bit  
....................             //  
....................             switch (ep0_rx_buffer[4]&0x0F)  
....................             {  
03BC:  MOVF   57,W
03BD:  ANDLW  0F
03BE:  MOVWF  77
03BF:  MOVF   77,F
03C0:  BTFSC  03.2
03C1:  GOTO   3DB
03C2:  MOVLW  01
03C3:  SUBWF  77,W
03C4:  BTFSC  03.2
03C5:  GOTO   3EC
03C6:  MOVLW  02
03C7:  SUBWF  77,W
03C8:  BTFSC  03.2
03C9:  GOTO   3FD
03CA:  MOVLW  03
03CB:  SUBWF  77,W
03CC:  BTFSC  03.2
03CD:  GOTO   40E
03CE:  MOVLW  04
03CF:  SUBWF  77,W
03D0:  BTFSC  03.2
03D1:  GOTO   41F
03D2:  MOVLW  05
03D3:  SUBWF  77,W
03D4:  BTFSC  03.2
03D5:  GOTO   430
03D6:  MOVLW  06
03D7:  SUBWF  77,W
03D8:  BTFSC  03.2
03D9:  GOTO   441
03DA:  GOTO   452
....................                 case 0:  
....................                     usbn_write(EPC0, usbn_read(EPC0) & ~STALL);     // CLEAR_STALL_EP0  
03DB:  MOVLW  20
03DC:  BSF    03.5
03DD:  MOVWF  36
03DE:  BCF    03.5
03DF:  CALL   1F0
03E0:  MOVF   78,W
03E1:  ANDLW  7F
03E2:  BSF    03.5
03E3:  MOVWF  33
03E4:  MOVLW  20
03E5:  MOVWF  38
03E6:  MOVF   33,W
03E7:  MOVWF  39
03E8:  BCF    03.5
03E9:  CALL   225
....................                     bit_clear(stalld,0);  
03EA:  BCF    73.0
....................                     break;  
03EB:  GOTO   453
....................                 case 1:  
....................                     usbn_write(EPC1, usbn_read(EPC1) & ~STALL);     // CLEAR_STALL_EP1  
03EC:  MOVLW  28
03ED:  BSF    03.5
03EE:  MOVWF  36
03EF:  BCF    03.5
03F0:  CALL   1F0
03F1:  MOVF   78,W
03F2:  ANDLW  7F
03F3:  BSF    03.5
03F4:  MOVWF  33
03F5:  MOVLW  28
03F6:  MOVWF  38
03F7:  MOVF   33,W
03F8:  MOVWF  39
03F9:  BCF    03.5
03FA:  CALL   225
....................                     bit_clear(stalld,1);  
03FB:  BCF    73.1
....................                     break;  
03FC:  GOTO   453
....................                 case 2:  
....................                     usbn_write(EPC2, usbn_read(EPC2) & ~STALL);     // CLEAR_STALL_EP2  
03FD:  MOVLW  2C
03FE:  BSF    03.5
03FF:  MOVWF  36
0400:  BCF    03.5
0401:  CALL   1F0
0402:  MOVF   78,W
0403:  ANDLW  7F
0404:  BSF    03.5
0405:  MOVWF  33
0406:  MOVLW  2C
0407:  MOVWF  38
0408:  MOVF   33,W
0409:  MOVWF  39
040A:  BCF    03.5
040B:  CALL   225
....................                     bit_clear(stalld,2);  
040C:  BCF    73.2
....................                     break;  
040D:  GOTO   453
....................                 case 3:  
....................                     usbn_write(EPC3, usbn_read(EPC3) & ~STALL);     // CLEAR_STALL_EP3  
040E:  MOVLW  30
040F:  BSF    03.5
0410:  MOVWF  36
0411:  BCF    03.5
0412:  CALL   1F0
0413:  MOVF   78,W
0414:  ANDLW  7F
0415:  BSF    03.5
0416:  MOVWF  33
0417:  MOVLW  30
0418:  MOVWF  38
0419:  MOVF   33,W
041A:  MOVWF  39
041B:  BCF    03.5
041C:  CALL   225
....................                     bit_clear(stalld,3);  
041D:  BCF    73.3
....................                     break;  
041E:  GOTO   453
....................                 case 4:  
....................                     usbn_write(EPC4, usbn_read(EPC4) & ~STALL);     // CLEAR_STALL_EP4  
041F:  MOVLW  34
0420:  BSF    03.5
0421:  MOVWF  36
0422:  BCF    03.5
0423:  CALL   1F0
0424:  MOVF   78,W
0425:  ANDLW  7F
0426:  BSF    03.5
0427:  MOVWF  33
0428:  MOVLW  34
0429:  MOVWF  38
042A:  MOVF   33,W
042B:  MOVWF  39
042C:  BCF    03.5
042D:  CALL   225
....................                     bit_clear(stalld,4);  
042E:  BCF    73.4
....................                     break;  
042F:  GOTO   453
....................                 case 5:  
....................                     usbn_write(EPC5, usbn_read(EPC5) & ~STALL);     // CLEAR_STALL_EP5  
0430:  MOVLW  38
0431:  BSF    03.5
0432:  MOVWF  36
0433:  BCF    03.5
0434:  CALL   1F0
0435:  MOVF   78,W
0436:  ANDLW  7F
0437:  BSF    03.5
0438:  MOVWF  33
0439:  MOVLW  38
043A:  MOVWF  38
043B:  MOVF   33,W
043C:  MOVWF  39
043D:  BCF    03.5
043E:  CALL   225
....................                     bit_clear(stalld,5);  
043F:  BCF    73.5
....................                     break;  
0440:  GOTO   453
....................                 case 6:  
....................                     usbn_write(EPC6, usbn_read(EPC6) & ~STALL);     // CLEAR_STALL_EP6  
0441:  MOVLW  3C
0442:  BSF    03.5
0443:  MOVWF  36
0444:  BCF    03.5
0445:  CALL   1F0
0446:  MOVF   78,W
0447:  ANDLW  7F
0448:  BSF    03.5
0449:  MOVWF  33
044A:  MOVLW  3C
044B:  MOVWF  38
044C:  MOVF   33,W
044D:  MOVWF  39
044E:  BCF    03.5
044F:  CALL   225
....................                     bit_clear(stalld,6);  
0450:  BCF    73.6
....................                     break;  
0451:  GOTO   453
....................                 default:  
....................                     break;  
0452:  GOTO   453
....................             }  
....................             break;  
0453:  GOTO   455
....................   
....................         default:                        // UNDEFINED  
....................             break;  
0454:  GOTO   455
....................     }  
....................     return;  
.................... }  
....................   
.................... void setconfiguration(void)  
.................... {  
....................     int8 i;  
....................   
....................     usb_cfg = ep0_rx_buffer[2];         // Save off the configuration #  
*
0591:  BCF    03.5
0592:  MOVF   55,W
0593:  MOVWF  74
....................   
....................     if (ep0_rx_buffer[2] != 0)          // Non-zero = set the configuration  
....................     {  
0594:  MOVF   55,F
0595:  BTFSC  03.2
0596:  GOTO   5EB
....................         // First PID is DATA0  
....................         // Don't muck with EP0  
.................... 	    for(i=1; i<USB_MAX_ENDPOINTS; i++)  
0597:  MOVLW  01
0598:  BSF    03.5
0599:  MOVWF  32
059A:  MOVF   32,W
059B:  SUBLW  04
059C:  BTFSS  03.0
059D:  GOTO   5AB
....................         {  
....................             endpoint_stat[i].toggle_bit = 0x00;  
059E:  BCF    03.0
059F:  RLF    32,W
05A0:  ADDLW  67
05A1:  MOVWF  04
05A2:  CLRF   00
....................             endpoint_stat[i].FIFO_status = EMPTY;  
05A3:  BCF    03.0
05A4:  RLF    32,W
05A5:  ADDLW  01
05A6:  ADDLW  67
05A7:  MOVWF  04
05A8:  CLRF   00
....................         }  
05A9:  INCF   32,F
05AA:  GOTO   59A
....................   
....................         stalld = 0;                     // Nothing stalled yet  
05AB:  CLRF   73
....................   
....................         // Enable Pipe 0, EPC1, address 1  
....................         usbn_write(TXC1,FLUSH);         // Flush  TX1 and disable  
05AC:  MOVLW  2B
05AD:  MOVWF  38
05AE:  MOVLW  08
05AF:  MOVWF  39
05B0:  BCF    03.5
05B1:  CALL   225
....................         usbn_write(EPC1,EP_EN+01);      // Enable EP1 at adr 1  
05B2:  MOVLW  28
05B3:  BSF    03.5
05B4:  MOVWF  38
05B5:  MOVLW  11
05B6:  MOVWF  39
05B7:  BCF    03.5
05B8:  CALL   225
....................   
....................         // Enable Pipe 1, EPC2, address 2  
....................         usbn_write(RXC1,FLUSH);         // Flush  RX1 and disable  
05B9:  MOVLW  2F
05BA:  BSF    03.5
05BB:  MOVWF  38
05BC:  MOVLW  08
05BD:  MOVWF  39
05BE:  BCF    03.5
05BF:  CALL   225
....................         usbn_write(EPC2,EP_EN+02);      // Enable EP2 at adr 2  
05C0:  MOVLW  2C
05C1:  BSF    03.5
05C2:  MOVWF  38
05C3:  MOVLW  12
05C4:  MOVWF  39
05C5:  BCF    03.5
05C6:  CALL   225
....................         usbn_write(RXC1,RX_EN);         // Enable RX1  
05C7:  MOVLW  2F
05C8:  BSF    03.5
05C9:  MOVWF  38
05CA:  MOVLW  01
05CB:  MOVWF  39
05CC:  BCF    03.5
05CD:  CALL   225
....................   
....................         // Enable Pipe 2, EPC3, address 3  
....................         usbn_write(TXC2,FLUSH);         // Flush  TX1 and disable  
05CE:  MOVLW  33
05CF:  BSF    03.5
05D0:  MOVWF  38
05D1:  MOVLW  08
05D2:  MOVWF  39
05D3:  BCF    03.5
05D4:  CALL   225
....................         usbn_write(EPC3,EP_EN+03);      // Enable EP1 at adr 3  
05D5:  MOVLW  30
05D6:  BSF    03.5
05D7:  MOVWF  38
05D8:  MOVLW  13
05D9:  MOVWF  39
05DA:  BCF    03.5
05DB:  CALL   225
....................   
....................         // Enable Pipe 3, EPC5, address 4  
....................         usbn_write(TXC3,FLUSH);         // Flush  TX1 and disable  
05DC:  MOVLW  3B
05DD:  BSF    03.5
05DE:  MOVWF  38
05DF:  MOVLW  08
05E0:  MOVWF  39
05E1:  BCF    03.5
05E2:  CALL   225
....................         usbn_write(EPC5,EP_EN+04);      // Enable EP1 at adr 4  
05E3:  MOVLW  38
05E4:  BSF    03.5
05E5:  MOVWF  38
05E6:  MOVLW  14
05E7:  MOVWF  39
05E8:  BCF    03.5
05E9:  CALL   225
....................   
....................     } else {                            // Zero = unconfigure the device  
05EA:  GOTO   60F
....................   
....................         usbn_write(EPC1,0);             // Disable EP1  
05EB:  MOVLW  28
05EC:  BSF    03.5
05ED:  MOVWF  38
05EE:  CLRF   39
05EF:  BCF    03.5
05F0:  CALL   225
....................         usbn_write(EPC2,0);             // Disable EP2  
05F1:  MOVLW  2C
05F2:  BSF    03.5
05F3:  MOVWF  38
05F4:  CLRF   39
05F5:  BCF    03.5
05F6:  CALL   225
....................         usbn_write(EPC3,0);             // Disable EP3  
05F7:  MOVLW  30
05F8:  BSF    03.5
05F9:  MOVWF  38
05FA:  CLRF   39
05FB:  BCF    03.5
05FC:  CALL   225
....................         usbn_write(EPC4,0);             // Disable EP4  
05FD:  MOVLW  34
05FE:  BSF    03.5
05FF:  MOVWF  38
0600:  CLRF   39
0601:  BCF    03.5
0602:  CALL   225
....................         usbn_write(EPC5,0);             // Disable EP5  
0603:  MOVLW  38
0604:  BSF    03.5
0605:  MOVWF  38
0606:  CLRF   39
0607:  BCF    03.5
0608:  CALL   225
....................         usbn_write(EPC6,0);             // Disable EP6  
0609:  MOVLW  3C
060A:  BSF    03.5
060B:  MOVWF  38
060C:  CLRF   39
060D:  BCF    03.5
060E:  CALL   225
....................     }  
....................     return;  
.................... }  
....................   
....................   
.................... void setfeature(void)  
.................... {  
....................     switch (ep0_rx_buffer[0]&0x03)      // Find the request target  
....................     {  
*
0613:  BCF    03.5
0614:  MOVF   53,W
0615:  ANDLW  03
0616:  MOVWF  77
0617:  MOVF   77,F
0618:  BTFSC  03.2
0619:  GOTO   623
061A:  MOVLW  01
061B:  SUBWF  77,W
061C:  BTFSC  03.2
061D:  GOTO   624
061E:  MOVLW  02
061F:  SUBWF  77,W
0620:  BTFSC  03.2
0621:  GOTO   625
0622:  GOTO   6AE
....................         case 0:                         // DEVICE  
....................             break;  
0623:  GOTO   6AF
....................   
....................         case 1:                         // INTERFACE  
....................             break;  
0624:  GOTO   6AF
....................   
....................         case 2:                         // ENDPOINT  
....................             //  
....................             // Find the endpoint. Strip off direction bit  
....................             //  
....................             switch (ep0_rx_buffer[4]&0x0F)  
....................             {  
0625:  MOVF   57,W
0626:  ANDLW  0F
0627:  MOVWF  77
0628:  MOVF   77,F
0629:  BTFSC  03.2
062A:  GOTO   644
062B:  MOVLW  01
062C:  SUBWF  77,W
062D:  BTFSC  03.2
062E:  GOTO   646
062F:  MOVLW  02
0630:  SUBWF  77,W
0631:  BTFSC  03.2
0632:  GOTO   657
0633:  MOVLW  03
0634:  SUBWF  77,W
0635:  BTFSC  03.2
0636:  GOTO   668
0637:  MOVLW  04
0638:  SUBWF  77,W
0639:  BTFSC  03.2
063A:  GOTO   679
063B:  MOVLW  05
063C:  SUBWF  77,W
063D:  BTFSC  03.2
063E:  GOTO   68A
063F:  MOVLW  06
0640:  SUBWF  77,W
0641:  BTFSC  03.2
0642:  GOTO   69B
0643:  GOTO   6AC
....................                 case 0:  
....................                     // Control pipes must accept setup requests even if  
....................                     // stalled. So we log the stall here, but don't actually do it  
....................                     // usbn_write(EPC0, usbn_read(EPC0) | STALL);      // STALL EP0  
....................                     bit_set(stalld,0);  
0644:  BSF    73.0
....................                     break;  
0645:  GOTO   6AD
....................                 case 1:  
....................                     usbn_write(EPC1, usbn_read(EPC1) | STALL);      // STALL EP1  
0646:  MOVLW  28
0647:  BSF    03.5
0648:  MOVWF  36
0649:  BCF    03.5
064A:  CALL   1F0
064B:  MOVF   78,W
064C:  IORLW  80
064D:  BSF    03.5
064E:  MOVWF  33
064F:  MOVLW  28
0650:  MOVWF  38
0651:  MOVF   33,W
0652:  MOVWF  39
0653:  BCF    03.5
0654:  CALL   225
....................                     bit_set(stalld,1);  
0655:  BSF    73.1
....................                     break;  
0656:  GOTO   6AD
....................                 case 2:  
....................                     usbn_write(EPC2, usbn_read(EPC2) | STALL);      // STALL EP2  
0657:  MOVLW  2C
0658:  BSF    03.5
0659:  MOVWF  36
065A:  BCF    03.5
065B:  CALL   1F0
065C:  MOVF   78,W
065D:  IORLW  80
065E:  BSF    03.5
065F:  MOVWF  33
0660:  MOVLW  2C
0661:  MOVWF  38
0662:  MOVF   33,W
0663:  MOVWF  39
0664:  BCF    03.5
0665:  CALL   225
....................                     bit_set(stalld,2);  
0666:  BSF    73.2
....................                     break;  
0667:  GOTO   6AD
....................                 case 3:  
....................                     usbn_write(EPC3, usbn_read(EPC3) | STALL);      // STALL EP3  
0668:  MOVLW  30
0669:  BSF    03.5
066A:  MOVWF  36
066B:  BCF    03.5
066C:  CALL   1F0
066D:  MOVF   78,W
066E:  IORLW  80
066F:  BSF    03.5
0670:  MOVWF  33
0671:  MOVLW  30
0672:  MOVWF  38
0673:  MOVF   33,W
0674:  MOVWF  39
0675:  BCF    03.5
0676:  CALL   225
....................                     bit_set(stalld,3);  
0677:  BSF    73.3
....................                     break;  
0678:  GOTO   6AD
....................                 case 4:  
....................                     usbn_write(EPC4, usbn_read(EPC4) | STALL);      // STALL EP4  
0679:  MOVLW  34
067A:  BSF    03.5
067B:  MOVWF  36
067C:  BCF    03.5
067D:  CALL   1F0
067E:  MOVF   78,W
067F:  IORLW  80
0680:  BSF    03.5
0681:  MOVWF  33
0682:  MOVLW  34
0683:  MOVWF  38
0684:  MOVF   33,W
0685:  MOVWF  39
0686:  BCF    03.5
0687:  CALL   225
....................                     bit_set(stalld,4);  
0688:  BSF    73.4
....................                     break;  
0689:  GOTO   6AD
....................                 case 5:  
....................                     usbn_write(EPC5, usbn_read(EPC5) | STALL);      // STALL EP5  
068A:  MOVLW  38
068B:  BSF    03.5
068C:  MOVWF  36
068D:  BCF    03.5
068E:  CALL   1F0
068F:  MOVF   78,W
0690:  IORLW  80
0691:  BSF    03.5
0692:  MOVWF  33
0693:  MOVLW  38
0694:  MOVWF  38
0695:  MOVF   33,W
0696:  MOVWF  39
0697:  BCF    03.5
0698:  CALL   225
....................                     bit_set(stalld,5);  
0699:  BSF    73.5
....................                     break;  
069A:  GOTO   6AD
....................                 case 6:  
....................                     usbn_write(EPC6, usbn_read(EPC6) | STALL);      // STALL EP6  
069B:  MOVLW  3C
069C:  BSF    03.5
069D:  MOVWF  36
069E:  BCF    03.5
069F:  CALL   1F0
06A0:  MOVF   78,W
06A1:  IORLW  80
06A2:  BSF    03.5
06A3:  MOVWF  33
06A4:  MOVLW  3C
06A5:  MOVWF  38
06A6:  MOVF   33,W
06A7:  MOVWF  39
06A8:  BCF    03.5
06A9:  CALL   225
....................                     bit_set(stalld,6);  
06AA:  BSF    73.6
....................                     break;  
06AB:  GOTO   6AD
....................                 default:  
....................                     break;  
06AC:  GOTO   6AD
....................             }  
....................             break;  
06AD:  GOTO   6AF
....................   
....................         default:                        // UNDEFINED  
....................             break;  
06AE:  GOTO   6AF
....................     }  
....................     return;  
.................... }  
....................   
.................... void getstatus(void)  
.................... {  
....................     switch (ep0_rx_buffer[0]&0x03)      // Find the request target  
....................     {  
*
04C8:  MOVF   53,W
04C9:  ANDLW  03
04CA:  MOVWF  77
04CB:  MOVF   77,F
04CC:  BTFSC  03.2
04CD:  GOTO   4D7
04CE:  MOVLW  01
04CF:  SUBWF  77,W
04D0:  BTFSC  03.2
04D1:  GOTO   4DE
04D2:  MOVLW  02
04D3:  SUBWF  77,W
04D4:  BTFSC  03.2
04D5:  GOTO   4E5
04D6:  GOTO   57D
....................         case 0:                         // DEVICE  
....................             usbn_write(TXD0,0);         // First byte is reserved  
04D7:  MOVLW  21
04D8:  BSF    03.5
04D9:  MOVWF  38
04DA:  CLRF   39
04DB:  BCF    03.5
04DC:  CALL   225
....................             break;  
04DD:  GOTO   583
....................   
....................         case 1:                         // INTERFACE  
....................             usbn_write(TXD0,0);         // First byte is reserved  
04DE:  MOVLW  21
04DF:  BSF    03.5
04E0:  MOVWF  38
04E1:  CLRF   39
04E2:  BCF    03.5
04E3:  CALL   225
....................             break;  
04E4:  GOTO   583
....................   
....................         case 2:                         // ENDPOINT  
....................             //  
....................             // Find the endpoint. Strip off direction bit  
....................             //  
....................             switch (ep0_rx_buffer[4]&0x0F)  
....................             {  
04E5:  MOVF   57,W
04E6:  ANDLW  0F
04E7:  MOVWF  77
04E8:  MOVF   77,F
04E9:  BTFSC  03.2
04EA:  GOTO   504
04EB:  MOVLW  01
04EC:  SUBWF  77,W
04ED:  BTFSC  03.2
04EE:  GOTO   515
04EF:  MOVLW  02
04F0:  SUBWF  77,W
04F1:  BTFSC  03.2
04F2:  GOTO   526
04F3:  MOVLW  03
04F4:  SUBWF  77,W
04F5:  BTFSC  03.2
04F6:  GOTO   537
04F7:  MOVLW  04
04F8:  SUBWF  77,W
04F9:  BTFSC  03.2
04FA:  GOTO   548
04FB:  MOVLW  05
04FC:  SUBWF  77,W
04FD:  BTFSC  03.2
04FE:  GOTO   559
04FF:  MOVLW  06
0500:  SUBWF  77,W
0501:  BTFSC  03.2
0502:  GOTO   56A
0503:  GOTO   57B
....................                 case 0:  
....................                     if (bit_test(stalld, 0))    // EP0  
....................                         usbn_write(TXD0,1);  
0504:  BTFSS  73.0
0505:  GOTO   50E
0506:  MOVLW  21
0507:  BSF    03.5
0508:  MOVWF  38
0509:  MOVLW  01
050A:  MOVWF  39
050B:  BCF    03.5
050C:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
050D:  GOTO   514
050E:  MOVLW  21
050F:  BSF    03.5
0510:  MOVWF  38
0511:  CLRF   39
0512:  BCF    03.5
0513:  CALL   225
....................                     break;  
0514:  GOTO   57C
....................                 case 1:  
....................                     if (bit_test(stalld, 1))    // EP1  
....................                         usbn_write(TXD0,1);  
0515:  BTFSS  73.1
0516:  GOTO   51F
0517:  MOVLW  21
0518:  BSF    03.5
0519:  MOVWF  38
051A:  MOVLW  01
051B:  MOVWF  39
051C:  BCF    03.5
051D:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
051E:  GOTO   525
051F:  MOVLW  21
0520:  BSF    03.5
0521:  MOVWF  38
0522:  CLRF   39
0523:  BCF    03.5
0524:  CALL   225
....................                     break;  
0525:  GOTO   57C
....................                 case 2:  
....................                     if (bit_test(stalld, 2))    // EP2  
....................                         usbn_write(TXD0,1);  
0526:  BTFSS  73.2
0527:  GOTO   530
0528:  MOVLW  21
0529:  BSF    03.5
052A:  MOVWF  38
052B:  MOVLW  01
052C:  MOVWF  39
052D:  BCF    03.5
052E:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
052F:  GOTO   536
0530:  MOVLW  21
0531:  BSF    03.5
0532:  MOVWF  38
0533:  CLRF   39
0534:  BCF    03.5
0535:  CALL   225
....................                     break;  
0536:  GOTO   57C
....................                 case 3:  
....................                     if (bit_test(stalld, 3))    // EP3  
....................                         usbn_write(TXD0,1);  
0537:  BTFSS  73.3
0538:  GOTO   541
0539:  MOVLW  21
053A:  BSF    03.5
053B:  MOVWF  38
053C:  MOVLW  01
053D:  MOVWF  39
053E:  BCF    03.5
053F:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
0540:  GOTO   547
0541:  MOVLW  21
0542:  BSF    03.5
0543:  MOVWF  38
0544:  CLRF   39
0545:  BCF    03.5
0546:  CALL   225
....................                     break;  
0547:  GOTO   57C
....................                 case 4:  
....................                     if (bit_test(stalld, 4))    // EP4  
....................                         usbn_write(TXD0,1);  
0548:  BTFSS  73.4
0549:  GOTO   552
054A:  MOVLW  21
054B:  BSF    03.5
054C:  MOVWF  38
054D:  MOVLW  01
054E:  MOVWF  39
054F:  BCF    03.5
0550:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
0551:  GOTO   558
0552:  MOVLW  21
0553:  BSF    03.5
0554:  MOVWF  38
0555:  CLRF   39
0556:  BCF    03.5
0557:  CALL   225
....................                     break;  
0558:  GOTO   57C
....................                 case 5:  
....................                     if (bit_test(stalld, 5))    // EP5  
....................                         usbn_write(TXD0,1);  
0559:  BTFSS  73.5
055A:  GOTO   563
055B:  MOVLW  21
055C:  BSF    03.5
055D:  MOVWF  38
055E:  MOVLW  01
055F:  MOVWF  39
0560:  BCF    03.5
0561:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
0562:  GOTO   569
0563:  MOVLW  21
0564:  BSF    03.5
0565:  MOVWF  38
0566:  CLRF   39
0567:  BCF    03.5
0568:  CALL   225
....................                     break;  
0569:  GOTO   57C
....................                 case 6:  
....................                     if (bit_test(stalld, 6))    // EP6  
....................                         usbn_write(TXD0,1);  
056A:  BTFSS  73.6
056B:  GOTO   574
056C:  MOVLW  21
056D:  BSF    03.5
056E:  MOVWF  38
056F:  MOVLW  01
0570:  MOVWF  39
0571:  BCF    03.5
0572:  CALL   225
....................                     else  
....................                         usbn_write(TXD0,0);  
0573:  GOTO   57A
0574:  MOVLW  21
0575:  BSF    03.5
0576:  MOVWF  38
0577:  CLRF   39
0578:  BCF    03.5
0579:  CALL   225
....................                     break;  
057A:  GOTO   57C
....................                 default:  
....................                     break;  
057B:  GOTO   57C
....................             }  
....................             break;  
057C:  GOTO   583
....................   
....................         default:                        // UNDEFINED  
....................             usbn_write(TXD0,0);         // First byte is reserved  
057D:  MOVLW  21
057E:  BSF    03.5
057F:  MOVWF  38
0580:  CLRF   39
0581:  BCF    03.5
0582:  CALL   225
....................             break;  
....................     }  
....................     usbn_write(TXD0,0);                 // Second byte is reserved  
0583:  MOVLW  21
0584:  BSF    03.5
0585:  MOVWF  38
0586:  CLRF   39
0587:  BCF    03.5
0588:  CALL   225
....................     return;  
.................... }  
....................   
.................... //  
.................... // #separate means not #inline  
.................... //  
.................... #separate  
.................... void handle_setup()  
.................... {  
....................     int8 i;  
....................   
....................     if ((ep0_rx_buffer[0] & 0x60) == 0x00)      // if a standard request  
....................     {  
*
0384:  MOVF   53,W
0385:  ANDLW  60
0386:  XORLW  00
0387:  BTFSS  03.2
0388:  GOTO   6B6
....................         switch (ep0_rx_buffer[1]) {             // find request target  
0389:  MOVF   54,W
038A:  MOVWF  77
038B:  MOVLW  01
038C:  SUBWF  77,W
038D:  BTFSC  03.2
038E:  GOTO   3A7
038F:  MOVLW  08
0390:  SUBWF  77,W
0391:  BTFSC  03.2
0392:  GOTO   456
0393:  MOVLW  06
0394:  SUBWF  77,W
0395:  BTFSC  03.2
0396:  GOTO   460
0397:  MOVF   77,F
0398:  BTFSC  03.2
0399:  GOTO   4C8
039A:  MOVLW  05
039B:  SUBWF  77,W
039C:  BTFSC  03.2
039D:  GOTO   58A
039E:  MOVLW  09
039F:  SUBWF  77,W
03A0:  BTFSC  03.2
03A1:  GOTO   58E
03A2:  MOVLW  03
03A3:  SUBWF  77,W
03A4:  BTFSC  03.2
03A5:  GOTO   610
03A6:  GOTO   6B0
....................   
....................             case CLEAR_FEATURE:                 // CLEAR Feature (device = remote wakeip, endpoint = stall)  
....................                 i = 1;  
03A7:  MOVLW  01
03A8:  BSF    03.5
03A9:  MOVWF  31
....................                 clrfeature();  
....................                 break;  
*
0455:  GOTO   6B5
....................   
....................             case GET_CONFIGURATION:  
....................                 i = 2;  
0456:  MOVLW  02
0457:  BSF    03.5
0458:  MOVWF  31
....................                 usbn_write(TXD0, usb_cfg);      // Only have one configuration - return value from setconfiguration()  
0459:  MOVLW  21
045A:  MOVWF  38
045B:  MOVF   74,W
045C:  MOVWF  39
045D:  BCF    03.5
045E:  CALL   225
....................                 break;  
045F:  GOTO   6B5
....................   
....................             case GET_DESCRIPTOR:  
....................                 getdescriptor(ep0_rx_buffer);   // Process the descriptor request  
0460:  MOVLW  53
0461:  BSF    03.5
0462:  MOVWF  32
....................                 break;  
*
04C7:  GOTO   6B5
....................   
....................             case GET_STATUS:                    // GET status (endpoint = stall)  
....................                 getstatus();  
....................                 break;  
*
0589:  GOTO   6B5
....................   
....................             case SET_ADDRESS:  
....................                 //  
....................                 // Save off the new address, but do not set until the TX handshake completes  
....................                 //  
....................                 setaddress = ep0_rx_buffer[2] | AD_EN;  
058A:  MOVF   55,W
058B:  IORLW  80
058C:  MOVWF  72
....................                 break;  
058D:  GOTO   6B5
....................   
....................             case SET_CONFIGURATION:  
....................                 i = 3;  
058E:  MOVLW  03
058F:  BSF    03.5
0590:  MOVWF  31
....................                 setconfiguration();  
....................                 break;  
*
060F:  GOTO   6B5
....................   
....................             case SET_FEATURE:                   // SET Feature (device = remote wakeip, endpoint = stall)  
....................                 i = 4;  
0610:  MOVLW  04
0611:  BSF    03.5
0612:  MOVWF  31
....................                 setfeature();  
....................                 break;  
*
06AF:  GOTO   6B5
....................   
....................             default:  
....................                 i = 5;  
06B0:  MOVLW  05
06B1:  BSF    03.5
06B2:  MOVWF  31
....................                 //unsupported standard req  
....................                 break;  
06B3:  BCF    03.5
06B4:  GOTO   6B5
.................... 	        } // end switch  
....................     } else {  
06B5:  GOTO   6BA
....................         i =9;  
06B6:  MOVLW  09
06B7:  BSF    03.5
06B8:  MOVWF  31
06B9:  BCF    03.5
....................     }  
....................   
....................     // Start with TOGGLE = 1  
....................     endpoint_stat[0].toggle_bit = 0x01;  
06BA:  MOVLW  01
06BB:  MOVWF  67
....................     i = endpoint_stat[0].toggle_bit << 2;  
06BC:  RLF    67,W
06BD:  BSF    03.5
06BE:  MOVWF  31
06BF:  RLF    31,F
06C0:  MOVLW  FC
06C1:  ANDWF  31,F
....................   
....................     // the following is done for all setup packets.  Note that if  
....................     // no data was stuffed into the FIFO, the result of the fol-  
....................     // lowing will be a zero-length response.  
....................   
....................     usbn_write(TXC0, TX_EN | i);   // enable the TX (DATA1) and toggle PID  
06C2:  MOVF   31,W
06C3:  IORLW  01
06C4:  MOVWF  32
06C5:  MOVLW  23
06C6:  MOVWF  38
06C7:  MOVF   32,W
06C8:  MOVWF  39
06C9:  BCF    03.5
06CA:  CALL   225
....................   
....................     endpoint_stat[0].toggle_bit ^= 0x01;  
06CB:  MOVLW  01
06CC:  XORWF  67,F
....................     return;  
.................... }  
06CD:  BSF    0A.3
06CE:  BCF    0A.4
06CF:  GOTO   092 (RETURN)
....................   
....................   
.................... void tx_1(void)  
.................... {  
....................     int8    txstat;  
....................   
....................     txstat = usbn_read(TXS1);       // Get transmitter status  
*
09DC:  MOVLW  2A
09DD:  BSF    03.5
09DE:  MOVWF  36
09DF:  BCF    0A.3
09E0:  BCF    03.5
09E1:  CALL   1F0
09E2:  BSF    0A.3
09E3:  MOVF   78,W
09E4:  BSF    03.5
09E5:  MOVWF  2F
....................     usbn_write(TXC1, FLUSH);        // Flush the FIFO  
09E6:  MOVLW  2B
09E7:  MOVWF  38
09E8:  MOVLW  08
09E9:  MOVWF  39
09EA:  BCF    0A.3
09EB:  BCF    03.5
09EC:  CALL   225
09ED:  BSF    0A.3
....................     //  
....................     // If a transmission has completed successfully, update the data and toggle the PID  
....................     //  
....................     if ((txstat & ACK_STAT) && (txstat & TX_DONE)) {  
09EE:  BSF    03.5
09EF:  BTFSS  2F.6
09F0:  GOTO   1F9
09F1:  BTFSS  2F.5
09F2:  GOTO   1F9
....................         // This is where we know there's been a successful transmission to Host.  
....................         // So we can re-enable RX1 for reception. Allowing new commands  
....................         //  
....................         endpoint_stat[1].toggle_bit ^= 0x01;    // Flip the PID bit on EP1  
09F3:  MOVLW  01
09F4:  BCF    03.5
09F5:  XORWF  69,F
....................         endpoint_stat[1].FIFO_status = EMPTY;  
09F6:  CLRF   6A
....................         // usbn_write(RXC1,RX_EN);                 // Enable command receive (EP2)  
....................     } else {  
09F7:  GOTO   1FB
09F8:  BSF    03.5
....................         //  
....................         // TODO: Resend data  
....................         endpoint_stat[1].FIFO_status = EMPTY;  
09F9:  BCF    03.5
09FA:  CLRF   6A
....................         // usbn_write(RXC1,RX_EN);                 // Enable command receive (EP2)  
....................     }  
....................     return;  
.................... }  
....................   
.................... void tx_2(void)  
.................... {  
....................     int8    txstat;  
....................   
....................     txstat = usbn_read(TXS2);       // Get transmitter status  
*
09FC:  MOVLW  32
09FD:  BSF    03.5
09FE:  MOVWF  36
09FF:  BCF    0A.3
0A00:  BCF    03.5
0A01:  CALL   1F0
0A02:  BSF    0A.3
0A03:  MOVF   78,W
0A04:  BSF    03.5
0A05:  MOVWF  2F
....................     usbn_write(TXC2, FLUSH);        // Flush the FIFO  
0A06:  MOVLW  33
0A07:  MOVWF  38
0A08:  MOVLW  08
0A09:  MOVWF  39
0A0A:  BCF    0A.3
0A0B:  BCF    03.5
0A0C:  CALL   225
0A0D:  BSF    0A.3
....................     //  
....................     // If a transmission has completed successfully, update the data and toggle the PID  
....................     //  
....................     if ((txstat & ACK_STAT) && (txstat & TX_DONE)) {  
0A0E:  BSF    03.5
0A0F:  BTFSS  2F.6
0A10:  GOTO   219
0A11:  BTFSS  2F.5
0A12:  GOTO   219
....................         // This is where we know there's been a successful transmission to Host.  
....................         endpoint_stat[2].toggle_bit ^= 0x01;    // Flip the PID bit on EP2  
0A13:  MOVLW  01
0A14:  BCF    03.5
0A15:  XORWF  6B,F
....................         endpoint_stat[2].FIFO_status = EMPTY;  
0A16:  CLRF   6C
....................     } else {  
0A17:  GOTO   21B
0A18:  BSF    03.5
....................         endpoint_stat[2].FIFO_status = EMPTY;  
0A19:  BCF    03.5
0A1A:  CLRF   6C
....................     }  
....................     return;  
.................... }  
....................   
.................... void tx_3(void)  
.................... {  
....................     int8    txstat;  
....................   
....................     txstat = usbn_read(TXS3);       // Get transmitter status  
*
0A1C:  MOVLW  3A
0A1D:  BSF    03.5
0A1E:  MOVWF  36
0A1F:  BCF    0A.3
0A20:  BCF    03.5
0A21:  CALL   1F0
0A22:  BSF    0A.3
0A23:  MOVF   78,W
0A24:  BSF    03.5
0A25:  MOVWF  2F
....................     usbn_write(TXC3, FLUSH);        // Flush the FIFO  
0A26:  MOVLW  3B
0A27:  MOVWF  38
0A28:  MOVLW  08
0A29:  MOVWF  39
0A2A:  BCF    0A.3
0A2B:  BCF    03.5
0A2C:  CALL   225
0A2D:  BSF    0A.3
....................     //  
....................     // If a transmission has completed successfully, update the data and toggle the PID  
....................     //  
....................     if ((txstat & ACK_STAT) && (txstat & TX_DONE)) {  
0A2E:  BSF    03.5
0A2F:  BTFSS  2F.6
0A30:  GOTO   239
0A31:  BTFSS  2F.5
0A32:  GOTO   239
....................         // This is where we know there's been a successful transmission to Host.  
....................         // So we can re-enable RX1 for reception. Allowing new commands and/or data  
....................         // to be received  
....................         endpoint_stat[3].toggle_bit ^= 0x01;    // Flip the PID bit on EP3  
0A33:  MOVLW  01
0A34:  BCF    03.5
0A35:  XORWF  6D,F
....................         endpoint_stat[3].FIFO_status = EMPTY;  
0A36:  CLRF   6E
....................     } else {  
0A37:  GOTO   23B
0A38:  BSF    03.5
....................         endpoint_stat[3].FIFO_status = EMPTY;  
0A39:  BCF    03.5
0A3A:  CLRF   6E
....................     }  
....................     return;  
.................... }  
....................   
.................... void rx_1(void)  
.................... {  
....................     int8    i, len, rxstatus, toggle;  
....................   
....................     rxstatus = usbn_read(RXS1);     // Get the receiver status  
*
08B1:  MOVLW  2E
08B2:  MOVWF  36
08B3:  BCF    0A.3
08B4:  BCF    03.5
08B5:  CALL   1F0
08B6:  BSF    0A.3
08B7:  MOVF   78,W
08B8:  BSF    03.5
08B9:  MOVWF  33
....................   
.................... //    if(rxstatus & SETUP_R) {        // We don't do setup packets on RX1  
.................... //        usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable  
.................... //        return;  
.................... //    }  
....................   
....................     if (rxstatus & RX_ERR) {        // If Error, flush fifo and re-enable, i.e. simply ignore it  
08BA:  BTFSS  33.7
08BB:  GOTO   0CF
....................         usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable  
08BC:  MOVLW  2F
08BD:  MOVWF  38
08BE:  MOVLW  08
08BF:  MOVWF  39
08C0:  BCF    0A.3
08C1:  BCF    03.5
08C2:  CALL   225
08C3:  BSF    0A.3
....................         usbn_write(RXC1, RX_EN);    // Re-Enable receiving  
08C4:  MOVLW  2F
08C5:  BSF    03.5
08C6:  MOVWF  38
08C7:  MOVLW  01
08C8:  MOVWF  39
08C9:  BCF    0A.3
08CA:  BCF    03.5
08CB:  CALL   225
08CC:  BSF    0A.3
....................         return;  
08CD:  GOTO   139
08CE:  BSF    03.5
....................     }  
....................   
....................     len = rxstatus & 0x0F;      // Get data length  
08CF:  MOVF   33,W
08D0:  ANDLW  0F
08D1:  MOVWF  32
....................   
....................     if ((rxstatus & RX_LAST) && (len != 0)) {  
08D2:  BTFSS  33.4
08D3:  GOTO   128
08D4:  MOVF   32,F
08D5:  BTFSC  03.2
08D6:  GOTO   128
....................   
....................   
....................         toggle = endpoint_stat[4].toggle_bit << 5;  
08D7:  BCF    03.5
08D8:  SWAPF  6F,W
08D9:  BSF    03.5
08DA:  MOVWF  34
08DB:  RLF    34,F
08DC:  MOVLW  E0
08DD:  ANDWF  34,F
....................         if ((rxstatus & RX_TOGL) == toggle) {  
08DE:  MOVF   33,W
08DF:  ANDLW  20
08E0:  SUBWF  34,W
08E1:  BTFSS  03.2
08E2:  GOTO   0E8
....................   
....................             endpoint_stat[4].toggle_bit ^= 0x01;  
08E3:  MOVLW  01
08E4:  BCF    03.5
08E5:  XORWF  6F,F
....................         } else {  
08E6:  GOTO   0FA
08E7:  BSF    03.5
....................             usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable  
08E8:  MOVLW  2F
08E9:  MOVWF  38
08EA:  MOVLW  08
08EB:  MOVWF  39
08EC:  BCF    0A.3
08ED:  BCF    03.5
08EE:  CALL   225
08EF:  BSF    0A.3
....................             usbn_write(RXC1, RX_EN);    // Re-Enable receiving  
08F0:  MOVLW  2F
08F1:  BSF    03.5
08F2:  MOVWF  38
08F3:  MOVLW  01
08F4:  MOVWF  39
08F5:  BCF    0A.3
08F6:  BCF    03.5
08F7:  CALL   225
08F8:  BSF    0A.3
....................             return;  
08F9:  GOTO   139
....................         }  
....................         //  
....................         // Read the data out of the FIFO  
....................         //  
....................         for (i=0; i<len; i++)  
08FA:  BSF    03.5
08FB:  CLRF   31
08FC:  MOVF   32,W
08FD:  SUBWF  31,W
08FE:  BTFSC  03.0
08FF:  GOTO   11E
....................         {  
....................             if (len >= 8) {         // Cap at 8 (shovel the rest into the bit bucket)  
0900:  MOVF   32,W
0901:  SUBLW  07
0902:  BTFSC  03.0
0903:  GOTO   10E
....................                 rxstatus = usbn_read(RXD1);  
0904:  MOVLW  2D
0905:  MOVWF  36
0906:  BCF    0A.3
0907:  BCF    03.5
0908:  CALL   1F0
0909:  BSF    0A.3
090A:  MOVF   78,W
090B:  BSF    03.5
090C:  MOVWF  33
....................             } else {                // Stuff the data into the command buffer  
090D:  GOTO   11C
....................                 CommandBuffer[i] = usbn_read(RXD1);  
090E:  MOVLW  40
090F:  ADDWF  31,W
0910:  MOVWF  35
0911:  MOVLW  2D
0912:  MOVWF  36
0913:  BCF    0A.3
0914:  BCF    03.5
0915:  CALL   1F0
0916:  BSF    0A.3
0917:  BSF    03.5
0918:  MOVF   35,W
0919:  MOVWF  04
091A:  MOVF   78,W
091B:  MOVWF  00
....................             }  
....................         }  
091C:  INCF   31,F
091D:  GOTO   0FC
....................   
....................         usbn_write(RXC1,FLUSH);     // Flush  RX1 and disable  
091E:  MOVLW  2F
091F:  MOVWF  38
0920:  MOVLW  08
0921:  MOVWF  39
0922:  BCF    0A.3
0923:  BCF    03.5
0924:  CALL   225
0925:  BSF    0A.3
....................         //  
....................         // NOTE: Reciever will be re-enable after a response is sent  
....................         //  
....................     } else {  
0926:  GOTO   139
0927:  BSF    03.5
....................         //  
....................         // Zero length packet.  
....................         //  
....................         usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable  
0928:  MOVLW  2F
0929:  MOVWF  38
092A:  MOVLW  08
092B:  MOVWF  39
092C:  BCF    0A.3
092D:  BCF    03.5
092E:  CALL   225
092F:  BSF    0A.3
....................         usbn_write(RXC1, RX_EN);    // Re-Enable receiving  
0930:  MOVLW  2F
0931:  BSF    03.5
0932:  MOVWF  38
0933:  MOVLW  01
0934:  MOVWF  39
0935:  BCF    0A.3
0936:  BCF    03.5
0937:  CALL   225
0938:  BSF    0A.3
....................     }  
....................     return;  
.................... }  
....................   
....................   
.................... /*******************************************************************************  
.................... /* usbn_get_version()  
.................... /*  
.................... /* Summary: Stictly for debugging, this function gets the revision number of the  
.................... /*          USBN960x you are connected to.  Good to see if you're connection  
.................... /*          to the USBN960x is good.  
.................... /*  
.................... /********************************************************************************/  
.................... int8 usbn_get_version(void) {  
*
10F5:  CLRF   28
10F6:  BTFSC  0B.7
10F7:  BSF    28.7
10F8:  BCF    0B.7
....................    return(usbn_read(RID));  
10F9:  MOVLW  03
10FA:  BSF    03.5
10FB:  MOVWF  36
10FC:  BCF    0A.4
10FD:  BCF    03.5
10FE:  CALL   1F0
10FF:  BSF    0A.4
1100:  BTFSC  28.7
1101:  BSF    0B.7
1102:  MOVF   78,W
.................... }  
....................   
....................   
.................... /*******************************************************************************  
.................... /* usb_isr()  
.................... /*  
.................... /* Summary: Checks the Main Event interrupt register, and acts upon USB interrupts.  
.................... /*          ALT interrupt happens for the misc interrupts (reset, idle, wakeup, etc.)  
.................... /*          NAK interrupt happens when the USBN device generated a NAK to an IN or OUT/SETUP token  
.................... /*          TX interrupt happens when an IN token has happend (PIC -> HOST)  
.................... /*          RX interrupt happens when an OUT/SETUP token has happened. (HOST -> PIC).  
.................... /*          Majority of USB token handling is done through the RX event.  
.................... /*  
.................... /*          If you choose to use a polling method instead of by interrupt then call  
.................... /*          this function on any free time.  Use great care if you choose to poll:  
.................... /*          some USB requests require a response within a few milli-seconds.  
.................... /*  
.................... /********************************************************************************/  
.................... #int_ext NOCLEAR  
.................... void usb_isr(void)  
.................... {  
....................     int8 usbn_event, i;  
....................   
....................     // Clear the interrupt manually and immediately so another can come in  
....................     bit_clear(*11, 1);      
*
0800:  BCF    0B.1
....................   
....................     //  
....................     // Loop until all ISR events are handled  
....................     //  
....................     do {  
....................         usbn_event = usbn_read(MAEV);  
0801:  MOVLW  06
0802:  BSF    03.5
0803:  MOVWF  36
0804:  BCF    0A.3
0805:  BCF    03.5
0806:  CALL   1F0
0807:  BSF    0A.3
0808:  MOVF   78,W
0809:  BSF    03.5
080A:  MOVWF  28
....................   
....................         if (usbn_event & RX_EV)          // RX_EV - OUT and SETUP tokens (data from HOST)  
....................         {  
080B:  BTFSS  28.6
080C:  GOTO   145
....................             trigger_led_red();  
080D:  BCF    0A.3
080E:  BCF    03.5
080F:  CALL   21D
0810:  BSF    0A.3
....................             handle_rxev();  
....................             continue;  
*
0944:  GOTO   31D
....................         }  
....................   
....................         if (usbn_event & TX_EV) 	    // TX_EV - IN token (DEVICE sending data)  
....................         {  
0945:  BTFSS  28.2
0946:  GOTO   245
....................             trigger_led_red();  
0947:  BCF    0A.3
0948:  BCF    03.5
0949:  CALL   21D
094A:  BSF    0A.3
....................             handle_txev();  
....................             continue;  
*
0A44:  GOTO   31D
....................         }  
....................   
....................         if (usbn_event & ALT)           // ALT - Resets, Idles, Suspends, etc.  
....................         {  
0A45:  BTFSS  28.1
0A46:  GOTO   2F0
....................             led_on_green();  
0A47:  BCF    0A.3
0A48:  BCF    03.5
0A49:  CALL   6D0
0A4A:  BSF    0A.3
.................... 			handle_alt();  
....................             continue;  
*
0AEE:  BSF    03.5
0AEF:  GOTO   31D
....................         }  
....................   
.................... 		if (usbn_event & NAK)           // NAK - PC tried to send us data, but 960x nak'd it  
.................... 		{  
0AF0:  BTFSS  28.4
0AF1:  GOTO   317
....................             // NAK on EP0  
.................... 			if (usbn_read(NAKEV) & 0x10)  
.................... 			{  
0AF2:  MOVLW  0E
0AF3:  MOVWF  36
0AF4:  BCF    0A.3
0AF5:  BCF    03.5
0AF6:  CALL   1F0
0AF7:  BSF    0A.3
0AF8:  BTFSS  78.4
0AF9:  GOTO   311
....................                 //  
....................                 // IF we're in the middle of a multipacket transfer, then the  
....................                 // host has NAL'd us and wants us to stop transmitting.  
....................                 //  
....................                if ( XferEP0.nXferType != NO_XFER) {  
0AFA:  MOVF   63,F
0AFB:  BTFSC  03.2
0AFC:  GOTO   310
....................                     // clear any output transmission  
....................                     XferEP0.nXferType = NO_XFER;  
0AFD:  CLRF   63
....................                     // Flush xmitter, disable transmitting, enable reception  
....................                     usbn_write(TXC0, FLUSH);  
0AFE:  MOVLW  23
0AFF:  BSF    03.5
0B00:  MOVWF  38
0B01:  MOVLW  08
0B02:  MOVWF  39
0B03:  BCF    0A.3
0B04:  BCF    03.5
0B05:  CALL   225
0B06:  BSF    0A.3
....................                     usbn_write(RXC0, RX_EN);  
0B07:  MOVLW  27
0B08:  BSF    03.5
0B09:  MOVWF  38
0B0A:  MOVLW  01
0B0B:  MOVWF  39
0B0C:  BCF    0A.3
0B0D:  BCF    03.5
0B0E:  CALL   225
0B0F:  BSF    0A.3
....................                 }  
.................... 			} else {  
0B10:  GOTO   315
....................               i = 9;  
0B11:  MOVLW  09
0B12:  BSF    03.5
0B13:  MOVWF  29
0B14:  BCF    03.5
....................            }  
....................             continue;  
0B15:  BSF    03.5
0B16:  GOTO   31D
.................... 		}  
....................         //  
....................         // TODO: This events should not  happen  
....................         //  
....................         if (usbn_event & WARN)          // WARN - FIFO warn event (FWEV)  
....................             handle_warn();  
0B17:  BTFSS  28.0
0B18:  GOTO   319
....................   
....................         if (usbn_event & FRAME)         // FRAME - frame counter updated  
....................             handle_frame();  
0B19:  BTFSS  28.3
0B1A:  GOTO   31B
....................   
....................         if (usbn_event & ULD)           // ULD - Unlock/Lock deteced  
....................             handle_uld();  
0B1B:  BTFSS  28.5
0B1C:  GOTO   31D
....................   
....................     } while (usbn_event);  
....................       
....................     return;  
0B1D:  MOVF   28,F
0B1E:  BTFSC  03.2
0B1F:  GOTO   322
0B20:  BCF    03.5
0B21:  GOTO   001
.................... }  
....................   
.................... /*******************************************************************************  
.................... /* handle_alt()  
.................... /*  
.................... /* Summary:  This interrupt happens when an RESET, SUSPEND or RESUME event has happened.  
.................... /*            RESET - USBN device is reset, USB token handling code is put into initial state  
.................... /*            SUSPEND - Resume interrupt is enabled, USBN device put into suspended mode  
.................... /*            RESUME - Suspend interrupt is enabled, USBN device put into operational state, EP0 reception enabled  
.................... /*  
.................... /********************************************************************************/  
0B22:  BCF    0A.3
0B23:  BCF    0A.4
0B24:  BCF    03.5
0B25:  GOTO   027
.................... void handle_alt(void) {  
....................     int8 alt_event, i;  
....................   
....................     alt_event = usbn_read(ALTEV);  
*
0A4B:  MOVLW  08
0A4C:  BSF    03.5
0A4D:  MOVWF  36
0A4E:  BCF    0A.3
0A4F:  BCF    03.5
0A50:  CALL   1F0
0A51:  BSF    0A.3
0A52:  MOVF   78,W
0A53:  BSF    03.5
0A54:  MOVWF  2A
....................     alt_event &= alt_mask;  
0A55:  MOVF   71,W
0A56:  ANDWF  2A,F
....................   
....................     //  
....................     // Loop through and handle all events one at a time  
....................     //  
....................     if (alt_event & ALT_RESET)                  // RESET  
....................     {  
0A57:  BTFSS  2A.6
0A58:  GOTO   2B4
....................         usbn_write(EPC0, usbn_read(EPC0) & ~STALL);     // CLEAR_STALL_EP0  
0A59:  MOVLW  20
0A5A:  MOVWF  36
0A5B:  BCF    0A.3
0A5C:  BCF    03.5
0A5D:  CALL   1F0
0A5E:  BSF    0A.3
0A5F:  MOVF   78,W
0A60:  ANDLW  7F
0A61:  BSF    03.5
0A62:  MOVWF  2D
0A63:  MOVLW  20
0A64:  MOVWF  38
0A65:  MOVF   2D,W
0A66:  MOVWF  39
0A67:  BCF    0A.3
0A68:  BCF    03.5
0A69:  CALL   225
0A6A:  BSF    0A.3
....................         usbn_write(NFSR, RST_ST);                       // Enter RESET state  
0A6B:  MOVLW  05
0A6C:  BSF    03.5
0A6D:  MOVWF  38
0A6E:  CLRF   39
0A6F:  BCF    0A.3
0A70:  BCF    03.5
0A71:  CALL   225
0A72:  BSF    0A.3
....................         delay_ms(1);                                    // Must stay in RESET for at least 100 us)  
0A73:  MOVLW  01
0A74:  BSF    03.5
0A75:  MOVWF  2C
0A76:  BCF    0A.3
0A77:  BCF    03.5
0A78:  CALL   6D3
0A79:  BSF    0A.3
....................         usbn_write(FAR, AD_EN+0);                       // set default address 0x00  
0A7A:  MOVLW  04
0A7B:  BSF    03.5
0A7C:  MOVWF  38
0A7D:  MOVLW  80
0A7E:  MOVWF  39
0A7F:  BCF    0A.3
0A80:  BCF    03.5
0A81:  CALL   225
0A82:  BSF    0A.3
....................         usbn_write(EPC0, 0x00);                         // enable EP0 only  
0A83:  MOVLW  20
0A84:  BSF    03.5
0A85:  MOVWF  38
0A86:  CLRF   39
0A87:  BCF    0A.3
0A88:  BCF    03.5
0A89:  CALL   225
0A8A:  BSF    0A.3
....................   
.................... 	    reset_usb();  
0A8B:  BCF    0A.3
0A8C:  CALL   705
0A8D:  BSF    0A.3
.................... 	    // TODO: Set device state  
....................         // usb_device_reset();  
....................   
....................         XferEP0.nXferType = NO_XFER;  
0A8E:  CLRF   63
....................   
.................... 	    usbn_write(NFSR, OPR_ST);                       // Enter OPERATIONAL state  
0A8F:  MOVLW  05
0A90:  BSF    03.5
0A91:  MOVWF  38
0A92:  MOVLW  02
0A93:  MOVWF  39
0A94:  BCF    0A.3
0A95:  BCF    03.5
0A96:  CALL   225
0A97:  BSF    0A.3
....................   
....................         usbn_write(FAR, AD_EN+0);                       // set default address 0x00  
0A98:  MOVLW  04
0A99:  BSF    03.5
0A9A:  MOVWF  38
0A9B:  MOVLW  80
0A9C:  MOVWF  39
0A9D:  BCF    0A.3
0A9E:  BCF    03.5
0A9F:  CALL   225
0AA0:  BSF    0A.3
....................         usbn_write(EPC0, 0x00);                         // default address  
0AA1:  MOVLW  20
0AA2:  BSF    03.5
0AA3:  MOVWF  38
0AA4:  CLRF   39
0AA5:  BCF    0A.3
0AA6:  BCF    03.5
0AA7:  CALL   225
0AA8:  BSF    0A.3
....................         usbn_write(RXC0, RX_EN);                        // enable reception  
0AA9:  MOVLW  27
0AAA:  BSF    03.5
0AAB:  MOVWF  38
0AAC:  MOVLW  01
0AAD:  MOVWF  39
0AAE:  BCF    0A.3
0AAF:  BCF    03.5
0AB0:  CALL   225
0AB1:  BSF    0A.3
....................   
....................     } else if (alt_event & ALT_SD3) {  
0AB2:  GOTO   2EE
0AB3:  BSF    03.5
0AB4:  BTFSS  2A.4
0AB5:  GOTO   2CB
....................         //  
....................         // Enable the RESUME interrupt  
....................         alt_mask = ALT_RESET | ALT_RESUME;  
0AB6:  MOVLW  C0
0AB7:  MOVWF  71
....................         usbn_write(ALTMSK, alt_mask);  
0AB8:  MOVLW  09
0AB9:  MOVWF  38
0ABA:  MOVF   71,W
0ABB:  MOVWF  39
0ABC:  BCF    0A.3
0ABD:  BCF    03.5
0ABE:  CALL   225
0ABF:  BSF    0A.3
....................         //  
....................         // Enter SUSPENDED state  
.................... 		usbn_write(NFSR, SUS_ST);  
0AC0:  MOVLW  05
0AC1:  BSF    03.5
0AC2:  MOVWF  38
0AC3:  MOVLW  03
0AC4:  MOVWF  39
0AC5:  BCF    0A.3
0AC6:  BCF    03.5
0AC7:  CALL   225
0AC8:  BSF    0A.3
....................   
....................     } else if (alt_event & ALT_RESUME) {  
0AC9:  GOTO   2EE
0ACA:  BSF    03.5
0ACB:  BTFSS  2A.7
0ACC:  GOTO   2EB
....................         //  
....................         // Disable the RESUME interrupt  
....................         alt_mask = ALT_SD3 | ALT_RESET;  
0ACD:  MOVLW  50
0ACE:  MOVWF  71
....................         usbn_write(ALTMSK, alt_mask);  
0ACF:  MOVLW  09
0AD0:  MOVWF  38
0AD1:  MOVF   71,W
0AD2:  MOVWF  39
0AD3:  BCF    0A.3
0AD4:  BCF    03.5
0AD5:  CALL   225
0AD6:  BSF    0A.3
....................         //  
....................         // Enter operation state  
....................         usbn_write(NFSR, OPR_ST);  
0AD7:  MOVLW  05
0AD8:  BSF    03.5
0AD9:  MOVWF  38
0ADA:  MOVLW  02
0ADB:  MOVWF  39
0ADC:  BCF    0A.3
0ADD:  BCF    03.5
0ADE:  CALL   225
0ADF:  BSF    0A.3
....................         //  
....................         // Enable receiving  
....................         usbn_write(RXC0, RX_EN);  
0AE0:  MOVLW  27
0AE1:  BSF    03.5
0AE2:  MOVWF  38
0AE3:  MOVLW  01
0AE4:  MOVWF  39
0AE5:  BCF    0A.3
0AE6:  BCF    03.5
0AE7:  CALL   225
0AE8:  BSF    0A.3
....................     } else {  
0AE9:  GOTO   2EE
0AEA:  BSF    03.5
....................         //  
....................         // Spurious ALT event  
....................         //  
....................         i = 99;  
0AEB:  MOVLW  63
0AEC:  MOVWF  2B
0AED:  BCF    03.5
....................     }  
....................     return;  
.................... }  
....................   
.................... /*******************************************************************************  
.................... /* handle_txev()  
.................... /*  
.................... /* The TX interrupt happens whenever an IN token has been processed.  (PIC -> HOST).  
.................... /*  
.................... /********************************************************************************/  
.................... void handle_txev(void) {  
....................     int8 status, txs;  
....................     int8 tx_event, i;  
.................... 	int8 event_mask = 1;  
*
094B:  MOVLW  01
094C:  BSF    03.5
094D:  MOVWF  2E
....................   
....................     tx_event = usbn_read(TXEV);  
094E:  MOVLW  0A
094F:  MOVWF  36
0950:  BCF    0A.3
0951:  BCF    03.5
0952:  CALL   1F0
0953:  BSF    0A.3
0954:  MOVF   78,W
0955:  BSF    03.5
0956:  MOVWF  2C
....................   
....................     //  
....................     // Loop through and handle all events one at a time  
....................     //  
....................     while(tx_event)  
....................     {  
0957:  MOVF   2C,F
0958:  BTFSC  03.2
0959:  GOTO   244
....................         switch(tx_event & event_mask)  
....................         {  
095A:  MOVF   2C,W
095B:  ANDWF  2E,W
095C:  MOVWF  77
095D:  MOVLW  01
095E:  SUBWF  77,W
095F:  BCF    03.5
0960:  BTFSC  03.2
0961:  GOTO   17F
0962:  MOVLW  02
0963:  SUBWF  77,W
0964:  BTFSC  03.2
0965:  GOTO   1DC
0966:  MOVLW  04
0967:  SUBWF  77,W
0968:  BTFSC  03.2
0969:  GOTO   1FC
096A:  MOVLW  08
096B:  SUBWF  77,W
096C:  BTFSC  03.2
096D:  GOTO   21C
096E:  MOVLW  10
096F:  SUBWF  77,W
0970:  BTFSC  03.2
0971:  GOTO   23C
0972:  MOVLW  20
0973:  SUBWF  77,W
0974:  BTFSC  03.2
0975:  GOTO   23C
0976:  MOVLW  40
0977:  SUBWF  77,W
0978:  BTFSC  03.2
0979:  GOTO   23C
097A:  MOVLW  80
097B:  SUBWF  77,W
097C:  BTFSC  03.2
097D:  GOTO   23C
097E:  GOTO   23C
....................             case TX_FIFO0:              // EP0  
....................   
....................                 txs=usbn_read(TXS0);    // Read TX status for EP0  
097F:  MOVLW  22
0980:  BSF    03.5
0981:  MOVWF  36
0982:  BCF    0A.3
0983:  BCF    03.5
0984:  CALL   1F0
0985:  BSF    0A.3
0986:  MOVF   78,W
0987:  BSF    03.5
0988:  MOVWF  2B
....................   
....................                 if (txs & TX_DONE)  
....................                 {  
0989:  BTFSS  2B.5
098A:  GOTO   1D8
....................                     // FLUSH - disable TX  
....................                     usbn_write(TXC0, FLUSH);  
098B:  MOVLW  23
098C:  MOVWF  38
098D:  MOVLW  08
098E:  MOVWF  39
098F:  BCF    0A.3
0990:  BCF    03.5
0991:  CALL   225
0992:  BSF    0A.3
....................   
....................                     if (txs & ACK_STAT)     // ACK status  
....................                     {  
0993:  BSF    03.5
0994:  BTFSS  2B.6
0995:  GOTO   1CB
....................                         //  
....................                         if (XferEP0.nXferType != NO_XFER) {    // if we are processing a report then send the next part  
0996:  BCF    03.5
0997:  MOVF   63,F
0998:  BTFSC  03.2
0999:  GOTO   1B3
....................                             // Continue transmitting descriptor  
....................     	                    XmitOnUSB0();  
099A:  BCF    0A.3
099B:  CALL   24B
099C:  BSF    0A.3
....................                             i = endpoint_stat[0].toggle_bit << 2;  
099D:  RLF    67,W
099E:  BSF    03.5
099F:  MOVWF  2D
09A0:  RLF    2D,F
09A1:  MOVLW  FC
09A2:  ANDWF  2D,F
....................                             endpoint_stat[0].toggle_bit ^= 0x01;  
09A3:  MOVLW  01
09A4:  BCF    03.5
09A5:  XORWF  67,F
....................                             usbn_write(TXC0, TX_EN | i);   // enable the TX (DATA1) and toggle PID  
09A6:  BSF    03.5
09A7:  MOVF   2D,W
09A8:  IORLW  01
09A9:  MOVWF  2F
09AA:  MOVLW  23
09AB:  MOVWF  38
09AC:  MOVF   2F,W
09AD:  MOVWF  39
09AE:  BCF    0A.3
09AF:  BCF    03.5
09B0:  CALL   225
09B1:  BSF    0A.3
....................   
....................                         } else {  
09B2:  GOTO   1C9
....................   
....................                             if (setaddress) {  
09B3:  MOVF   72,F
09B4:  BTFSC  03.2
09B5:  GOTO   1C0
....................                                 usbn_write(FAR, setaddress);  
09B6:  MOVLW  04
09B7:  BSF    03.5
09B8:  MOVWF  38
09B9:  MOVF   72,W
09BA:  MOVWF  39
09BB:  BCF    0A.3
09BC:  BCF    03.5
09BD:  CALL   225
09BE:  BSF    0A.3
....................                                 setaddress = 0;  
09BF:  CLRF   72
....................                             }  
....................   
....................                             usbn_write(RXC0, RX_EN);  // enable reception  
09C0:  MOVLW  27
09C1:  BSF    03.5
09C2:  MOVWF  38
09C3:  MOVLW  01
09C4:  MOVWF  39
09C5:  BCF    0A.3
09C6:  BCF    03.5
09C7:  CALL   225
09C8:  BSF    0A.3
....................                         }  
....................                     } else {  
09C9:  GOTO   1D6
09CA:  BSF    03.5
....................   
....................                         XferEP0.nXferType = NO_XFER;  
09CB:  BCF    03.5
09CC:  CLRF   63
.................... 	    				/*-------------------  
.................... 		    			* there is no ACK  
.................... 			    		* Re-enable receiving  
.................... 				    	*--------------------*/  
....................                         usbn_write(RXC0, RX_EN);  
09CD:  MOVLW  27
09CE:  BSF    03.5
09CF:  MOVWF  38
09D0:  MOVLW  01
09D1:  MOVWF  39
09D2:  BCF    0A.3
09D3:  BCF    03.5
09D4:  CALL   225
09D5:  BSF    0A.3
....................                     }  
....................                 } else {  
09D6:  GOTO   1DB
09D7:  BSF    03.5
....................                     i =9;  
09D8:  MOVLW  09
09D9:  MOVWF  2D
09DA:  BCF    03.5
....................                 }  
....................                 break;  
09DB:  GOTO   23D
....................   
....................             case TX_FIFO1:              // TX event - FIFO1  
....................                 tx_1();  
....................                 break;  
*
09FB:  GOTO   23D
....................             case TX_FIFO2:              // TX event - FIFO2  
....................                 tx_2();  
....................                 break;  
*
0A1B:  GOTO   23D
....................             case TX_FIFO3:              // TX event - FIFO3  
....................                 tx_3();  
....................                 break;  
*
0A3B:  GOTO   23D
....................             case TX_UDRN0:  
....................             case TX_UDRN1:  
....................             case TX_UDRN2:  
....................             case TX_UDRN3:  
....................             default:  
....................   
.................... #if 0  
....................                 txs=usbn_read(TXS1);  
....................                 if (txs & ACK_STAT)     // ACK status  
....................                 {  
....................                     // Done transmitting data  
....................                 } else {  
....................                     // Retransmit data  
....................                 }  
.................... #endif  
....................                 break;  
0A3C:  GOTO   23D
....................   
.................... 		}  
....................         tx_event &= ~event_mask;  
0A3D:  BSF    03.5
0A3E:  MOVF   2E,W
0A3F:  XORLW  FF
0A40:  ANDWF  2C,F
....................         event_mask = event_mask << 1;  
0A41:  BCF    03.0
0A42:  RLF    2E,F
....................     }  
0A43:  GOTO   157
....................     return;  
.................... }  
....................   
.................... /*******************************************************************************  
.................... /* handle_rxev()  
.................... /*  
.................... /* Summary: Handles the RX interrupt.  This happens when an OUT/SETUP token has happened (HOST -> PIC)  
.................... /*          and there is data in the RX buffers.  
.................... /*  
.................... /*          If there is data in the EP0 buffer and it is a SETUP token, it is processed by the  
.................... /*          SETUP token handler.  The SETUP token handler is the bulk of this code.  
.................... /*  
.................... /********************************************************************************/  
.................... void handle_rxev(void) {  
....................     int8    rxstatus, len, i;  
....................     int8    temp;  
....................     int8    rx_event, rx_event2;  
....................     int8    event_mask = 1;  
*
0811:  MOVLW  01
0812:  BSF    03.5
0813:  MOVWF  30
....................   
....................     //  
....................     // Get the RX event status  
....................     //  
....................   
....................     rx_event = usbn_read(RXEV);  
0814:  MOVLW  0C
0815:  MOVWF  36
0816:  BCF    0A.3
0817:  BCF    03.5
0818:  CALL   1F0
0819:  BSF    0A.3
081A:  MOVF   78,W
081B:  BSF    03.5
081C:  MOVWF  2E
....................     rx_event2= rx_event;  
081D:  MOVWF  2F
....................   
....................     while(rx_event)  
....................     {  
081E:  MOVF   2E,F
081F:  BTFSC  03.2
0820:  GOTO   144
....................         switch(rx_event & event_mask)  
....................         {  
0821:  MOVF   2E,W
0822:  ANDWF  30,W
0823:  MOVWF  77
0824:  MOVLW  01
0825:  SUBWF  77,W
0826:  BCF    03.5
0827:  BTFSC  03.2
0828:  GOTO   042
0829:  MOVLW  02
082A:  SUBWF  77,W
082B:  BTFSC  03.2
082C:  GOTO   0AE
082D:  MOVLW  04
082E:  SUBWF  77,W
082F:  BTFSC  03.2
0830:  GOTO   13B
0831:  MOVLW  08
0832:  SUBWF  77,W
0833:  BTFSC  03.2
0834:  GOTO   13B
0835:  MOVLW  10
0836:  SUBWF  77,W
0837:  BTFSC  03.2
0838:  GOTO   13B
0839:  MOVLW  20
083A:  SUBWF  77,W
083B:  BTFSC  03.2
083C:  GOTO   13B
083D:  MOVLW  40
083E:  SUBWF  77,W
083F:  BTFSC  03.2
0840:  GOTO   13B
0841:  GOTO   13B
....................             case RX_FIFO0:              // RX0, EP0 - Main control and Setup endpoint  
....................                 memset(ep0_rx_buffer, 0, USB_MAX_EP0_PACKET_LENGTH);  
0842:  MOVLW  08
0843:  MOVWF  78
0844:  MOVLW  53
0845:  MOVWF  04
0846:  CLRF   00
0847:  INCF   04,F
0848:  DECFSZ 78,F
0849:  GOTO   046
....................                 rxstatus = usbn_read(RXS0);     // Get Receiver 0 status  
084A:  MOVLW  26
084B:  BSF    03.5
084C:  MOVWF  36
084D:  BCF    0A.3
084E:  BCF    03.5
084F:  CALL   1F0
0850:  BSF    0A.3
0851:  MOVF   78,W
0852:  BSF    03.5
0853:  MOVWF  2A
....................                 len = rxstatus & 0x0F;          // Get the length  
0854:  ANDLW  0F
0855:  MOVWF  2B
....................   
.................... 			    if (rxstatus & SETUP_R)         // SETUP packet  
.................... 			    {  
0856:  BTFSS  2A.6
0857:  GOTO   095
....................   
....................                     //  
....................                     // Ignore zero length packets  
....................                     if ((rxstatus & RX_LAST) && (len == 0)) {  
0858:  BTFSS  2A.4
0859:  GOTO   060
085A:  MOVF   2B,F
085B:  BTFSS  03.2
085C:  GOTO   060
....................                         i = 1;  
085D:  MOVLW  01
085E:  MOVWF  2C
....................                         break;  
085F:  GOTO   13E
....................                     }  
....................   
.................... //                    usbn_write(EPC0, usbn_read(EPC0) & ~STALL); // clear STALL  
....................                     endpoint_stat[0].toggle_bit = 0x01;         // Initial TOGGLE status  
0860:  MOVLW  01
0861:  BCF    03.5
0862:  MOVWF  67
....................   
....................                     //  
....................                     // Establish maximum length  
....................                     if (len > USB_MAX_EP0_PACKET_LENGTH)  
....................                         len = USB_MAX_EP0_PACKET_LENGTH;  
0863:  BSF    03.5
0864:  MOVF   2B,W
0865:  SUBLW  08
0866:  BTFSC  03.0
0867:  GOTO   06A
0868:  MOVLW  08
0869:  MOVWF  2B
....................                     // Read EP0 FIFO data  
....................                     for (i=0; i<len; i++)  
086A:  CLRF   2C
086B:  MOVF   2B,W
086C:  SUBWF  2C,W
086D:  BTFSC  03.0
086E:  GOTO   07F
....................                     {  
....................                         ep0_rx_buffer[i] = usbn_read(RXD0);  
086F:  MOVLW  53
0870:  ADDWF  2C,W
0871:  MOVWF  31
0872:  MOVLW  25
0873:  MOVWF  36
0874:  BCF    0A.3
0875:  BCF    03.5
0876:  CALL   1F0
0877:  BSF    0A.3
0878:  BSF    03.5
0879:  MOVF   31,W
087A:  MOVWF  04
087B:  MOVF   78,W
087C:  MOVWF  00
....................                     }  
087D:  INCF   2C,F
087E:  GOTO   06B
....................   
....................                     usbn_write(TXC0, FLUSH);    // Flush TX and RX fifo's  
087F:  MOVLW  23
0880:  MOVWF  38
0881:  MOVLW  08
0882:  MOVWF  39
0883:  BCF    0A.3
0884:  BCF    03.5
0885:  CALL   225
0886:  BSF    0A.3
....................                     usbn_write(RXC0, FLUSH);  
0887:  MOVLW  27
0888:  BSF    03.5
0889:  MOVWF  38
088A:  MOVLW  08
088B:  MOVWF  39
088C:  BCF    0A.3
088D:  BCF    03.5
088E:  CALL   225
088F:  BSF    0A.3
....................                     handle_setup();             // Process setup packet  
0890:  BCF    0A.3
0891:  GOTO   384
0892:  BSF    0A.3
....................                 } else {  
0893:  GOTO   0AC
0894:  BSF    03.5
....................                     //  
....................                     // OUT packet of Status stage in control read/write sequence  
....................                     // This signals the normal completion of a CONTROL IN  
....................                     // such as Descriptor data sent to host.  
....................                     //  
....................                     if (XferEP0.nXferType != NO_XFER) {  
0895:  BCF    03.5
0896:  MOVF   63,F
0897:  BTFSC  03.2
0898:  GOTO   0A3
....................                         XferEP0.nXferType = NO_XFER;  
0899:  CLRF   63
....................                         usbn_write(TXC0, FLUSH);    // Flush TX and RX fifo's  
089A:  MOVLW  23
089B:  BSF    03.5
089C:  MOVWF  38
089D:  MOVLW  08
089E:  MOVWF  39
089F:  BCF    0A.3
08A0:  BCF    03.5
08A1:  CALL   225
08A2:  BSF    0A.3
....................                     }  
....................                     usbn_write(RXC0, RX_EN);        // Enable receiving on EP0  
08A3:  MOVLW  27
08A4:  BSF    03.5
08A5:  MOVWF  38
08A6:  MOVLW  01
08A7:  MOVWF  39
08A8:  BCF    0A.3
08A9:  BCF    03.5
08AA:  CALL   225
08AB:  BSF    0A.3
....................                 }  
....................                 break;  
08AC:  BSF    03.5
08AD:  GOTO   13E
....................   
....................             case RX_FIFO1:  
....................                 i = 8;  
08AE:  MOVLW  08
08AF:  BSF    03.5
08B0:  MOVWF  2C
....................                 rx_1();  
....................                 break;  
*
0939:  BSF    03.5
093A:  GOTO   13E
....................   
....................             case RX_FIFO2:  
....................             case RX_FIFO3:  
....................             case RX_OVRN0:  
....................             case RX_OVRN1:  
....................             case RX_OVRN2:  
....................             default:  
....................               i = 9;  
093B:  MOVLW  09
093C:  BSF    03.5
093D:  MOVWF  2C
....................                 break;  
....................         }  
....................         rx_event &= ~event_mask;  
093E:  MOVF   30,W
093F:  XORLW  FF
0940:  ANDWF  2E,F
....................         event_mask = event_mask << 1;  
0941:  BCF    03.0
0942:  RLF    30,F
....................     }  
0943:  GOTO   01E
....................   
....................     return;  
.................... }  
....................   
....................   
....................   
.................... /*******************************************************************************  
.................... /* handle_warn()  
.................... /*  
.................... /* Summary: The WARN event happens when a USBN buffer reaches a desired state.  
.................... /*          This requires the user to setup the WARN setting for each buffer.  
.................... /*  
.................... /********************************************************************************/  
.................... void handle_warn(void) {  
....................    int8 status;  
....................   
....................    // TODO: add code to handle when FIFOs get near full / empty  
....................   
.................... }  
....................   
.................... /*******************************************************************************  
.................... /* handle_frame()  
.................... /*  
.................... /* Summary: Handles a FRAME event interrupt.  
.................... /*          Only relevant to users using isochronous.  
.................... /*  
.................... /********************************************************************************/  
.................... void handle_frame(void) {  
....................   
....................    // TODO: add code if needed  
.................... }  
....................   
.................... /*******************************************************************************  
.................... /* handle_uld()  
.................... /*  
.................... /* Summary:  Handles ULD interrupt.  
.................... /*  
.................... /********************************************************************************/  
.................... void handle_uld(void) {  
....................   
....................    // TODO: add code if needed  
.................... }  
....................   
....................   
.................... /////////////////////////////////////////////////////////////////////////////////////////  
.................... // usbn_write(address, data)  
.................... //  
.................... // Input: address - address of USBN960x register to write to  
.................... //        data - data to write to USBN960x  
.................... //  
.................... // Summary: Writes a byte of memory to specified address on USBN960x  
.................... //  
.................... void usbn_write(int8 address, int8 data) {  
....................   
.................... //    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_16);  
....................    if (SpiMode != SPI_USB)  
....................        setup_spi_mode(SPI_USB);  
*
0225:  DECFSZ 32,W
0226:  GOTO   228
0227:  GOTO   22D
0228:  MOVLW  01
0229:  BSF    03.5
022A:  MOVWF  3A
022B:  BCF    03.5
022C:  CALL   1D2
....................   
....................     output_low(USB_CS);     // Select the USBN9603  
022D:  BCF    05.2
....................     address &= 0x3F;        // Mask off bits 7 and 6  
022E:  MOVLW  3F
022F:  BSF    03.5
0230:  ANDWF  38,F
....................     address |= 0x80;        // WRITE CMD 10xxxxxxb  
0231:  BSF    38.7
....................     spi_write(address);  
0232:  BCF    03.5
0233:  MOVF   13,W
0234:  BSF    03.5
0235:  MOVF   38,W
0236:  BCF    03.5
0237:  MOVWF  13
0238:  BSF    03.5
0239:  BTFSC  14.0
023A:  GOTO   23D
023B:  BCF    03.5
023C:  GOTO   238
....................     spi_write(data);  
023D:  BCF    03.5
023E:  MOVF   13,W
023F:  BSF    03.5
0240:  MOVF   39,W
0241:  BCF    03.5
0242:  MOVWF  13
0243:  BSF    03.5
0244:  BTFSC  14.0
0245:  GOTO   248
0246:  BCF    03.5
0247:  GOTO   243
....................     output_high(USB_CS);    // De-Select the USBN9603  
0248:  BCF    03.5
0249:  BSF    05.2
.................... }  
024A:  RETLW  00
....................   
.................... ////////////////////////////////////////////////////////////////////////////////////////  
.................... // usbn_read(address)  
.................... //  
.................... // Input:   address - address of USBN960x register to read  
.................... // Output:  data (byte) in specified address.  
.................... //  
.................... // Summary: Reads a byte of memory from specified address on USBN960x  
.................... //  
.................... int8 usbn_read(int8 address) {  
....................    int8 data;  
....................   
.................... //    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_16);  
....................    if (SpiMode != SPI_USB)  
....................        setup_spi_mode(SPI_USB);  
*
01F0:  DECFSZ 32,W
01F1:  GOTO   1F3
01F2:  GOTO   1F8
01F3:  MOVLW  01
01F4:  BSF    03.5
01F5:  MOVWF  3A
01F6:  BCF    03.5
01F7:  CALL   1D2
....................   
....................     output_low(USB_CS);     // Select the USBN9603  
01F8:  BCF    05.2
....................   
....................     address &= 0x3F;        // Mask off bits 7 and 6  
01F9:  MOVLW  3F
01FA:  BSF    03.5
01FB:  ANDWF  36,F
....................                             // READ CMD 00xxxxxxb  
....................     spi_write(address);  
01FC:  BCF    03.5
01FD:  MOVF   13,W
01FE:  BSF    03.5
01FF:  MOVF   36,W
0200:  BCF    03.5
0201:  MOVWF  13
0202:  BSF    03.5
0203:  BTFSC  14.0
0204:  GOTO   207
0205:  BCF    03.5
0206:  GOTO   202
....................     data = spi_read(0);  
0207:  BCF    03.5
0208:  MOVF   13,W
0209:  CLRF   13
020A:  BSF    03.5
020B:  BTFSC  14.0
020C:  GOTO   20F
020D:  BCF    03.5
020E:  GOTO   20A
020F:  BCF    03.5
0210:  MOVF   13,W
0211:  BSF    03.5
0212:  MOVWF  37
....................     output_high(USB_CS);    // De-Select the USBN9603  
0213:  BCF    03.5
0214:  BSF    05.2
....................     return(data);  
0215:  BSF    03.5
0216:  MOVF   37,W
0217:  MOVWF  78
.................... }  
0218:  BCF    03.5
0219:  RETLW  00
....................   
....................  
....................   
.................... //-----------------------------------------------------------------------------  
.................... // 25C040 read EEPROM  
.................... //  
.................... #separate  
.................... int8 read_eeprom(int8 address)  
.................... {  
....................     int8    data;  
....................   
....................     // Check and set SPI mode  
....................     if (SpiMode != SPI_EEPROM)  
....................         setup_spi_mode(SPI_EEPROM);  
*
078E:  MOVF   32,W
078F:  SUBLW  02
0790:  BTFSC  03.2
0791:  GOTO   79D
0792:  CLRF   28
0793:  BTFSC  0B.7
0794:  BSF    28.7
0795:  BCF    0B.7
0796:  MOVLW  02
0797:  BSF    03.5
0798:  MOVWF  3A
0799:  BCF    03.5
079A:  CALL   1D2
079B:  BTFSC  28.7
079C:  BSF    0B.7
....................   
....................     output_low(EEPROM_CS);  // Select the EEPROM  
079D:  BCF    05.1
....................     spi_write(0x03);        // READ command byte, A8=0  
079E:  MOVF   13,W
079F:  MOVLW  03
07A0:  MOVWF  13
07A1:  BSF    03.5
07A2:  BTFSC  14.0
07A3:  GOTO   7A6
07A4:  BCF    03.5
07A5:  GOTO   7A1
....................     spi_write(address);     // ADDRESS byte  
07A6:  BCF    03.5
07A7:  MOVF   13,W
07A8:  BSF    03.5
07A9:  MOVF   25,W
07AA:  BCF    03.5
07AB:  MOVWF  13
07AC:  BSF    03.5
07AD:  BTFSC  14.0
07AE:  GOTO   7B1
07AF:  BCF    03.5
07B0:  GOTO   7AC
....................     data = spi_read(0);     // read DATA byte  
07B1:  BCF    03.5
07B2:  MOVF   13,W
07B3:  CLRF   13
07B4:  BSF    03.5
07B5:  BTFSC  14.0
07B6:  GOTO   7B9
07B7:  BCF    03.5
07B8:  GOTO   7B4
07B9:  BCF    03.5
07BA:  MOVF   13,W
07BB:  BSF    03.5
07BC:  MOVWF  26
....................     output_high(EEPROM_CS); // De-select the EEPROM  
07BD:  BCF    03.5
07BE:  BSF    05.1
....................     return (data);  
07BF:  BSF    03.5
07C0:  MOVF   26,W
07C1:  MOVWF  78
.................... }  
07C2:  BCF    03.5
07C3:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // 25C040 write EEPROM  
.................... //  
.................... #separate  
.................... write_eeprom(int8 address, int8 data)  
.................... {  
....................     int8 i;  
....................   
....................     // Check and set SPI mode  
....................     if (SpiMode != SPI_EEPROM)  
....................         setup_spi_mode(SPI_EEPROM);  
*
0B26:  MOVF   32,W
0B27:  SUBLW  02
0B28:  BTFSC  03.2
0B29:  GOTO   337
0B2A:  CLRF   28
0B2B:  BTFSC  0B.7
0B2C:  BSF    28.7
0B2D:  BCF    0B.7
0B2E:  MOVLW  02
0B2F:  BSF    03.5
0B30:  MOVWF  3A
0B31:  BCF    0A.3
0B32:  BCF    03.5
0B33:  CALL   1D2
0B34:  BSF    0A.3
0B35:  BTFSC  28.7
0B36:  BSF    0B.7
....................   
....................     output_low(EEPROM_CS);  // Select the EEPROM  
0B37:  BCF    05.1
....................     spi_write(0x06);        // WRITE ENABLE command byte  
0B38:  MOVF   13,W
0B39:  MOVLW  06
0B3A:  MOVWF  13
0B3B:  BSF    03.5
0B3C:  BTFSC  14.0
0B3D:  GOTO   340
0B3E:  BCF    03.5
0B3F:  GOTO   33B
....................     output_high(EEPROM_CS); // De-select the EEPROM to set WRITE ENABLE  
0B40:  BCF    03.5
0B41:  BSF    05.1
....................     // The 25C40 needs a little delay (500 ns)  
.................... #asm  
....................     nop  
0B42:  NOP
....................     nop  
0B43:  NOP
....................     nop  
0B44:  NOP
.................... #endasm  
....................     output_low(EEPROM_CS);  // Select the EEPROM  
0B45:  BCF    05.1
....................     spi_write(0x02);        // WRITE  command byte, A8=0  
0B46:  MOVF   13,W
0B47:  MOVLW  02
0B48:  MOVWF  13
0B49:  BSF    03.5
0B4A:  BTFSC  14.0
0B4B:  GOTO   34E
0B4C:  BCF    03.5
0B4D:  GOTO   349
....................     spi_write(address);     // ADDRESS byte  
0B4E:  BCF    03.5
0B4F:  MOVF   13,W
0B50:  BSF    03.5
0B51:  MOVF   24,W
0B52:  BCF    03.5
0B53:  MOVWF  13
0B54:  BSF    03.5
0B55:  BTFSC  14.0
0B56:  GOTO   359
0B57:  BCF    03.5
0B58:  GOTO   354
....................     spi_write(data);        // DATA byte  
0B59:  BCF    03.5
0B5A:  MOVF   13,W
0B5B:  BSF    03.5
0B5C:  MOVF   25,W
0B5D:  BCF    03.5
0B5E:  MOVWF  13
0B5F:  BSF    03.5
0B60:  BTFSC  14.0
0B61:  GOTO   364
0B62:  BCF    03.5
0B63:  GOTO   35F
....................     output_high(EEPROM_CS); // De-select the EEPROM  
0B64:  BCF    03.5
0B65:  BSF    05.1
....................   
....................     //  
....................     // Wait for WRITE to complete  
....................     do {  
....................         // The 25C40 needs a little delay (500 ns) between CS  
.................... #asm  
....................         nop  
0B66:  NOP
....................         nop  
0B67:  NOP
....................         nop  
0B68:  NOP
.................... #endasm  
....................         output_low(EEPROM_CS);  // Select the EEPROM  
0B69:  BCF    05.1
....................         spi_write(0x05);    // READ STATUS REGISTER  
0B6A:  MOVF   13,W
0B6B:  MOVLW  05
0B6C:  MOVWF  13
0B6D:  BSF    03.5
0B6E:  BTFSC  14.0
0B6F:  GOTO   372
0B70:  BCF    03.5
0B71:  GOTO   36D
....................         i = spi_read(0);    // WIP (Write In Progess) = bit 0  
0B72:  BCF    03.5
0B73:  MOVF   13,W
0B74:  CLRF   13
0B75:  BSF    03.5
0B76:  BTFSC  14.0
0B77:  GOTO   37A
0B78:  BCF    03.5
0B79:  GOTO   375
0B7A:  BCF    03.5
0B7B:  MOVF   13,W
0B7C:  BSF    03.5
0B7D:  MOVWF  26
....................         output_high(EEPROM_CS); // De-select the EEPROM  
0B7E:  BCF    03.5
0B7F:  BSF    05.1
....................     } while (i & 0x01);  
....................   
....................     return;  
0B80:  BSF    03.5
0B81:  BTFSS  26.0
0B82:  GOTO   385
0B83:  BCF    03.5
0B84:  GOTO   366
.................... }  
0B85:  BCF    03.5
0B86:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Output an updated DAC value in LTC1448  
.................... //  
.................... // DAC output values in DAC_CH0 and DAC_CH1  
.................... //  
.................... // These need to be put together into 3 bytes (24 bits) for the DAC  
.................... //  
.................... #separate  
.................... update_dac()  
.................... {  
....................     int8    data;  
....................   
....................     // Check and set SPI mode  
....................     if (SpiMode != SPI_DAC)  
....................         setup_spi_mode(SPI_DAC);  
*
0BA7:  MOVF   32,W
0BA8:  SUBLW  02
0BA9:  BTFSC  03.2
0BAA:  GOTO   3B8
0BAB:  CLRF   28
0BAC:  BTFSC  0B.7
0BAD:  BSF    28.7
0BAE:  BCF    0B.7
0BAF:  MOVLW  02
0BB0:  BSF    03.5
0BB1:  MOVWF  3A
0BB2:  BCF    0A.3
0BB3:  BCF    03.5
0BB4:  CALL   1D2
0BB5:  BSF    0A.3
0BB6:  BTFSC  28.7
0BB7:  BSF    0B.7
....................   
....................     output_low(DAC_CS);     // Select the D/A converter  
0BB8:  BCF    05.5
....................   
....................     data = ((DAC_CH0 & 0x0FF0) >> 4);  
0BB9:  MOVF   38,W
0BBA:  ANDLW  F0
0BBB:  BSF    03.5
0BBC:  MOVWF  23
0BBD:  BCF    03.5
0BBE:  MOVF   39,W
0BBF:  ANDLW  0F
0BC0:  BSF    03.5
0BC1:  MOVWF  24
0BC2:  RRF    24,W
0BC3:  MOVWF  7A
0BC4:  RRF    23,W
0BC5:  MOVWF  79
0BC6:  RRF    7A,F
0BC7:  RRF    79,F
0BC8:  RRF    7A,F
0BC9:  RRF    79,F
0BCA:  RRF    7A,F
0BCB:  RRF    79,F
0BCC:  MOVF   79,W
0BCD:  MOVWF  22
....................     spi_write(data);  
0BCE:  BCF    03.5
0BCF:  MOVF   13,W
0BD0:  BSF    03.5
0BD1:  MOVF   22,W
0BD2:  BCF    03.5
0BD3:  MOVWF  13
0BD4:  BSF    03.5
0BD5:  BTFSC  14.0
0BD6:  GOTO   3D9
0BD7:  BCF    03.5
0BD8:  GOTO   3D4
....................   
....................     data = ((DAC_CH0 & 0x000F) << 4);  
0BD9:  BCF    03.5
0BDA:  MOVF   38,W
0BDB:  ANDLW  0F
0BDC:  BSF    03.5
0BDD:  MOVWF  23
0BDE:  BCF    03.5
0BDF:  MOVF   39,W
0BE0:  ANDLW  00
0BE1:  BSF    03.5
0BE2:  MOVWF  24
0BE3:  RLF    23,W
0BE4:  MOVWF  79
0BE5:  RLF    24,W
0BE6:  MOVWF  7A
0BE7:  RLF    79,F
0BE8:  RLF    7A,F
0BE9:  RLF    79,F
0BEA:  RLF    7A,F
0BEB:  RLF    79,F
0BEC:  RLF    7A,F
0BED:  MOVLW  F0
0BEE:  ANDWF  79,F
0BEF:  MOVF   79,W
0BF0:  MOVWF  22
....................     data = data | ((DAC_CH1 & 0x0F00) >> 8);  
0BF1:  BCF    03.5
0BF2:  MOVF   3A,W
0BF3:  ANDLW  00
0BF4:  BSF    03.5
0BF5:  MOVWF  23
0BF6:  BCF    03.5
0BF7:  MOVF   3B,W
0BF8:  ANDLW  0F
0BF9:  BSF    03.5
0BFA:  MOVWF  24
0BFB:  CLRF   7A
0BFC:  IORWF  22,F
....................     spi_write(data);  
0BFD:  BCF    03.5
0BFE:  MOVF   13,W
0BFF:  BSF    03.5
0C00:  MOVF   22,W
0C01:  BCF    03.5
0C02:  MOVWF  13
0C03:  BSF    03.5
0C04:  BTFSC  14.0
0C05:  GOTO   408
0C06:  BCF    03.5
0C07:  GOTO   403
....................   
....................     data = (DAC_CH1 & 0x00FF);  
0C08:  BCF    03.5
0C09:  MOVF   3A,W
0C0A:  BSF    03.5
0C0B:  MOVWF  22
....................     spi_write(data);  
0C0C:  BCF    03.5
0C0D:  MOVF   13,W
0C0E:  BSF    03.5
0C0F:  MOVF   22,W
0C10:  BCF    03.5
0C11:  MOVWF  13
0C12:  BSF    03.5
0C13:  BTFSC  14.0
0C14:  GOTO   417
0C15:  BCF    03.5
0C16:  GOTO   412
....................   
....................     output_high(DAC_CS);    // De-Select the D/A converter  
0C17:  BCF    03.5
0C18:  BSF    05.5
....................     return;  
.................... }  
0C19:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Acquire and A/D value from LTC1296  
.................... //  
.................... #separate  
.................... int16 acquire_adc(int8 control, int8 unipolar)  
.................... {  
....................     int16   ad_sample;  
....................     int8    data;  
....................   
....................     // Check and configure SPI if needed  
....................     if (EEFLags & SLOW_ADC_CLOCK) {  
0C1A:  BTFSS  29.1
0C1B:  GOTO   42E
....................         if (SpiMode != SPI_ADC_SLOW)  
....................             setup_spi_mode(SPI_ADC_SLOW);  
0C1C:  MOVF   32,W
0C1D:  SUBLW  03
0C1E:  BTFSC  03.2
0C1F:  GOTO   42D
0C20:  CLRF   28
0C21:  BTFSC  0B.7
0C22:  BSF    28.7
0C23:  BCF    0B.7
0C24:  MOVLW  03
0C25:  BSF    03.5
0C26:  MOVWF  3A
0C27:  BCF    0A.3
0C28:  BCF    03.5
0C29:  CALL   1D2
0C2A:  BSF    0A.3
0C2B:  BTFSC  28.7
0C2C:  BSF    0B.7
....................     } else {  
0C2D:  GOTO   43F
....................         if (SpiMode != SPI_ADC_FAST)  
....................             setup_spi_mode(SPI_ADC_FAST);  
0C2E:  MOVF   32,W
0C2F:  SUBLW  02
0C30:  BTFSC  03.2
0C31:  GOTO   43F
0C32:  CLRF   28
0C33:  BTFSC  0B.7
0C34:  BSF    28.7
0C35:  BCF    0B.7
0C36:  MOVLW  02
0C37:  BSF    03.5
0C38:  MOVWF  3A
0C39:  BCF    0A.3
0C3A:  BCF    03.5
0C3B:  CALL   1D2
0C3C:  BSF    0A.3
0C3D:  BTFSC  28.7
0C3E:  BSF    0B.7
....................     }  
....................   
....................     output_low(AD_CS);              // Select the D/A converter  
0C3F:  BCF    05.0
....................   
....................     data = control & 0x0F;          // Mask off lower nibble  
0C40:  BSF    03.5
0C41:  MOVF   22,W
0C42:  ANDLW  0F
0C43:  MOVWF  26
....................     data = data | 0x10;             // OR in the START bit  
0C44:  BSF    26.4
....................     spi_write(data);  
0C45:  BCF    03.5
0C46:  MOVF   13,W
0C47:  BSF    03.5
0C48:  MOVF   26,W
0C49:  BCF    03.5
0C4A:  MOVWF  13
0C4B:  BSF    03.5
0C4C:  BTFSC  14.0
0C4D:  GOTO   450
0C4E:  BCF    03.5
0C4F:  GOTO   44B
....................   
....................     if (unipolar) {  
0C50:  MOVF   23,F
0C51:  BTFSC  03.2
0C52:  GOTO   461
....................         data = spi_read(0xE0);      // UNI=1, MSBF=1, PS=1  
0C53:  BCF    03.5
0C54:  MOVF   13,W
0C55:  MOVLW  E0
0C56:  MOVWF  13
0C57:  BSF    03.5
0C58:  BTFSC  14.0
0C59:  GOTO   45C
0C5A:  BCF    03.5
0C5B:  GOTO   457
0C5C:  BCF    03.5
0C5D:  MOVF   13,W
0C5E:  BSF    03.5
0C5F:  MOVWF  26
....................     } else {  
0C60:  GOTO   46E
....................         data = spi_read(0x60);      // UNI=0, MSBF=1, PS=1  
0C61:  BCF    03.5
0C62:  MOVF   13,W
0C63:  MOVLW  60
0C64:  MOVWF  13
0C65:  BSF    03.5
0C66:  BTFSC  14.0
0C67:  GOTO   46A
0C68:  BCF    03.5
0C69:  GOTO   465
0C6A:  BCF    03.5
0C6B:  MOVF   13,W
0C6C:  BSF    03.5
0C6D:  MOVWF  26
....................     }  
....................   
....................     ad_sample = data & 0x0F;        // Upper 4 bits of data conversion  
0C6E:  MOVF   26,W
0C6F:  ANDLW  0F
0C70:  MOVWF  24
0C71:  CLRF   25
....................     ad_sample = ad_sample << 8;  
0C72:  MOVF   24,W
0C73:  MOVWF  25
0C74:  CLRF   24
....................   
....................     data = spi_read(0);             // Get lower 8 bits of data comnversion  
0C75:  BCF    03.5
0C76:  MOVF   13,W
0C77:  CLRF   13
0C78:  BSF    03.5
0C79:  BTFSC  14.0
0C7A:  GOTO   47D
0C7B:  BCF    03.5
0C7C:  GOTO   478
0C7D:  BCF    03.5
0C7E:  MOVF   13,W
0C7F:  BSF    03.5
0C80:  MOVWF  26
....................     ad_sample = ad_sample | data;  
0C81:  MOVF   26,W
0C82:  IORWF  24,F
....................   
....................     output_high(AD_CS);     // De-Select the D/A converter  
0C83:  BCF    03.5
0C84:  BSF    05.0
....................     return (ad_sample);  
0C85:  BSF    03.5
0C86:  MOVF   24,W
0C87:  MOVWF  78
0C88:  MOVF   25,W
0C89:  MOVWF  79
.................... }  
0C8A:  BCF    03.5
0C8B:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Turn LED on (RED)  
.................... //  
.................... led_on_red(void)  
.................... {  
....................     output_high(LED_RED);  
*
021A:  BSF    07.1
....................     output_low(LED_GREEN);  
021B:  BCF    07.0
....................     return;  
.................... }  
021C:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Turn LED on (GREEN)  
.................... //  
.................... led_on_green(void)  
.................... {  
....................     output_high(LED_GREEN);  
*
06D0:  BSF    07.0
....................     output_low(LED_RED);  
06D1:  BCF    07.1
....................     return;  
.................... }  
06D2:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Turn LED off  
.................... //  
.................... led_off(void)  
.................... {  
....................     output_low(LED_RED);  
*
0760:  BCF    07.1
....................     output_low(LED_GREEN);  
0761:  BCF    07.0
....................     return;  
.................... }  
0762:  RETLW  00
....................   
.................... #separate  
.................... trigger_led_red(void)  
.................... {  
....................     // Only start the Red sequence if it was Green  
....................     if (LedGreenFlag) {  
*
021D:  MOVF   34,F
021E:  BTFSC  03.2
021F:  GOTO   224
....................         LedGreenFlag = 0;  
0220:  CLRF   34
....................         LedCount = 90;          // To make a faster Red LED blink, put a value here (0 ... 100)  
0221:  MOVLW  5A
0222:  MOVWF  35
....................                                 // Full blink gets a 0  
....................         led_on_red();  
0223:  CALL   21A
....................     }  
.................... }  
0224:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Write the digital output to PORT1  
.................... // BIT 0 = PORTE 0  
.................... // BIT 1-7 = PORTB 1-7  
.................... //  
.................... #separate  
.................... write_port1(int8 value)  
.................... {  
....................     // Expander inversion  
....................     if (EEFlags & EXPANDER_FLAG)  
....................         value = value ^ 0xFF;  
*
0B87:  BTFSS  29.0
0B88:  GOTO   38D
0B89:  MOVLW  FF
0B8A:  BSF    03.5
0B8B:  XORWF  22,F
0B8C:  BCF    03.5
....................   
....................     if (value & 0x01)           // bit 0 = PORTe bit 0  
....................         output_high(PIN_E0);  
0B8D:  BSF    03.5
0B8E:  BTFSS  22.0
0B8F:  GOTO   394
0B90:  BCF    03.5
0B91:  BSF    09.0
....................     else  
....................         output_low(PIN_E0);  
0B92:  GOTO   396
0B93:  BSF    03.5
0B94:  BCF    03.5
0B95:  BCF    09.0
....................   
....................     value = value & 0xFE;       // mask off bit 0  
0B96:  BSF    03.5
0B97:  BCF    22.0
....................     PORT_B = value;             // bits 1-7 = PORTB 1-7  
0B98:  MOVF   22,W
0B99:  BCF    03.5
0B9A:  MOVWF  06
....................     return;  
.................... }  
0B9B:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Read the digital input of PORT1  
.................... // BIT 0 = PORTE 0  
.................... // BIT 1-7 = PORTB 1-7  
.................... //  
.................... #separate  
.................... int8 read_port1(void)  
.................... {  
....................     int8 value, mask;  
....................   
....................     value = PORT_B;             // PORT1 bits 1-7 are PORTB bits 1-7  
*
0C9B:  MOVF   06,W
0C9C:  BSF    03.5
0C9D:  MOVWF  22
....................     value = PORT_B & 0xFE;      // mask off bit 0  
0C9E:  BCF    03.5
0C9F:  MOVF   06,W
0CA0:  ANDLW  FE
0CA1:  BSF    03.5
0CA2:  MOVWF  22
....................     mask  = PORT_E;             // PORT1 bit 0 = PORTE bit 0  
0CA3:  BCF    03.5
0CA4:  MOVF   09,W
0CA5:  BSF    03.5
0CA6:  MOVWF  23
....................     mask  = mask * 0x01;  
....................     value = value | mask;  
0CA7:  MOVF   23,W
0CA8:  IORWF  22,F
....................   
....................     // Expander inversion  
....................     if (EEFlags & EXPANDER_FLAG)  
....................         value = value ^ 0xFF;  
0CA9:  BCF    03.5
0CAA:  BTFSS  29.0
0CAB:  GOTO   4B0
0CAC:  MOVLW  FF
0CAD:  BSF    03.5
0CAE:  XORWF  22,F
0CAF:  BCF    03.5
....................     return (value);  
0CB0:  BSF    03.5
0CB1:  MOVF   22,W
0CB2:  MOVWF  78
.................... }  
0CB3:  BCF    03.5
0CB4:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Write the digital output to PORT2  
.................... // BIT 0-7 = PORTD 0-7  
.................... //  
.................... write_port2(int8 value)  
.................... {  
....................     // Expander inversion  
....................     if (EEFlags & EXPANDER_FLAG)  
....................         value = value ^ 0xFF;  
*
0B9C:  BTFSS  29.0
0B9D:  GOTO   3A2
0B9E:  MOVLW  FF
0B9F:  BSF    03.5
0BA0:  XORWF  22,F
0BA1:  BCF    03.5
....................     PORT_D = value;  
0BA2:  BSF    03.5
0BA3:  MOVF   22,W
0BA4:  BCF    03.5
0BA5:  MOVWF  08
....................     return;  
.................... }  
0BA6:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Read the digital input of PORT2  
.................... // BIT 0-7 = PORTB 0-7  
.................... //  
.................... int8 read_port2(void)  
.................... {  
....................     int8 value;  
....................   
....................     value = PORT_D;             // PORT2 bits 0-7 = PORT_D bits 0-7  
*
0C8C:  MOVF   08,W
0C8D:  BSF    03.5
0C8E:  MOVWF  22
....................   
....................     // Expander inversion  
....................     if (EEFlags & EXPANDER_FLAG)  
....................         value = value ^ 0xFF;  
0C8F:  BCF    03.5
0C90:  BTFSS  29.0
0C91:  GOTO   496
0C92:  MOVLW  FF
0C93:  BSF    03.5
0C94:  XORWF  22,F
0C95:  BCF    03.5
....................     return (value);  
0C96:  BSF    03.5
0C97:  MOVF   22,W
0C98:  MOVWF  78
.................... }  
0C99:  BCF    03.5
0C9A:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Set the data direction of PORT1  
.................... // BIT 0 = PORTE 0  
.................... // BIT 1-7 = PORTB 1-7  
.................... //  
.................... set_dir_port1(int8 direction)  
.................... {  
....................     int8 i;  
....................     Port1_Dir = direction;  
*
103D:  MOVF   22,W
103E:  BCF    03.5
103F:  MOVWF  36
*
1471:  MOVF   22,W
1472:  BCF    03.5
1473:  MOVWF  36
....................     write_eeprom(EEPROM_DIR_PORT1, Port1_Dir);  
*
1040:  MOVLW  02
1041:  BSF    03.5
1042:  MOVWF  24
1043:  BCF    03.5
1044:  MOVF   36,W
1045:  BSF    03.5
1046:  MOVWF  25
1047:  BCF    0A.4
1048:  BSF    0A.3
1049:  BCF    03.5
104A:  CALL   326
104B:  BSF    0A.4
104C:  BCF    0A.3
*
1474:  MOVLW  02
1475:  BSF    03.5
1476:  MOVWF  24
1477:  BCF    03.5
1478:  MOVF   36,W
1479:  BSF    03.5
147A:  MOVWF  25
147B:  BCF    0A.4
147C:  BSF    0A.3
147D:  BCF    03.5
147E:  CALL   326
147F:  BSF    0A.4
1480:  BCF    0A.3
....................     i = Port1_Dir | 0x01;  
*
104D:  MOVF   36,W
104E:  IORLW  01
104F:  BSF    03.5
1050:  MOVWF  23
*
1481:  MOVF   36,W
1482:  IORLW  01
1483:  BSF    03.5
1484:  MOVWF  23
....................     set_tris_b(i);          // bit 0 = input, bits 1-7 set by Port1_Dir  
*
1051:  TRIS   6
*
1485:  TRIS   6
....................     i = Port1_Dir & 0x01;  
*
1052:  BCF    03.5
1053:  MOVF   36,W
1054:  ANDLW  01
1055:  BSF    03.5
1056:  MOVWF  23
*
1486:  BCF    03.5
1487:  MOVF   36,W
1488:  ANDLW  01
1489:  BSF    03.5
148A:  MOVWF  23
....................     i = i | 0x06;  
*
1057:  MOVLW  06
1058:  IORWF  23,F
*
148B:  MOVLW  06
148C:  IORWF  23,F
....................     set_tris_e(i);          // bits 1-2 = input, bit 0 set by Port1_Dir  
*
1059:  MOVF   09,W
105A:  ANDLW  F8
105B:  MOVWF  77
105C:  MOVF   23,W
105D:  ANDLW  07
105E:  IORWF  77,W
105F:  MOVWF  09
*
148D:  MOVF   09,W
148E:  ANDLW  F8
148F:  MOVWF  77
1490:  MOVF   23,W
1491:  ANDLW  07
1492:  IORWF  77,W
1493:  MOVWF  09
....................     return;  
.................... }  
....................   
.................... int8 get_dir_port1(void)  
.................... {  
....................     return (Port1_Dir);  
*
0D1F:  MOVF   36,W
0D20:  MOVWF  78
.................... }  
0D21:  BCF    0A.3
0D22:  BSF    0A.4
0D23:  GOTO   4D2 (RETURN)
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Set the data direction of PORT2  
.................... // BIT 0-7 = PORTB 0-7  
.................... //  
.................... set_dir_port2(int8 direction)  
.................... {  
....................     Port2_Dir = direction;  
*
106B:  MOVF   22,W
106C:  BCF    03.5
106D:  MOVWF  37
*
14A1:  MOVF   22,W
14A2:  BCF    03.5
14A3:  MOVWF  37
....................     write_eeprom(EEPROM_DIR_PORT2, Port2_Dir);  
*
106E:  MOVLW  03
106F:  BSF    03.5
1070:  MOVWF  24
1071:  BCF    03.5
1072:  MOVF   37,W
1073:  BSF    03.5
1074:  MOVWF  25
1075:  BCF    0A.4
1076:  BSF    0A.3
1077:  BCF    03.5
1078:  CALL   326
1079:  BSF    0A.4
107A:  BCF    0A.3
*
14A4:  MOVLW  03
14A5:  BSF    03.5
14A6:  MOVWF  24
14A7:  BCF    03.5
14A8:  MOVF   37,W
14A9:  BSF    03.5
14AA:  MOVWF  25
14AB:  BCF    0A.4
14AC:  BSF    0A.3
14AD:  BCF    03.5
14AE:  CALL   326
14AF:  BSF    0A.4
14B0:  BCF    0A.3
....................     set_tris_d(Port2_Dir);  
*
107B:  MOVF   37,W
107C:  BSF    03.5
107D:  MOVWF  08
*
14B1:  MOVF   37,W
14B2:  BSF    03.5
14B3:  MOVWF  08
....................     return;  
.................... }  
....................   
.................... int8 get_dir_port2(void)  
.................... {  
....................     return (Port2_Dir);  
*
0D24:  MOVF   37,W
0D25:  MOVWF  78
.................... }  
0D26:  BCF    0A.3
0D27:  BSF    0A.4
0D28:  GOTO   4E4 (RETURN)
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Converts 2 hexadecimal ASCII characters pointed to *ptr to a binary value  
.................... //  
.................... #separate  
.................... int8 hex_to_bin(int8 *ptr)  
.................... {  
....................     int8 value, i;  
....................     int8 *tmp_ptr;  
....................   
....................     tmp_ptr = ptr;  
*
0CE7:  BSF    03.5
0CE8:  MOVF   22,W
0CE9:  MOVWF  25
....................   
....................     // MSB conversion  
....................     for (i=0; i<16; i++) {  
0CEA:  CLRF   24
0CEB:  MOVF   24,W
0CEC:  SUBLW  0F
0CED:  BTFSS  03.0
0CEE:  GOTO   503
....................         if (BIN_TO_HEX_TBL[i] == *tmp_ptr) {  
0CEF:  MOVF   24,W
0CF0:  BCF    0A.3
0CF1:  BCF    03.5
0CF2:  CALL   043
0CF3:  BSF    0A.3
0CF4:  BSF    03.5
0CF5:  MOVWF  26
0CF6:  MOVF   25,W
0CF7:  MOVWF  04
0CF8:  MOVF   00,W
0CF9:  SUBWF  26,W
0CFA:  BTFSS  03.2
0CFB:  GOTO   501
....................             value = i * 16;  
0CFC:  SWAPF  24,W
0CFD:  MOVWF  23
0CFE:  MOVLW  F0
0CFF:  ANDWF  23,F
....................             break;  
0D00:  GOTO   503
....................         }  
....................     }  
0D01:  INCF   24,F
0D02:  GOTO   4EB
....................   
....................     // LSB conversion  
....................     tmp_ptr++;  
0D03:  INCF   25,F
....................     for (i=0; i<16; i++) {  
0D04:  CLRF   24
0D05:  MOVF   24,W
0D06:  SUBLW  0F
0D07:  BTFSS  03.0
0D08:  GOTO   51B
....................         if (BIN_TO_HEX_TBL[i] == *tmp_ptr) {  
0D09:  MOVF   24,W
0D0A:  BCF    0A.3
0D0B:  BCF    03.5
0D0C:  CALL   043
0D0D:  BSF    0A.3
0D0E:  BSF    03.5
0D0F:  MOVWF  26
0D10:  MOVF   25,W
0D11:  MOVWF  04
0D12:  MOVF   00,W
0D13:  SUBWF  26,W
0D14:  BTFSS  03.2
0D15:  GOTO   519
....................             value = value + i;  
0D16:  MOVF   24,W
0D17:  ADDWF  23,F
....................             break;  
0D18:  GOTO   51B
....................         }  
....................     }  
0D19:  INCF   24,F
0D1A:  GOTO   505
....................   
....................     return (value);  
0D1B:  MOVF   23,W
0D1C:  MOVWF  78
.................... }  
0D1D:  BCF    03.5
0D1E:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Converts binary value to two hexadecimal ASCII characters  
.................... //  
.................... #separate  
.................... void bin_to_hex(int8 value, int8 *ptr)  
.................... {  
....................     int8 tbl_index;  
....................     int8 *tmp_ptr;  
....................   
....................     tmp_ptr = ptr;  
*
0CC4:  BSF    03.5
0CC5:  MOVF   23,W
0CC6:  MOVWF  25
....................   
....................     // MSB first  
....................     tbl_index = value;  
0CC7:  MOVF   22,W
0CC8:  MOVWF  24
....................     tbl_index = tbl_index & 0xF0;  
0CC9:  MOVLW  F0
0CCA:  ANDWF  24,F
....................     tbl_index = tbl_index >> 4;  
0CCB:  SWAPF  24,F
0CCC:  MOVLW  0F
0CCD:  ANDWF  24,F
....................     *tmp_ptr = BIN_TO_HEX_TBL[tbl_index];  
0CCE:  MOVF   25,W
0CCF:  MOVWF  04
0CD0:  MOVF   24,W
0CD1:  BCF    0A.3
0CD2:  BCF    03.5
0CD3:  CALL   043
0CD4:  BSF    0A.3
0CD5:  MOVWF  78
0CD6:  MOVWF  00
....................     // LSB last  
....................     tbl_index = value;  
0CD7:  BSF    03.5
0CD8:  MOVF   22,W
0CD9:  MOVWF  24
....................     tbl_index = tbl_index & 0x0F;  
0CDA:  MOVLW  0F
0CDB:  ANDWF  24,F
....................     tmp_ptr++;  
0CDC:  INCF   25,F
....................     *tmp_ptr = BIN_TO_HEX_TBL[tbl_index];  
0CDD:  MOVF   25,W
0CDE:  MOVWF  04
0CDF:  MOVF   24,W
0CE0:  BCF    0A.3
0CE1:  BCF    03.5
0CE2:  CALL   043
0CE3:  BSF    0A.3
0CE4:  MOVWF  78
0CE5:  MOVWF  00
....................     return;  
.................... }  
0CE6:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // RTCC/Timer0 interrupt - pulse counter is redirected to Timer0  
.................... //  
.................... #int_timer0  
.................... void timer0_isr(void)  
.................... {  
....................     PulseCount = PulseCount + 0x100;  
*
0752:  MOVLW  01
0753:  ADDWF  3D,F
0754:  MOVLW  00
0755:  BTFSC  03.0
0756:  MOVLW  01
0757:  ADDWF  3E,F
0758:  MOVLW  00
0759:  BTFSC  03.0
075A:  MOVLW  01
075B:  ADDWF  3F,F
....................     return;  
.................... }  
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Timer1 interrupt - 10 milliseconds  
.................... //  
075C:  BCF    0B.2
075D:  BCF    0A.3
075E:  BCF    0A.4
075F:  GOTO   027
.................... #int_timer1  
.................... void timer1_isr(void)  
.................... {  
.................... //    set_timer1(0xEC78);                       // 1ms = 65536-(.001/(4/20000000)) = 60536 (0xEC78)  
....................     set_timer1(0x3CB0);                       // 10ms = 65536-(.01/(4/20000000)) = 0x3CB0  
*
0763:  MOVLW  3C
0764:  MOVWF  0F
0765:  MOVLW  B0
0766:  MOVWF  0E
....................   
....................     LedCount++;  
0767:  INCF   35,F
....................     if (LedCount < 100) {                   // One second count (LED on)  
0768:  MOVF   35,W
0769:  SUBLW  63
076A:  BTFSS  03.0
076B:  GOTO   777
....................         if (LedCount & 1) {  
076C:  BTFSS  35.0
076D:  GOTO   775
....................             if (LedGreenFlag)               // LED on (Red or Green)  
....................                 led_on_green();  
076E:  MOVF   34,F
076F:  BTFSC  03.2
0770:  GOTO   773
0771:  CALL   6D0
....................             else  
....................                 led_on_red();  
0772:  GOTO   774
0773:  CALL   21A
....................         } else {  
0774:  GOTO   776
....................             led_off();                      // Toggle off every other cycle (100 Hz)  
0775:  CALL   760
....................         }  
....................     } else {  
0776:  GOTO   78A
....................         led_off();  
0777:  CALL   760
....................         if (LedGreenFlag) {  
0778:  MOVF   34,F
0779:  BTFSC  03.2
077A:  GOTO   783
....................             // Green LED timing  
....................             if (LedCount > 200) {               // Two second count (LED off)  
077B:  MOVF   35,W
077C:  SUBLW  C8
077D:  BTFSC  03.0
077E:  GOTO   782
....................                 LedCount = 0;  
077F:  CLRF   35
....................                 LedGreenFlag = 1;  
0780:  MOVLW  01
0781:  MOVWF  34
....................             }  
....................         } else {  
0782:  GOTO   78A
....................             // Red LED timing  
....................             if (LedCount > 110) {               // short off phase (250 ms.)  
0783:  MOVF   35,W
0784:  SUBLW  6E
0785:  BTFSC  03.0
0786:  GOTO   78A
....................                 LedCount = 0;  
0787:  CLRF   35
....................                 LedGreenFlag = 1;  
0788:  MOVLW  01
0789:  MOVWF  34
....................             }  
....................         }  
....................     }  
....................     return;  
.................... }  
....................   
....................   
.................... //-----------------------------------------------------------------------------  
.................... // update_eesettings - updates the EEPROM based flags and vriables  
.................... //  
078A:  BCF    0C.0
078B:  BCF    0A.3
078C:  BCF    0A.4
078D:  GOTO   027
.................... #separate  
.................... void update_eesettings(void)  
.................... {  
....................     int8 i;  
....................   
....................     //  
....................     // Expander flag and slow A/D flag  
....................     //  
....................     i = read_eeprom(EEPROM_EXPANDER_FLAG);  
*
07C4:  MOVLW  08
07C5:  BSF    03.5
07C6:  MOVWF  25
07C7:  BCF    03.5
07C8:  CALL   78E
07C9:  MOVF   78,W
07CA:  BSF    03.5
07CB:  MOVWF  22
....................     if (i) {  
07CC:  MOVF   22,F
07CD:  BTFSC  03.2
07CE:  GOTO   7D3
....................         EEFlags = EEFLags | EXPANDER_FLAG;  
07CF:  BCF    03.5
07D0:  BSF    29.0
....................     } else {  
07D1:  GOTO   7D5
07D2:  BSF    03.5
....................         EEFlags = EEFLags & (~EXPANDER_FLAG);  
07D3:  BCF    03.5
07D4:  BCF    29.0
....................     }  
....................     i = read_eeprom(EEPROM_AD_SAMPLE_CLK);  
07D5:  MOVLW  0D
07D6:  BSF    03.5
07D7:  MOVWF  25
07D8:  BCF    03.5
07D9:  CALL   78E
07DA:  MOVF   78,W
07DB:  BSF    03.5
07DC:  MOVWF  22
....................     if (i) {  
07DD:  MOVF   22,F
07DE:  BTFSC  03.2
07DF:  GOTO   7E4
....................         EEFlags = EEFLags | SLOW_ADC_CLOCK;  
07E0:  BCF    03.5
07E1:  BSF    29.1
....................     } else {  
07E2:  GOTO   7E6
07E3:  BSF    03.5
....................         EEFlags = EEFLags & (~SLOW_ADC_CLOCK);  
07E4:  BCF    03.5
07E5:  BCF    29.1
....................     }  
....................   
....................     // A/D Control nibble. In EEPROM locations 0x11 to 0x18  
....................     for (i=0; i<8; i++) {  
07E6:  BSF    03.5
07E7:  CLRF   22
07E8:  MOVF   22,W
07E9:  SUBLW  07
07EA:  BTFSS  03.0
07EB:  GOTO   7FC
....................         AdcNibble[i] = read_eeprom(0x11+i);  
07EC:  MOVLW  2A
07ED:  ADDWF  22,W
07EE:  MOVWF  23
07EF:  MOVLW  11
07F0:  ADDWF  22,W
07F1:  MOVWF  24
07F2:  MOVWF  25
07F3:  BCF    03.5
07F4:  CALL   78E
07F5:  BSF    03.5
07F6:  MOVF   23,W
07F7:  MOVWF  04
07F8:  MOVF   78,W
07F9:  MOVWF  00
....................     }  
07FA:  INCF   22,F
07FB:  GOTO   7E8
....................   
....................     return;  
.................... }  
07FC:  BCF    03.5
07FD:  RETLW  00
....................   
.................... //-----------------------------------------------------------------------------  
.................... // Main program entry point.  
.................... //  
.................... main() {  
....................   
*
1000:  CLRF   04
1001:  MOVLW  1F
1002:  ANDWF  03,F
1003:  MOVLW  81
1004:  BSF    03.5
1005:  MOVWF  19
1006:  MOVLW  26
1007:  MOVWF  18
1008:  MOVLW  90
1009:  BCF    03.5
100A:  MOVWF  18
....................     int8    i, j, k, x;  
....................     int16   temp;  
....................   
....................     //  
....................     // Setup the TRIS registers and initial port outputs  
....................     // Disable all SPI device chip selects  
....................     //  
....................     set_tris_a(0x10);   // A0-3=O, A4=I, A5=O  
*
101D:  MOVLW  10
101E:  TRIS   5
....................     output_high(AD_CS);  
101F:  BSF    05.0
....................     output_high(EEPROM_CS);  
1020:  BSF    05.1
....................     output_high(USB_CS);  
1021:  BSF    05.2
....................     output_high(RTC_CS);  
1022:  BSF    05.3
....................     output_high(DAC_CS);  
1023:  BSF    05.5
....................   
....................     set_tris_b(0xFF);   // B0-7=I  
1024:  MOVLW  FF
1025:  TRIS   6
....................     set_tris_d(0xFF);   // D0-7=I  
1026:  BSF    03.5
1027:  MOVWF  08
....................     set_tris_c(0xD0);   // C0-3=O, C4=I, C6=I, C7=I  
1028:  MOVLW  D0
1029:  TRIS   7
....................     set_tris_e(0x07);   // E0-3=I  
102A:  BSF    09.0
102B:  BSF    09.1
102C:  BSF    09.2
....................   
....................     //  
....................     // Get EEPROM settings  
....................     //  
....................     update_eesettings();  
102D:  BCF    0A.4
102E:  BCF    03.5
102F:  CALL   7C4
1030:  BSF    0A.4
....................   
.................... //    while (TRUE) {  
.................... //        temp = acquire_adc(8, 1);  
.................... //    }  
....................   
....................     //  
....................     // Set Port data direction from EEPROM  
....................     //  
....................     i = read_eeprom(EEPROM_DIR_PORT1);  
1031:  MOVLW  02
1032:  BSF    03.5
1033:  MOVWF  25
1034:  BCF    0A.4
1035:  BCF    03.5
1036:  CALL   78E
1037:  BSF    0A.4
1038:  MOVF   78,W
1039:  MOVWF  75
....................     set_dir_port1(i);  
103A:  MOVF   75,W
103B:  BSF    03.5
103C:  MOVWF  22
....................     i = read_eeprom(EEPROM_DIR_PORT2);  
*
1060:  MOVLW  03
1061:  MOVWF  25
1062:  BCF    0A.4
1063:  BCF    03.5
1064:  CALL   78E
1065:  BSF    0A.4
1066:  MOVF   78,W
1067:  MOVWF  75
....................     set_dir_port2(i);  
1068:  MOVF   75,W
1069:  BSF    03.5
106A:  MOVWF  22
....................   
....................     //  
....................     // Output power on default for I/O ports from EEPROM  
....................     //  
....................     i = read_eeprom(EEPROM_POD_PORT1);  
*
107E:  MOVLW  06
107F:  MOVWF  25
1080:  BCF    0A.4
1081:  BCF    03.5
1082:  CALL   78E
1083:  BSF    0A.4
1084:  MOVF   78,W
1085:  MOVWF  75
....................     write_port1(i);  
1086:  MOVF   75,W
1087:  BSF    03.5
1088:  MOVWF  22
1089:  BCF    0A.4
108A:  BSF    0A.3
108B:  BCF    03.5
108C:  CALL   387
108D:  BSF    0A.4
108E:  BCF    0A.3
....................     i = read_eeprom(EEPROM_POD_PORT2);  
108F:  MOVLW  07
1090:  BSF    03.5
1091:  MOVWF  25
1092:  BCF    0A.4
1093:  BCF    03.5
1094:  CALL   78E
1095:  BSF    0A.4
1096:  MOVF   78,W
1097:  MOVWF  75
....................     write_port2(i);  
1098:  MOVF   75,W
1099:  BSF    03.5
109A:  MOVWF  22
109B:  BCF    0A.4
109C:  BSF    0A.3
109D:  BCF    03.5
109E:  CALL   39C
109F:  BSF    0A.4
10A0:  BCF    0A.3
....................   
....................     //  
....................     // Output power on default for D/A converter  
....................     //  
....................     i = read_eeprom(EEPROM_POD_DA_MSB_CH0);  
10A1:  MOVLW  09
10A2:  BSF    03.5
10A3:  MOVWF  25
10A4:  BCF    0A.4
10A5:  BCF    03.5
10A6:  CALL   78E
10A7:  BSF    0A.4
10A8:  MOVF   78,W
10A9:  MOVWF  75
....................     temp = i;  
10AA:  BSF    03.5
10AB:  CLRF   21
10AC:  MOVF   75,W
10AD:  MOVWF  20
....................     temp = temp << 8;  
10AE:  MOVF   20,W
10AF:  MOVWF  21
10B0:  CLRF   20
....................     i = read_eeprom(EEPROM_POD_DA_LSB_CH0);  
10B1:  MOVLW  0A
10B2:  MOVWF  25
10B3:  BCF    0A.4
10B4:  BCF    03.5
10B5:  CALL   78E
10B6:  BSF    0A.4
10B7:  MOVF   78,W
10B8:  MOVWF  75
....................     temp = temp | i;  
10B9:  MOVF   75,W
10BA:  BSF    03.5
10BB:  IORWF  20,F
....................     DAC_CH0 = temp;  
10BC:  MOVF   21,W
10BD:  BCF    03.5
10BE:  MOVWF  39
10BF:  BSF    03.5
10C0:  MOVF   20,W
10C1:  BCF    03.5
10C2:  MOVWF  38
....................     i = read_eeprom(EEPROM_POD_DA_MSB_CH1);  
10C3:  MOVLW  0B
10C4:  BSF    03.5
10C5:  MOVWF  25
10C6:  BCF    0A.4
10C7:  BCF    03.5
10C8:  CALL   78E
10C9:  BSF    0A.4
10CA:  MOVF   78,W
10CB:  MOVWF  75
....................     temp = i;  
10CC:  BSF    03.5
10CD:  CLRF   21
10CE:  MOVF   75,W
10CF:  MOVWF  20
....................     temp = temp << 8;  
10D0:  MOVF   20,W
10D1:  MOVWF  21
10D2:  CLRF   20
....................     i = read_eeprom(EEPROM_POD_DA_LSB_CH1);  
10D3:  MOVLW  0C
10D4:  MOVWF  25
10D5:  BCF    0A.4
10D6:  BCF    03.5
10D7:  CALL   78E
10D8:  BSF    0A.4
10D9:  MOVF   78,W
10DA:  MOVWF  75
....................     temp = temp | i;  
10DB:  MOVF   75,W
10DC:  BSF    03.5
10DD:  IORWF  20,F
....................     DAC_CH1 = temp;  
10DE:  MOVF   21,W
10DF:  BCF    03.5
10E0:  MOVWF  3B
10E1:  BSF    03.5
10E2:  MOVF   20,W
10E3:  BCF    03.5
10E4:  MOVWF  3A
....................   
....................     update_dac();                       // Send the new values to the D/A converter  
10E5:  BCF    0A.4
10E6:  BSF    0A.3
10E7:  CALL   3A7
10E8:  BSF    0A.4
10E9:  BCF    0A.3
....................   
....................     //  
....................     // Clear the command buffer  
....................     //  
....................     for (i=0; i<8; i++) {  
10EA:  CLRF   75
10EB:  MOVF   75,W
10EC:  SUBLW  07
10ED:  BTFSS  03.0
10EE:  GOTO   0F5
....................         CommandBuffer[i] = 0;  
10EF:  MOVLW  40
10F0:  ADDWF  75,W
10F1:  MOVWF  04
10F2:  CLRF   00
....................     }  
10F3:  INCF   75,F
10F4:  GOTO   0EB
....................   
....................     //  
....................     // Get the version out of the USB chip  
....................     //  
....................     i = usbn_get_version();  
*
1103:  MOVF   78,W
1104:  MOVWF  75
....................   
....................     if (i != 0x02) {  // USBN9603 and USBN9604 rev = 0x02  
1105:  MOVF   75,W
1106:  SUBLW  02
1107:  BTFSC  03.2
1108:  GOTO   10D
....................         //  
....................         // This should reset the CPU  
....................         //  
....................         while (TRUE) {  
....................             led_on_red();  
1109:  BCF    0A.4
110A:  CALL   21A
110B:  BSF    0A.4
....................         }  
110C:  GOTO   109
....................     }  
....................   
....................     //  
....................     // Initialize the USB chip. Now ready to communicate  
....................     //  
....................     usb_init();  
....................   
....................     //  
....................     // Initialize the other interrupts.  
....................     // Note: enable_interrupts(global) is called in usb_init()  
....................     //  
....................     set_timer0(0);  
*
1236:  CLRF   01
....................     setup_timer_0(RTCC_EXT_H_TO_L | RTCC_DIV_1);  
1237:  BSF    03.5
1238:  MOVF   01,W
1239:  ANDLW  C0
123A:  IORLW  38
123B:  MOVWF  01
....................     enable_interrupts(int_timer0);              // Timer0 RTCC Pulse counter input  
123C:  BCF    03.5
123D:  BSF    0B.5
....................     setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);     // setup interrupts  
123E:  MOVLW  85
123F:  MOVWF  10
....................     enable_interrupts(int_timer1);              // Timer1 Periodic 1 ms. timer  
1240:  BSF    03.5
1241:  BSF    0C.0
....................     enable_interrupts(global);  
1242:  MOVLW  C0
1243:  BCF    03.5
1244:  IORWF  0B,F
....................   
.................... // Output a string to the RS-232 port  
.................... //   printf("\r\n\Running...ABCDEFGHIJKLMNOPQRSTUVWXYZ1\r\n");  
....................   
.................... //    CommandBuffer[0] = 0;  
....................   
....................     //  
....................     // Main Loop - never exits  
....................     //  
....................     while (TRUE)  
....................     {  
....................         //  
....................         // Wait for a character in the USB Command buffer  
....................         //  
....................         if (CommandBuffer[0] == 0) {  
1245:  MOVF   40,F
1246:  BTFSS  03.2
1247:  GOTO   380
....................             //  
....................             // Check stream mode  
....................             //  
....................             if (StreamFlag) {  
1248:  MOVF   33,F
1249:  BTFSC  03.2
124A:  GOTO   37F
....................                 //  
....................                 // Is TX FIFO2 empty?? 
....................                 //  
....................                 if (endpoint_stat[2].FIFO_status == EMPTY) {  
124B:  MOVF   6C,F
124C:  BTFSS  03.2
124D:  GOTO   37F
....................                     //  
....................                     // A/D data to TX FIFO2.  
....................                     // 24 samples = 3 sets of 8 samples  
....................                     //  
....................                     for (k=0; k<3; k++) {  
124E:  CLRF   7C
124F:  MOVF   7C,W
1250:  SUBLW  02
1251:  BTFSS  03.0
1252:  GOTO   2B7
....................                         for (j=0; j<8; j++) {  
1253:  CLRF   76
1254:  MOVF   76,W
1255:  SUBLW  07
1256:  BTFSS  03.0
1257:  GOTO   2B5
....................                             // turn off interrupts to grant exclusive SPI acess  
....................                             disable_interrupts(global);  
1258:  BCF    0B.6
1259:  BCF    0B.7
125A:  BTFSC  0B.7
125B:  GOTO   259
....................                             x = ADCNibble[j];  
125C:  MOVLW  2A
125D:  ADDWF  76,W
125E:  MOVWF  04
125F:  MOVF   00,W
1260:  MOVWF  7D
....................                             if (x & 0x80) {  
1261:  BTFSS  7D.7
1262:  GOTO   277
....................                                 // Unipolar A/D  
....................                                 x = x & 0x0F;  
1263:  MOVLW  0F
1264:  ANDWF  7D,F
....................                                 temp = acquire_adc(x, 1);  
1265:  MOVF   7D,W
1266:  BSF    03.5
1267:  MOVWF  22
1268:  MOVLW  01
1269:  MOVWF  23
126A:  BCF    0A.4
126B:  BSF    0A.3
126C:  BCF    03.5
126D:  CALL   41A
126E:  BSF    0A.4
126F:  BCF    0A.3
1270:  MOVF   79,W
1271:  BSF    03.5
1272:  MOVWF  21
1273:  MOVF   78,W
1274:  MOVWF  20
....................                             } else {  
1275:  GOTO   288
1276:  BCF    03.5
....................                                 // Bipolar A/D  
....................                                 x = x & 0x0F;  
1277:  MOVLW  0F
1278:  ANDWF  7D,F
....................                                 temp = acquire_adc(x, 0);  
1279:  MOVF   7D,W
127A:  BSF    03.5
127B:  MOVWF  22
127C:  CLRF   23
127D:  BCF    0A.4
127E:  BSF    0A.3
127F:  BCF    03.5
1280:  CALL   41A
1281:  BSF    0A.4
1282:  BCF    0A.3
1283:  MOVF   79,W
1284:  BSF    03.5
1285:  MOVWF  21
1286:  MOVF   78,W
1287:  MOVWF  20
....................                             }  
....................   
....................                             // Little endian order for Intel PC  
....................                             i = (temp & 0x00FF);  
1288:  MOVF   20,W
1289:  MOVWF  75
128A:  BCF    03.5
128B:  CLRF   28
128C:  BTFSC  0B.7
128D:  BSF    28.7
128E:  BCF    0B.7
....................                             usbn_write(TXD2, i);  
128F:  MOVLW  31
1290:  BSF    03.5
1291:  MOVWF  38
1292:  MOVF   75,W
1293:  MOVWF  39
1294:  BCF    0A.4
1295:  BCF    03.5
1296:  CALL   225
1297:  BSF    0A.4
1298:  BTFSC  28.7
1299:  BSF    0B.7
....................   
....................                             i = (temp & 0xFF00) >> 8;  
129A:  BSF    03.5
129B:  MOVF   20,W
129C:  ANDLW  00
129D:  MOVWF  22
129E:  MOVF   21,W
129F:  MOVWF  23
12A0:  MOVWF  75
12A1:  BCF    03.5
12A2:  CLRF   28
12A3:  BTFSC  0B.7
12A4:  BSF    28.7
12A5:  BCF    0B.7
....................                             usbn_write(TXD2, i);  
12A6:  MOVLW  31
12A7:  BSF    03.5
12A8:  MOVWF  38
12A9:  MOVF   75,W
12AA:  MOVWF  39
12AB:  BCF    0A.4
12AC:  BCF    03.5
12AD:  CALL   225
12AE:  BSF    0A.4
12AF:  BTFSC  28.7
12B0:  BSF    0B.7
....................   
....................                             // turn on interrupts  
....................                             enable_interrupts(global);  
12B1:  MOVLW  C0
12B2:  IORWF  0B,F
....................                         }  
12B3:  INCF   76,F
12B4:  GOTO   254
....................                     }  
12B5:  INCF   7C,F
12B6:  GOTO   24F
....................   
....................                     //  
....................                     // Digital port data tp TX FIFO2  
....................                     // Little endian order for Intel PC  
....................                     //  
....................                     i = read_port2();  
12B7:  BCF    0A.4
12B8:  BSF    0A.3
12B9:  CALL   48C
12BA:  BSF    0A.4
12BB:  BCF    0A.3
12BC:  MOVF   78,W
12BD:  MOVWF  75
12BE:  CLRF   28
12BF:  BTFSC  0B.7
12C0:  BSF    28.7
12C1:  BCF    0B.7
....................                     usbn_write(TXD2, i);  
12C2:  MOVLW  31
12C3:  BSF    03.5
12C4:  MOVWF  38
12C5:  MOVF   75,W
12C6:  MOVWF  39
12C7:  BCF    0A.4
12C8:  BCF    03.5
12C9:  CALL   225
12CA:  BSF    0A.4
12CB:  BTFSC  28.7
12CC:  BSF    0B.7
....................   
....................                     i = read_port1();  
12CD:  BCF    0A.4
12CE:  BSF    0A.3
12CF:  CALL   49B
12D0:  BSF    0A.4
12D1:  BCF    0A.3
12D2:  MOVF   78,W
12D3:  MOVWF  75
12D4:  CLRF   28
12D5:  BTFSC  0B.7
12D6:  BSF    28.7
12D7:  BCF    0B.7
....................                     usbn_write(TXD2, i);  
12D8:  MOVLW  31
12D9:  BSF    03.5
12DA:  MOVWF  38
12DB:  MOVF   75,W
12DC:  MOVWF  39
12DD:  BCF    0A.4
12DE:  BCF    03.5
12DF:  CALL   225
12E0:  BSF    0A.4
12E1:  BTFSC  28.7
12E2:  BSF    0B.7
....................   
....................                     //  
....................                     // Pulse Counter data to TX FIFO2  
....................                     // Little endian order for Intel PC  
....................                     //  
....................                     j = PulseCount & 0x000000FF;  
12E3:  MOVF   3C,W
12E4:  MOVWF  76
....................                     i = get_timer0();  
12E5:  MOVF   01,W
12E6:  MOVWF  75
....................                     i = i + j;  
12E7:  MOVF   76,W
12E8:  ADDWF  75,F
12E9:  CLRF   28
12EA:  BTFSC  0B.7
12EB:  BSF    28.7
12EC:  BCF    0B.7
....................                     usbn_write(TXD2, i);  
12ED:  MOVLW  31
12EE:  BSF    03.5
12EF:  MOVWF  38
12F0:  MOVF   75,W
12F1:  MOVWF  39
12F2:  BCF    0A.4
12F3:  BCF    03.5
12F4:  CALL   225
12F5:  BSF    0A.4
12F6:  BTFSC  28.7
12F7:  BSF    0B.7
....................   
....................                     i = ((PulseCount & 0x0000FF00) >> 8);  
12F8:  MOVF   3C,W
12F9:  ANDLW  00
12FA:  BSF    03.5
12FB:  MOVWF  22
12FC:  BCF    03.5
12FD:  MOVF   3D,W
12FE:  BSF    03.5
12FF:  MOVWF  23
1300:  BCF    03.5
1301:  MOVF   3E,W
1302:  ANDLW  00
1303:  BSF    03.5
1304:  MOVWF  24
1305:  BCF    03.5
1306:  MOVF   3F,W
1307:  ANDLW  00
1308:  BSF    03.5
1309:  MOVWF  25
130A:  MOVF   23,W
130B:  MOVWF  75
130C:  BCF    03.5
130D:  CLRF   28
130E:  BTFSC  0B.7
130F:  BSF    28.7
1310:  BCF    0B.7
....................                     usbn_write(TXD2, i);  
1311:  MOVLW  31
1312:  BSF    03.5
1313:  MOVWF  38
1314:  MOVF   75,W
1315:  MOVWF  39
1316:  BCF    0A.4
1317:  BCF    03.5
1318:  CALL   225
1319:  BSF    0A.4
131A:  BTFSC  28.7
131B:  BSF    0B.7
....................   
....................                     i = ((PulseCount & 0x00FF0000) >> 16);  
131C:  MOVF   3C,W
131D:  ANDLW  00
131E:  BSF    03.5
131F:  MOVWF  22
1320:  BCF    03.5
1321:  MOVF   3D,W
1322:  ANDLW  00
1323:  BSF    03.5
1324:  MOVWF  23
1325:  BCF    03.5
1326:  MOVF   3E,W
1327:  BSF    03.5
1328:  MOVWF  24
1329:  BCF    03.5
132A:  MOVF   3F,W
132B:  ANDLW  00
132C:  BSF    03.5
132D:  MOVWF  25
132E:  MOVF   24,W
132F:  MOVWF  75
1330:  BCF    03.5
1331:  CLRF   28
1332:  BTFSC  0B.7
1333:  BSF    28.7
1334:  BCF    0B.7
....................                     usbn_write(TXD2, i);  
1335:  MOVLW  31
1336:  BSF    03.5
1337:  MOVWF  38
1338:  MOVF   75,W
1339:  MOVWF  39
133A:  BCF    0A.4
133B:  BCF    03.5
133C:  CALL   225
133D:  BSF    0A.4
133E:  BTFSC  28.7
133F:  BSF    0B.7
....................   
....................                     i = ((PulseCount & 0xFF000000) >> 24);  
1340:  MOVF   3C,W
1341:  ANDLW  00
1342:  BSF    03.5
1343:  MOVWF  22
1344:  BCF    03.5
1345:  MOVF   3D,W
1346:  ANDLW  00
1347:  BSF    03.5
1348:  MOVWF  23
1349:  BCF    03.5
134A:  MOVF   3E,W
134B:  ANDLW  00
134C:  BSF    03.5
134D:  MOVWF  24
134E:  BCF    03.5
134F:  MOVF   3F,W
1350:  BSF    03.5
1351:  MOVWF  25
1352:  MOVWF  75
1353:  BCF    03.5
1354:  CLRF   28
1355:  BTFSC  0B.7
1356:  BSF    28.7
1357:  BCF    0B.7
....................                     usbn_write(TXD2, i);  
1358:  MOVLW  31
1359:  BSF    03.5
135A:  MOVWF  38
135B:  MOVF   75,W
135C:  MOVWF  39
135D:  BCF    0A.4
135E:  BCF    03.5
135F:  CALL   225
1360:  BSF    0A.4
1361:  BTFSC  28.7
1362:  BSF    0B.7
....................   
....................                     // Waiting for ACK state from PC Host  
....................                     endpoint_stat[2].FIFO_status = WAIT_FOR_ACK;  
1363:  MOVLW  02
1364:  MOVWF  6C
....................   
....................                     //  
....................                     // Enable TX for EP1 (TX FIFO2) - includes DATAPID  
....................                     i = endpoint_stat[2].toggle_bit << 2;  
1365:  RLF    6B,W
1366:  MOVWF  75
1367:  RLF    75,F
1368:  MOVLW  FC
1369:  ANDWF  75,F
....................                     usbn_write(TXC2, TX_EN | TX_LAST | i);  
136A:  MOVF   75,W
136B:  IORLW  03
136C:  BSF    03.5
136D:  MOVWF  22
136E:  BCF    03.5
136F:  CLRF   28
1370:  BTFSC  0B.7
1371:  BSF    28.7
1372:  BCF    0B.7
1373:  MOVLW  33
1374:  BSF    03.5
1375:  MOVWF  38
1376:  MOVF   22,W
1377:  MOVWF  39
1378:  BCF    0A.4
1379:  BCF    03.5
137A:  CALL   225
137B:  BSF    0A.4
137C:  BTFSC  28.7
137D:  BSF    0B.7
....................                     continue;  
137E:  GOTO   245
....................                 } // if (endpoint_stat[2].FIFO_status == EMPTY) {  
....................             } // if (StreamFlag) {  
....................               
....................             continue;  
137F:  GOTO   245
....................         } // if (CommandBuffer[0] == 0) {  
....................   
....................         // Flush TX FIFO1  
....................         usbn_write(TXC1, FLUSH);  
1380:  CLRF   28
1381:  BTFSC  0B.7
1382:  BSF    28.7
1383:  BCF    0B.7
1384:  MOVLW  2B
1385:  BSF    03.5
1386:  MOVWF  38
1387:  MOVLW  08
1388:  MOVWF  39
1389:  BCF    0A.4
138A:  BCF    03.5
138B:  CALL   225
138C:  BSF    0A.4
138D:  BTFSC  28.7
138E:  BSF    0B.7
....................   
....................         i = strlen(CommandBuffer);                  // Used to check correct command length  
138F:  MOVLW  40
1390:  BSF    03.5
1391:  MOVWF  22
1392:  BCF    0A.4
1393:  BSF    0A.3
1394:  BCF    03.5
1395:  CALL   4B5
1396:  BSF    0A.4
1397:  BCF    0A.3
1398:  MOVF   78,W
1399:  MOVWF  75
....................   
....................         switch (CommandBuffer[0]) {  
139A:  MOVF   40,W
139B:  MOVWF  77
139C:  MOVLW  56
139D:  SUBWF  77,W
139E:  BTFSC  03.2
139F:  GOTO   3D5
13A0:  MOVLW  49
13A1:  SUBWF  77,W
13A2:  BTFSC  03.2
13A3:  GOTO   3EF
13A4:  MOVLW  4F
13A5:  SUBWF  77,W
13A6:  BTFSC  03.2
13A7:  GOTO   41B
13A8:  MOVLW  54
13A9:  SUBWF  77,W
13AA:  BTFSC  03.2
13AB:  GOTO   45E
13AC:  MOVLW  47
13AD:  SUBWF  77,W
13AE:  BTFSC  03.2
13AF:  GOTO   4C9
13B0:  MOVLW  4E
13B1:  SUBWF  77,W
13B2:  BTFSC  03.2
13B3:  GOTO   4F5
13B4:  MOVLW  4D
13B5:  SUBWF  77,W
13B6:  BTFSC  03.2
13B7:  GOTO   567
13B8:  MOVLW  51
13B9:  SUBWF  77,W
13BA:  BTFSC  03.2
13BB:  GOTO   586
13BC:  MOVLW  55
13BD:  SUBWF  77,W
13BE:  BTFSC  03.2
13BF:  GOTO   5D0
13C0:  MOVLW  4C
13C1:  SUBWF  77,W
13C2:  BTFSC  03.2
13C3:  GOTO   61B
13C4:  MOVLW  57
13C5:  SUBWF  77,W
13C6:  BTFSC  03.2
13C7:  GOTO   67C
13C8:  MOVLW  52
13C9:  SUBWF  77,W
13CA:  BTFSC  03.2
13CB:  GOTO   6BB
13CC:  MOVLW  53
13CD:  SUBWF  77,W
13CE:  BTFSC  03.2
13CF:  GOTO   6F6
13D0:  MOVLW  48
13D1:  SUBWF  77,W
13D2:  BTFSC  03.2
13D3:  GOTO   712
13D4:  GOTO   72D
....................             case 'V':  
....................                 //  
....................                 // Version string  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
13D5:  DECFSZ 75,W
13D6:  GOTO   3D8
13D7:  GOTO   3D9
13D8:  GOTO   72D
....................                 strcpy(ResponseBuffer, "V14");  
13D9:  BSF    03.5
13DA:  CLRF   22
13DB:  CLRF   23
13DC:  MOVLW  48
13DD:  MOVWF  04
13DE:  MOVF   22,W
13DF:  ADDWF  04,F
13E0:  MOVF   23,W
13E1:  BCF    0A.4
13E2:  BCF    03.5
13E3:  CALL   17E
13E4:  BSF    0A.4
13E5:  MOVWF  00
13E6:  IORLW  00
13E7:  BTFSC  03.2
13E8:  GOTO   3EE
13E9:  BSF    03.5
13EA:  INCF   23,F
13EB:  INCF   22,F
13EC:  GOTO   3DC
13ED:  BCF    03.5
....................                 break;  
13EE:  GOTO   743
....................   
....................             case 'I':  
....................                 //  
....................                 // Input digital port  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
13EF:  DECFSZ 75,W
13F0:  GOTO   3F2
13F1:  GOTO   3F3
13F2:  GOTO   72D
....................                 ResponseBuffer[0] = 'I';  
13F3:  MOVLW  49
13F4:  MOVWF  48
....................                 i = read_port1();  
13F5:  BCF    0A.4
13F6:  BSF    0A.3
13F7:  CALL   49B
13F8:  BSF    0A.4
13F9:  BCF    0A.3
13FA:  MOVF   78,W
13FB:  MOVWF  75
....................                 bin_to_hex(i, &ResponseBuffer[1]);  
13FC:  MOVF   75,W
13FD:  BSF    03.5
13FE:  MOVWF  22
13FF:  MOVLW  49
1400:  MOVWF  23
1401:  BCF    0A.4
1402:  BSF    0A.3
1403:  BCF    03.5
1404:  CALL   4C4
1405:  BSF    0A.4
1406:  BCF    0A.3
....................                 j = read_port2();  
1407:  BCF    0A.4
1408:  BSF    0A.3
1409:  CALL   48C
140A:  BSF    0A.4
140B:  BCF    0A.3
140C:  MOVF   78,W
140D:  MOVWF  76
....................                 bin_to_hex(j, &ResponseBuffer[3]);  
140E:  MOVF   76,W
140F:  BSF    03.5
1410:  MOVWF  22
1411:  MOVLW  4B
1412:  MOVWF  23
1413:  BCF    0A.4
1414:  BSF    0A.3
1415:  BCF    03.5
1416:  CALL   4C4
1417:  BSF    0A.4
1418:  BCF    0A.3
....................                 ResponseBuffer[5] = 0;              // Null terminate  
1419:  CLRF   4D
....................                 break;  
141A:  GOTO   743
....................   
....................             case 'O':  
....................                 //  
....................                 // Output digital port  
....................                 //  
....................                 if (i != 5)                         // Check for correct command length  
....................                     goto error_rsp;  
141B:  MOVF   75,W
141C:  SUBLW  05
141D:  BTFSC  03.2
141E:  GOTO   420
141F:  GOTO   72D
....................                 i = hex_to_bin(&CommandBuffer[1]);  // PORT1  
1420:  MOVLW  41
1421:  BSF    03.5
1422:  MOVWF  22
1423:  BCF    0A.4
1424:  BSF    0A.3
1425:  BCF    03.5
1426:  CALL   4E7
1427:  BSF    0A.4
1428:  BCF    0A.3
1429:  MOVF   78,W
142A:  MOVWF  75
....................                 write_port1(i);  
142B:  MOVF   75,W
142C:  BSF    03.5
142D:  MOVWF  22
142E:  BCF    0A.4
142F:  BSF    0A.3
1430:  BCF    03.5
1431:  CALL   387
1432:  BSF    0A.4
1433:  BCF    0A.3
....................                 j = hex_to_bin(&CommandBuffer[3]);  // PORT2  
1434:  MOVLW  43
1435:  BSF    03.5
1436:  MOVWF  22
1437:  BCF    0A.4
1438:  BSF    0A.3
1439:  BCF    03.5
143A:  CALL   4E7
143B:  BSF    0A.4
143C:  BCF    0A.3
143D:  MOVF   78,W
143E:  MOVWF  76
....................                 write_port2(j);  
143F:  MOVF   76,W
1440:  BSF    03.5
1441:  MOVWF  22
1442:  BCF    0A.4
1443:  BSF    0A.3
1444:  BCF    03.5
1445:  CALL   39C
1446:  BSF    0A.4
1447:  BCF    0A.3
....................                 strcpy(ResponseBuffer, "O");  
1448:  BSF    03.5
1449:  CLRF   22
144A:  CLRF   23
144B:  MOVLW  48
144C:  MOVWF  04
144D:  MOVF   22,W
144E:  ADDWF  04,F
144F:  MOVF   23,W
1450:  BCF    0A.4
1451:  BCF    03.5
1452:  CALL   186
1453:  BSF    0A.4
1454:  MOVWF  00
1455:  IORLW  00
1456:  BTFSC  03.2
1457:  GOTO   45D
1458:  BSF    03.5
1459:  INCF   23,F
145A:  INCF   22,F
145B:  GOTO   44B
145C:  BCF    03.5
....................                 break;  
145D:  GOTO   743
....................   
....................             case 'T':  
....................                 //  
....................                 // Set digital port direction  
....................                 //  
....................                 if (i != 5)                         // Check for correct command length  
....................                     goto error_rsp;  
145E:  MOVF   75,W
145F:  SUBLW  05
1460:  BTFSC  03.2
1461:  GOTO   463
1462:  GOTO   72D
....................                 i = hex_to_bin(&CommandBuffer[1]);  // PORT1  
1463:  MOVLW  41
1464:  BSF    03.5
1465:  MOVWF  22
1466:  BCF    0A.4
1467:  BSF    0A.3
1468:  BCF    03.5
1469:  CALL   4E7
146A:  BSF    0A.4
146B:  BCF    0A.3
146C:  MOVF   78,W
146D:  MOVWF  75
....................                 set_dir_port1(i);  
146E:  MOVF   75,W
146F:  BSF    03.5
1470:  MOVWF  22
....................                 j = hex_to_bin(&CommandBuffer[3]);  // PORT2  
*
1494:  MOVLW  43
1495:  MOVWF  22
1496:  BCF    0A.4
1497:  BSF    0A.3
1498:  BCF    03.5
1499:  CALL   4E7
149A:  BSF    0A.4
149B:  BCF    0A.3
149C:  MOVF   78,W
149D:  MOVWF  76
....................                 set_dir_port2(j);  
149E:  MOVF   76,W
149F:  BSF    03.5
14A0:  MOVWF  22
....................                 strcpy(ResponseBuffer, "T");  
*
14B4:  CLRF   22
14B5:  CLRF   23
14B6:  MOVLW  48
14B7:  MOVWF  04
14B8:  MOVF   22,W
14B9:  ADDWF  04,F
14BA:  MOVF   23,W
14BB:  BCF    0A.4
14BC:  BCF    03.5
14BD:  CALL   18C
14BE:  BSF    0A.4
14BF:  MOVWF  00
14C0:  IORLW  00
14C1:  BTFSC  03.2
14C2:  GOTO   4C8
14C3:  BSF    03.5
14C4:  INCF   23,F
14C5:  INCF   22,F
14C6:  GOTO   4B6
14C7:  BCF    03.5
....................                 break;  
14C8:  GOTO   743
....................   
....................             case 'G':  
....................                 //  
....................                 // Get digital port direction  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
14C9:  DECFSZ 75,W
14CA:  GOTO   4CC
14CB:  GOTO   4CD
14CC:  GOTO   72D
....................                 ResponseBuffer[0] = 'G';  
14CD:  MOVLW  47
14CE:  MOVWF  48
....................                 i = get_dir_port1();  
14CF:  BCF    0A.4
14D0:  BSF    0A.3
14D1:  GOTO   51F
14D2:  BSF    0A.4
14D3:  BCF    0A.3
14D4:  MOVF   78,W
14D5:  MOVWF  75
....................                 bin_to_hex(i, &ResponseBuffer[1]);  
14D6:  MOVF   75,W
14D7:  BSF    03.5
14D8:  MOVWF  22
14D9:  MOVLW  49
14DA:  MOVWF  23
14DB:  BCF    0A.4
14DC:  BSF    0A.3
14DD:  BCF    03.5
14DE:  CALL   4C4
14DF:  BSF    0A.4
14E0:  BCF    0A.3
....................                 j = get_dir_port2();  
14E1:  BCF    0A.4
14E2:  BSF    0A.3
14E3:  GOTO   524
14E4:  BSF    0A.4
14E5:  BCF    0A.3
14E6:  MOVF   78,W
14E7:  MOVWF  76
....................                 bin_to_hex(j, &ResponseBuffer[3]);  
14E8:  MOVF   76,W
14E9:  BSF    03.5
14EA:  MOVWF  22
14EB:  MOVLW  4B
14EC:  MOVWF  23
14ED:  BCF    0A.4
14EE:  BSF    0A.3
14EF:  BCF    03.5
14F0:  CALL   4C4
14F1:  BSF    0A.4
14F2:  BCF    0A.3
....................                 ResponseBuffer[5] = 0;              // Null terminate  
14F3:  CLRF   4D
....................                 break;  
14F4:  GOTO   743
....................   
....................             case 'N':  
....................                 //  
....................                 // Get pulse counter  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
14F5:  DECFSZ 75,W
14F6:  GOTO   4F8
14F7:  GOTO   4F9
14F8:  GOTO   72D
....................                 ResponseBuffer[0] = 'N';  
14F9:  MOVLW  4E
14FA:  MOVWF  48
....................   
....................                 i = ((PulseCount & 0xFF000000) >> 24);  
14FB:  MOVF   3C,W
14FC:  ANDLW  00
14FD:  BSF    03.5
14FE:  MOVWF  22
14FF:  BCF    03.5
1500:  MOVF   3D,W
1501:  ANDLW  00
1502:  BSF    03.5
1503:  MOVWF  23
1504:  BCF    03.5
1505:  MOVF   3E,W
1506:  ANDLW  00
1507:  BSF    03.5
1508:  MOVWF  24
1509:  BCF    03.5
150A:  MOVF   3F,W
150B:  BSF    03.5
150C:  MOVWF  25
150D:  MOVWF  75
....................                 bin_to_hex(i, &ResponseBuffer[1]);  
150E:  MOVF   75,W
150F:  MOVWF  22
1510:  MOVLW  49
1511:  MOVWF  23
1512:  BCF    0A.4
1513:  BSF    0A.3
1514:  BCF    03.5
1515:  CALL   4C4
1516:  BSF    0A.4
1517:  BCF    0A.3
....................   
....................                 i = ((PulseCount & 0xFF0000) >> 16);  
1518:  MOVF   3C,W
1519:  ANDLW  00
151A:  BSF    03.5
151B:  MOVWF  22
151C:  BCF    03.5
151D:  MOVF   3D,W
151E:  ANDLW  00
151F:  BSF    03.5
1520:  MOVWF  23
1521:  BCF    03.5
1522:  MOVF   3E,W
1523:  BSF    03.5
1524:  MOVWF  24
1525:  BCF    03.5
1526:  MOVF   3F,W
1527:  ANDLW  00
1528:  BSF    03.5
1529:  MOVWF  25
152A:  MOVF   24,W
152B:  MOVWF  75
....................                 bin_to_hex(i, &ResponseBuffer[3]);  
152C:  MOVF   75,W
152D:  MOVWF  22
152E:  MOVLW  4B
152F:  MOVWF  23
1530:  BCF    0A.4
1531:  BSF    0A.3
1532:  BCF    03.5
1533:  CALL   4C4
1534:  BSF    0A.4
1535:  BCF    0A.3
....................   
....................                 i = ((PulseCount & 0xFF00) >> 8);  
1536:  MOVF   3C,W
1537:  ANDLW  00
1538:  BSF    03.5
1539:  MOVWF  22
153A:  BCF    03.5
153B:  MOVF   3D,W
153C:  BSF    03.5
153D:  MOVWF  23
153E:  BCF    03.5
153F:  MOVF   3E,W
1540:  ANDLW  00
1541:  BSF    03.5
1542:  MOVWF  24
1543:  BCF    03.5
1544:  MOVF   3F,W
1545:  ANDLW  00
1546:  BSF    03.5
1547:  MOVWF  25
1548:  MOVF   23,W
1549:  MOVWF  75
....................                 bin_to_hex(i, &ResponseBuffer[5]);  
154A:  MOVF   75,W
154B:  MOVWF  22
154C:  MOVLW  4D
154D:  MOVWF  23
154E:  BCF    0A.4
154F:  BSF    0A.3
1550:  BCF    03.5
1551:  CALL   4C4
1552:  BSF    0A.4
1553:  BCF    0A.3
....................   
....................                 j = PulseCount & 0xFF;  
1554:  MOVF   3C,W
1555:  MOVWF  76
....................                 i = get_timer0();  
1556:  MOVF   01,W
1557:  MOVWF  75
....................                 i = i + j;  
1558:  MOVF   76,W
1559:  ADDWF  75,F
....................                 bin_to_hex(i, &ResponseBuffer[7]);  
155A:  MOVF   75,W
155B:  BSF    03.5
155C:  MOVWF  22
155D:  MOVLW  4F
155E:  MOVWF  23
155F:  BCF    0A.4
1560:  BSF    0A.3
1561:  BCF    03.5
1562:  CALL   4C4
1563:  BSF    0A.4
1564:  BCF    0A.3
....................   
....................                 ResponseBuffer[9] = 0;              // Null terminate  
1565:  CLRF   51
....................                 break;  
1566:  GOTO   743
....................   
....................             case 'M':  
....................                 //  
....................                 // Clear pulse counter  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
1567:  DECFSZ 75,W
1568:  GOTO   56A
1569:  GOTO   56B
156A:  GOTO   72D
....................                 set_timer0(0);                      // Clear Timer0 and the count  
156B:  CLRF   01
....................                 PulseCount = 0;  
156C:  CLRF   3F
156D:  CLRF   3E
156E:  CLRF   3D
156F:  CLRF   3C
....................                 strcpy(ResponseBuffer, "M");  
1570:  BSF    03.5
1571:  CLRF   22
1572:  CLRF   23
1573:  MOVLW  48
1574:  MOVWF  04
1575:  MOVF   22,W
1576:  ADDWF  04,F
1577:  MOVF   23,W
1578:  BCF    0A.4
1579:  BCF    03.5
157A:  CALL   192
157B:  BSF    0A.4
157C:  MOVWF  00
157D:  IORLW  00
157E:  BTFSC  03.2
157F:  GOTO   585
1580:  BSF    03.5
1581:  INCF   23,F
1582:  INCF   22,F
1583:  GOTO   573
1584:  BCF    03.5
....................                 break;  
1585:  GOTO   743
....................   
....................             case 'Q':  
....................                 //  
....................                 // Bipolar A/D sample  
....................                 //  
....................                 if (i != 2)                         // Check for correct command length  
....................                     goto error_rsp;  
1586:  MOVF   75,W
1587:  SUBLW  02
1588:  BTFSC  03.2
1589:  GOTO   58B
158A:  GOTO   72D
....................                 CommandBuffer[0] = '0';             // Add leading 0 since hex_to_bin() converts two bytes  
158B:  MOVLW  30
158C:  MOVWF  40
....................                 i = hex_to_bin(&CommandBuffer[0]);  // Control nibble  
158D:  MOVLW  40
158E:  BSF    03.5
158F:  MOVWF  22
1590:  BCF    0A.4
1591:  BSF    0A.3
1592:  BCF    03.5
1593:  CALL   4E7
1594:  BSF    0A.4
1595:  BCF    0A.3
1596:  MOVF   78,W
1597:  MOVWF  75
....................                 temp = acquire_adc(i, 0);  
1598:  MOVF   75,W
1599:  BSF    03.5
159A:  MOVWF  22
159B:  CLRF   23
159C:  BCF    0A.4
159D:  BSF    0A.3
159E:  BCF    03.5
159F:  CALL   41A
15A0:  BSF    0A.4
15A1:  BCF    0A.3
15A2:  MOVF   79,W
15A3:  BSF    03.5
15A4:  MOVWF  21
15A5:  MOVF   78,W
15A6:  MOVWF  20
....................                 ResponseBuffer[0] = 'Q';  
15A7:  MOVLW  51
15A8:  BCF    03.5
15A9:  MOVWF  48
....................                 j = ((temp & 0xFF00) >> 8);  
15AA:  BSF    03.5
15AB:  MOVF   20,W
15AC:  ANDLW  00
15AD:  MOVWF  22
15AE:  MOVF   21,W
15AF:  MOVWF  23
15B0:  MOVWF  76
....................                 j = j | (i << 4);                   // Control nibble plus MSB byte of high 12 bits  
15B1:  SWAPF  75,W
15B2:  MOVWF  77
15B3:  MOVLW  F0
15B4:  ANDWF  77,F
15B5:  MOVF   77,W
15B6:  IORWF  76,F
....................                 bin_to_hex(j, &ResponseBuffer[1]);  
15B7:  MOVF   76,W
15B8:  MOVWF  22
15B9:  MOVLW  49
15BA:  MOVWF  23
15BB:  BCF    0A.4
15BC:  BSF    0A.3
15BD:  BCF    03.5
15BE:  CALL   4C4
15BF:  BSF    0A.4
15C0:  BCF    0A.3
....................                 j = (temp & 0x00FF);                // LSB of 12 bits  
15C1:  BSF    03.5
15C2:  MOVF   20,W
15C3:  MOVWF  76
....................                 bin_to_hex(j, &ResponseBuffer[3]);  
15C4:  MOVF   76,W
15C5:  MOVWF  22
15C6:  MOVLW  4B
15C7:  MOVWF  23
15C8:  BCF    0A.4
15C9:  BSF    0A.3
15CA:  BCF    03.5
15CB:  CALL   4C4
15CC:  BSF    0A.4
15CD:  BCF    0A.3
....................                 ResponseBuffer[5] = 0;              // Null terminate  
15CE:  CLRF   4D
....................                 break;  
15CF:  GOTO   743
....................   
....................             case 'U':  
....................                 //  
....................                 // Unipolar A/D sample  
....................                 //  
....................                 if (i != 2)                         // Check for correct command length  
....................                     goto error_rsp;  
15D0:  MOVF   75,W
15D1:  SUBLW  02
15D2:  BTFSC  03.2
15D3:  GOTO   5D5
15D4:  GOTO   72D
....................                 CommandBuffer[0] = '0';             // Add leading 0 since hex_to_bin() converts two bytes  
15D5:  MOVLW  30
15D6:  MOVWF  40
....................                 i = hex_to_bin(&CommandBuffer[0]);  // Control nibble  
15D7:  MOVLW  40
15D8:  BSF    03.5
15D9:  MOVWF  22
15DA:  BCF    0A.4
15DB:  BSF    0A.3
15DC:  BCF    03.5
15DD:  CALL   4E7
15DE:  BSF    0A.4
15DF:  BCF    0A.3
15E0:  MOVF   78,W
15E1:  MOVWF  75
....................                 temp = acquire_adc(i, 1);  
15E2:  MOVF   75,W
15E3:  BSF    03.5
15E4:  MOVWF  22
15E5:  MOVLW  01
15E6:  MOVWF  23
15E7:  BCF    0A.4
15E8:  BSF    0A.3
15E9:  BCF    03.5
15EA:  CALL   41A
15EB:  BSF    0A.4
15EC:  BCF    0A.3
15ED:  MOVF   79,W
15EE:  BSF    03.5
15EF:  MOVWF  21
15F0:  MOVF   78,W
15F1:  MOVWF  20
....................                 ResponseBuffer[0] = 'U';  
15F2:  MOVLW  55
15F3:  BCF    03.5
15F4:  MOVWF  48
....................                 j = ((temp & 0xFF00) >> 8);  
15F5:  BSF    03.5
15F6:  MOVF   20,W
15F7:  ANDLW  00
15F8:  MOVWF  22
15F9:  MOVF   21,W
15FA:  MOVWF  23
15FB:  MOVWF  76
....................                 j = j | (i << 4);                   // Control nibble plus MSB byte of high 12 bits  
15FC:  SWAPF  75,W
15FD:  MOVWF  77
15FE:  MOVLW  F0
15FF:  ANDWF  77,F
1600:  MOVF   77,W
1601:  IORWF  76,F
....................                 bin_to_hex(j, &ResponseBuffer[1]);  
1602:  MOVF   76,W
1603:  MOVWF  22
1604:  MOVLW  49
1605:  MOVWF  23
1606:  BCF    0A.4
1607:  BSF    0A.3
1608:  BCF    03.5
1609:  CALL   4C4
160A:  BSF    0A.4
160B:  BCF    0A.3
....................                 j = (temp & 0x00FF);                // LSB of 12 bits  
160C:  BSF    03.5
160D:  MOVF   20,W
160E:  MOVWF  76
....................                 bin_to_hex(j, &ResponseBuffer[3]);  
160F:  MOVF   76,W
1610:  MOVWF  22
1611:  MOVLW  4B
1612:  MOVWF  23
1613:  BCF    0A.4
1614:  BSF    0A.3
1615:  BCF    03.5
1616:  CALL   4C4
1617:  BSF    0A.4
1618:  BCF    0A.3
....................                 ResponseBuffer[5] = 0;              // Null terminate  
1619:  CLRF   4D
....................                 break;  
161A:  GOTO   743
....................   
....................             case 'L':  
....................                 //  
....................                 // Output D/A value  
....................                 //  
....................                 if (i != 5)                         // Check for correct command length  
....................                     goto error_rsp;  
161B:  MOVF   75,W
161C:  SUBLW  05
161D:  BTFSC  03.2
161E:  GOTO   620
161F:  GOTO   72D
....................                 CommandBuffer[0] = '0';             // Add leading 0 since hex_to_bin() converts two bytes  
1620:  MOVLW  30
1621:  MOVWF  40
....................                 i = hex_to_bin(&CommandBuffer[0]);  // Control nibble (channel number 0 or 1)  
1622:  MOVLW  40
1623:  BSF    03.5
1624:  MOVWF  22
1625:  BCF    0A.4
1626:  BSF    0A.3
1627:  BCF    03.5
1628:  CALL   4E7
1629:  BSF    0A.4
162A:  BCF    0A.3
162B:  MOVF   78,W
162C:  MOVWF  75
....................                 CommandBuffer[1] = '0';             // Zero the control nibble since hex_to_bin() converts two bytes  
162D:  MOVLW  30
162E:  MOVWF  41
....................                 j = hex_to_bin(&CommandBuffer[1]);  // MSB (nibble) of the D/A value  
162F:  MOVLW  41
1630:  BSF    03.5
1631:  MOVWF  22
1632:  BCF    0A.4
1633:  BSF    0A.3
1634:  BCF    03.5
1635:  CALL   4E7
1636:  BSF    0A.4
1637:  BCF    0A.3
1638:  MOVF   78,W
1639:  MOVWF  76
....................                 temp = j;  
163A:  BSF    03.5
163B:  CLRF   21
163C:  MOVF   76,W
163D:  MOVWF  20
....................                 temp = temp << 8;  
163E:  MOVF   20,W
163F:  MOVWF  21
1640:  CLRF   20
....................                 j = hex_to_bin(&CommandBuffer[3]);  // LSB (byte) of the D/A value  
1641:  MOVLW  43
1642:  MOVWF  22
1643:  BCF    0A.4
1644:  BSF    0A.3
1645:  BCF    03.5
1646:  CALL   4E7
1647:  BSF    0A.4
1648:  BCF    0A.3
1649:  MOVF   78,W
164A:  MOVWF  76
....................                 temp = temp | j;  
164B:  MOVF   76,W
164C:  BSF    03.5
164D:  IORWF  20,F
....................                 if (i == 0) {                       // Channel 0  
164E:  MOVF   75,F
164F:  BTFSS  03.2
1650:  GOTO   65A
....................                     DAC_CH0 = temp;  
1651:  MOVF   21,W
1652:  BCF    03.5
1653:  MOVWF  39
1654:  BSF    03.5
1655:  MOVF   20,W
1656:  BCF    03.5
1657:  MOVWF  38
....................                 } else {                            // Channel 1  
1658:  GOTO   661
1659:  BSF    03.5
....................                     DAC_CH1 = temp;  
165A:  MOVF   21,W
165B:  BCF    03.5
165C:  MOVWF  3B
165D:  BSF    03.5
165E:  MOVF   20,W
165F:  BCF    03.5
1660:  MOVWF  3A
....................                 }  
....................                 update_dac();                       // Send the new values to the D/A converter  
1661:  BCF    0A.4
1662:  BSF    0A.3
1663:  CALL   3A7
1664:  BSF    0A.4
1665:  BCF    0A.3
....................                 strcpy(ResponseBuffer, "L");  
1666:  BSF    03.5
1667:  CLRF   22
1668:  CLRF   23
1669:  MOVLW  48
166A:  MOVWF  04
166B:  MOVF   22,W
166C:  ADDWF  04,F
166D:  MOVF   23,W
166E:  BCF    0A.4
166F:  BCF    03.5
1670:  CALL   198
1671:  BSF    0A.4
1672:  MOVWF  00
1673:  IORLW  00
1674:  BTFSC  03.2
1675:  GOTO   67B
1676:  BSF    03.5
1677:  INCF   23,F
1678:  INCF   22,F
1679:  GOTO   669
167A:  BCF    03.5
....................                 break;  
167B:  GOTO   743
....................   
....................             case 'W':  
....................                 //  
....................                 // Write EEPROM  
....................                 //  
....................                 if (i != 5)                         // Check for correct command length  
....................                     goto error_rsp;  
167C:  MOVF   75,W
167D:  SUBLW  05
167E:  BTFSC  03.2
167F:  GOTO   681
1680:  GOTO   72D
....................                 i = hex_to_bin(&CommandBuffer[1]);  // EEPROM Address  
1681:  MOVLW  41
1682:  BSF    03.5
1683:  MOVWF  22
1684:  BCF    0A.4
1685:  BSF    0A.3
1686:  BCF    03.5
1687:  CALL   4E7
1688:  BSF    0A.4
1689:  BCF    0A.3
168A:  MOVF   78,W
168B:  MOVWF  75
....................                 j = hex_to_bin(&CommandBuffer[3]);  // EEPROM Value  
168C:  MOVLW  43
168D:  BSF    03.5
168E:  MOVWF  22
168F:  BCF    0A.4
1690:  BSF    0A.3
1691:  BCF    03.5
1692:  CALL   4E7
1693:  BSF    0A.4
1694:  BCF    0A.3
1695:  MOVF   78,W
1696:  MOVWF  76
....................                 write_eeprom(i, j);  
1697:  MOVF   75,W
1698:  BSF    03.5
1699:  MOVWF  24
169A:  MOVF   76,W
169B:  MOVWF  25
169C:  BCF    0A.4
169D:  BSF    0A.3
169E:  BCF    03.5
169F:  CALL   326
16A0:  BSF    0A.4
16A1:  BCF    0A.3
....................   
....................                 //  
....................                 // Get new EEPROM settings  
....................                 //  
....................                 update_eesettings();  
16A2:  BCF    0A.4
16A3:  CALL   7C4
16A4:  BSF    0A.4
....................   
....................                 strcpy(ResponseBuffer, "W");  
16A5:  BSF    03.5
16A6:  CLRF   22
16A7:  CLRF   23
16A8:  MOVLW  48
16A9:  MOVWF  04
16AA:  MOVF   22,W
16AB:  ADDWF  04,F
16AC:  MOVF   23,W
16AD:  BCF    0A.4
16AE:  BCF    03.5
16AF:  CALL   19E
16B0:  BSF    0A.4
16B1:  MOVWF  00
16B2:  IORLW  00
16B3:  BTFSC  03.2
16B4:  GOTO   6BA
16B5:  BSF    03.5
16B6:  INCF   23,F
16B7:  INCF   22,F
16B8:  GOTO   6A8
16B9:  BCF    03.5
....................                 break;  
16BA:  GOTO   743
....................   
....................             case 'R':  
....................                 //  
....................                 // Read EEPROM  
....................                 //  
....................                 if (i != 3)                         // Check for correct command length  
....................                     goto error_rsp;  
16BB:  MOVF   75,W
16BC:  SUBLW  03
16BD:  BTFSC  03.2
16BE:  GOTO   6C0
16BF:  GOTO   72D
....................                 i = hex_to_bin(&CommandBuffer[1]);  // EEPROM Address  
16C0:  MOVLW  41
16C1:  BSF    03.5
16C2:  MOVWF  22
16C3:  BCF    0A.4
16C4:  BSF    0A.3
16C5:  BCF    03.5
16C6:  CALL   4E7
16C7:  BSF    0A.4
16C8:  BCF    0A.3
16C9:  MOVF   78,W
16CA:  MOVWF  75
....................                 j = read_eeprom(i);  
16CB:  MOVF   75,W
16CC:  BSF    03.5
16CD:  MOVWF  25
16CE:  BCF    0A.4
16CF:  BCF    03.5
16D0:  CALL   78E
16D1:  BSF    0A.4
16D2:  MOVF   78,W
16D3:  MOVWF  76
....................                 strcpy(ResponseBuffer, "R");  
16D4:  BSF    03.5
16D5:  CLRF   22
16D6:  CLRF   23
16D7:  MOVLW  48
16D8:  MOVWF  04
16D9:  MOVF   22,W
16DA:  ADDWF  04,F
16DB:  MOVF   23,W
16DC:  BCF    0A.4
16DD:  BCF    03.5
16DE:  CALL   1A4
16DF:  BSF    0A.4
16E0:  MOVWF  00
16E1:  IORLW  00
16E2:  BTFSC  03.2
16E3:  GOTO   6E9
16E4:  BSF    03.5
16E5:  INCF   23,F
16E6:  INCF   22,F
16E7:  GOTO   6D7
16E8:  BCF    03.5
....................                 bin_to_hex(j, &ResponseBuffer[1]);  
16E9:  MOVF   76,W
16EA:  BSF    03.5
16EB:  MOVWF  22
16EC:  MOVLW  49
16ED:  MOVWF  23
16EE:  BCF    0A.4
16EF:  BSF    0A.3
16F0:  BCF    03.5
16F1:  CALL   4C4
16F2:  BSF    0A.4
16F3:  BCF    0A.3
....................                 ResponseBuffer[3] = 0;              // Null terminate  
16F4:  CLRF   4B
....................                 break;  
16F5:  GOTO   743
....................   
....................             case 'S':  
....................                 //  
....................                 // Start stream mode  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
16F6:  DECFSZ 75,W
16F7:  GOTO   6F9
16F8:  GOTO   6FA
16F9:  GOTO   72D
....................                 StreamFlag = 1;  
16FA:  MOVLW  01
16FB:  MOVWF  33
....................                 strcpy(ResponseBuffer, "S");  
16FC:  BSF    03.5
16FD:  CLRF   22
16FE:  CLRF   23
16FF:  MOVLW  48
1700:  MOVWF  04
1701:  MOVF   22,W
1702:  ADDWF  04,F
1703:  MOVF   23,W
1704:  BCF    0A.4
1705:  BCF    03.5
1706:  CALL   1AA
1707:  BSF    0A.4
1708:  MOVWF  00
1709:  IORLW  00
170A:  BTFSC  03.2
170B:  GOTO   711
170C:  BSF    03.5
170D:  INCF   23,F
170E:  INCF   22,F
170F:  GOTO   6FF
1710:  BCF    03.5
....................                 break;  
1711:  GOTO   743
....................   
....................             case 'H':  
....................                 //  
....................                 // Halt stream mode  
....................                 //  
....................                 if (i != 1)                         // Check for correct command length  
....................                     goto error_rsp;  
1712:  DECFSZ 75,W
1713:  GOTO   715
1714:  GOTO   716
1715:  GOTO   72D
....................                 StreamFlag = 0;  
1716:  CLRF   33
....................                 strcpy(ResponseBuffer, "H");  
1717:  BSF    03.5
1718:  CLRF   22
1719:  CLRF   23
171A:  MOVLW  48
171B:  MOVWF  04
171C:  MOVF   22,W
171D:  ADDWF  04,F
171E:  MOVF   23,W
171F:  BCF    0A.4
1720:  BCF    03.5
1721:  CALL   1B0
1722:  BSF    0A.4
1723:  MOVWF  00
1724:  IORLW  00
1725:  BTFSC  03.2
1726:  GOTO   72C
1727:  BSF    03.5
1728:  INCF   23,F
1729:  INCF   22,F
172A:  GOTO   71A
172B:  BCF    03.5
....................                 break;  
172C:  GOTO   743
....................   
....................             default:  
....................                 //  
....................                 // Unknown command  
....................                 //  
.................... error_rsp:      // ERROR response  
....................                 strcpy(ResponseBuffer, "X");  
172D:  BSF    03.5
172E:  CLRF   22
172F:  CLRF   23
1730:  MOVLW  48
1731:  MOVWF  04
1732:  MOVF   22,W
1733:  ADDWF  04,F
1734:  MOVF   23,W
1735:  BCF    0A.4
1736:  BCF    03.5
1737:  CALL   1B6
1738:  BSF    0A.4
1739:  MOVWF  00
173A:  IORLW  00
173B:  BTFSC  03.2
173C:  GOTO   742
173D:  BSF    03.5
173E:  INCF   23,F
173F:  INCF   22,F
1740:  GOTO   730
1741:  BCF    03.5
....................                 break;  
1742:  GOTO   743
....................   
....................         } // switch (CommandChar)  
....................   
....................         //  
....................         // Clear the command buffer for next receive  
....................         //  
....................         for (i=0; i<8; i++) {  
1743:  CLRF   75
1744:  MOVF   75,W
1745:  SUBLW  07
1746:  BTFSS  03.0
1747:  GOTO   74E
....................             CommandBuffer[i] = 0;  
1748:  MOVLW  40
1749:  ADDWF  75,W
174A:  MOVWF  04
174B:  CLRF   00
....................         }  
174C:  INCF   75,F
174D:  GOTO   744
....................   
....................         //  
....................         // Write string to the TX FIFO1  
....................         //  
....................         j = strlen(ResponseBuffer);  
174E:  MOVLW  48
174F:  BSF    03.5
1750:  MOVWF  22
1751:  BCF    0A.4
1752:  BSF    0A.3
1753:  BCF    03.5
1754:  CALL   4B5
1755:  BSF    0A.4
1756:  BCF    0A.3
1757:  MOVF   78,W
1758:  MOVWF  76
....................         for (i=0; i<j; i++) {  
1759:  CLRF   75
175A:  MOVF   76,W
175B:  SUBWF  75,W
175C:  BTFSC  03.0
175D:  GOTO   776
....................             usbn_write(TXD1, ResponseBuffer[i]);  
175E:  MOVLW  48
175F:  ADDWF  75,W
1760:  MOVWF  04
1761:  MOVF   00,W
1762:  BSF    03.5
1763:  MOVWF  22
1764:  BCF    03.5
1765:  CLRF   28
1766:  BTFSC  0B.7
1767:  BSF    28.7
1768:  BCF    0B.7
1769:  MOVLW  29
176A:  BSF    03.5
176B:  MOVWF  38
176C:  MOVF   22,W
176D:  MOVWF  39
176E:  BCF    0A.4
176F:  BCF    03.5
1770:  CALL   225
1771:  BSF    0A.4
1772:  BTFSC  28.7
1773:  BSF    0B.7
....................         }  
1774:  INCF   75,F
1775:  GOTO   75A
....................   
....................         // Enable TX for EP1 (TX FIFO1) - includes DATAPID  
....................         i = endpoint_stat[1].toggle_bit << 2;  
1776:  RLF    69,W
1777:  MOVWF  75
1778:  RLF    75,F
1779:  MOVLW  FC
177A:  ANDWF  75,F
....................         usbn_write(TXC1, TX_EN | TX_LAST | i);  
177B:  MOVF   75,W
177C:  IORLW  03
177D:  BSF    03.5
177E:  MOVWF  22
177F:  BCF    03.5
1780:  CLRF   28
1781:  BTFSC  0B.7
1782:  BSF    28.7
1783:  BCF    0B.7
1784:  MOVLW  2B
1785:  BSF    03.5
1786:  MOVWF  38
1787:  MOVF   22,W
1788:  MOVWF  39
1789:  BCF    0A.4
178A:  BCF    03.5
178B:  CALL   225
178C:  BSF    0A.4
178D:  BTFSC  28.7
178E:  BSF    0B.7
178F:  CLRF   28
1790:  BTFSC  0B.7
1791:  BSF    28.7
1792:  BCF    0B.7
....................   
....................         // Re-enable RX  
....................         usbn_write(RXC1,FLUSH);     // Flush  RX1  
1793:  MOVLW  2F
1794:  BSF    03.5
1795:  MOVWF  38
1796:  MOVLW  08
1797:  MOVWF  39
1798:  BCF    0A.4
1799:  BCF    03.5
179A:  CALL   225
179B:  BSF    0A.4
179C:  BTFSC  28.7
179D:  BSF    0B.7
179E:  CLRF   28
179F:  BTFSC  0B.7
17A0:  BSF    28.7
17A1:  BCF    0B.7
....................         usbn_write(RXC1,RX_EN);     // Enable command receive (EP2)  
17A2:  MOVLW  2F
17A3:  BSF    03.5
17A4:  MOVWF  38
17A5:  MOVLW  01
17A6:  MOVWF  39
17A7:  BCF    0A.4
17A8:  BCF    03.5
17A9:  CALL   225
17AA:  BSF    0A.4
17AB:  BTFSC  28.7
17AC:  BSF    0B.7
....................     }  
17AD:  GOTO   245
.................... }  
....................  
17AE:  SLEEP

Configuration Fuses:
   Word  1: 00C2   HS NOWDT PUT PROTECT BROWNOUT
