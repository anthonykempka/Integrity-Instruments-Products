CCS PCH C Compiler, Version 4.068, 38756               24-Feb-08 21:19

               Filename: C:\Data\PicCode\USBM400 FW\usbm400.lst

               ROM used: 7914 bytes (24%)
                         Largest free fragment is 24854
               RAM used: 204 (10%) at main() level
                         224 (11%) worst case
               Stack:    9 worst case (3 in main + 6 for interrupts)

*
0000:  GOTO   16F8
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   106E
0058:  BTFSS  F9D.0
005A:  GOTO   0064
005E:  BTFSC  F9E.0
0060:  GOTO   1084
0064:  BTFSS  FF2.4
0066:  GOTO   0070
006A:  BTFSC  FF2.1
006C:  GOTO   0FF2
0070:  MOVFF  0F,00
0074:  MOVFF  10,01
0078:  MOVFF  11,02
007C:  MOVFF  12,03
0080:  MOVFF  13,04
0084:  BSF    0E.7
0086:  MOVFF  0D,FE9
008A:  MOVFF  08,FEA
008E:  MOVFF  09,FE1
0092:  MOVFF  0A,FE2
0096:  MOVFF  0B,FD9
009A:  MOVFF  0C,FDA
009E:  MOVFF  14,FF3
00A2:  MOVFF  15,FF4
00A6:  MOVFF  16,FFA
00AA:  MOVF   05,W
00AC:  MOVFF  07,FE0
00B0:  MOVFF  06,FD8
00B4:  RETFIE 0
.................... //***************************************************************************** 
.................... // 
.................... // USBM400 Firmware 
.................... // 
.................... // Target: PIC18F6520 
.................... // 
.................... // Comments: 
.................... // ---------- 
.................... // Based on the original USBM400 firmware 
.................... // 
....................  
.................... #include <18f6520.h> 
.................... //////// Standard Header file for the PIC18F6520 device //////////////// 
.................... #device PIC18F6520 
.................... #list 
....................  
....................  
.................... // Define for ICD debugging 
.................... // #device ICD=TRUE 
....................  
.................... // Establish the clock 
.................... #use delay(clock=40000000) 
*
0DFA:  CLRF   FEA
0DFC:  MOVLW  D4
0DFE:  MOVWF  FE9
0E00:  MOVF   FEF,W
0E02:  BZ    0E20
0E04:  MOVLW  0C
0E06:  MOVWF  01
0E08:  CLRF   00
0E0A:  DECFSZ 00,F
0E0C:  BRA    0E0A
0E0E:  DECFSZ 01,F
0E10:  BRA    0E08
0E12:  MOVLW  F7
0E14:  MOVWF  00
0E16:  DECFSZ 00,F
0E18:  BRA    0E16
0E1A:  BRA    0E1C
0E1C:  DECFSZ FEF,F
0E1E:  BRA    0E04
0E20:  RETLW  00
....................  
.................... // BUGBUG Change these fuses in release! 
.................... // --> Set for debug 
.................... // #fuses H4, NOWDT, NOCPB, NOCPD, NOLVP, BROWNOUT, BORV42, PUT, DEBUG 
.................... // --> Set for release 
.................... #fuses H4, NOWDT, NOCPB, NOCPD, NOLVP, BROWNOUT, BORV42, PUT 
....................  
....................  
.................... // Turn off the compiler's caching (virtual port) auto data direction crap 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E)  
.................... #use fast_io(F) 
.................... #use fast_io(G) 
....................  
.................... // Memory (port) defines so we can use ports directly in 'C' 
.................... // e.g.   PORT_B = value; 
.................... #byte PORT_A=0xF80 
.................... #byte PORT_B=0xF81 
.................... #byte PORT_C=0xF82 
.................... #byte PORT_D=0xF83 
.................... #byte PORT_E=0xF84 
.................... #byte PORT_F=0xF85 
.................... #byte PORT_G=0xF86 
.................... #byte SSPSTAT=0xFC7 
.................... #byte SSPCON1=0xFC6 
.................... #byte SSPCON2=0xFC5 
.................... #byte EEADRH=0xFAA 
.................... #byte EEADR=0xFA9 
.................... #byte EEDATA=0xFA8 
.................... #byte EECON1=0xFA6 
.................... #byte EECON2=0xFA7 
.................... #byte INTCON=0xFF2 
....................  
....................  
.................... // EEPROM Locations 
.................... #define EEPROM_MOD_ADDRESS      0x00 
.................... #define EEPROM_DIR_PORT1        0x02 
.................... #define EEPROM_DIR_PORT2        0x03 
.................... #define EEPROM_POD_PORT1        0x06 
.................... #define EEPROM_POD_PORT2        0x07 
.................... #define EEPROM_EXPANDER_FLAG    0x08 
.................... #define EEPROM_POD_DA_MSB_CH0   0x09 
.................... #define EEPROM_POD_DA_LSB_CH0   0x0A 
.................... #define EEPROM_POD_DA_MSB_CH1   0x0B 
.................... #define EEPROM_POD_DA_LSB_CH1   0x0C 
.................... #define EEPROM_AD_SAMPLE_CLK    0x0D 
....................  
.................... #define EEPROM_AD_CONFIG        0x11 
.................... #define EEPROM_AD_CONFIG_END    0x21 
....................  
.................... // Locations contain ASCII serial number, which will be converted to 
.................... // UNICODE when it is read in update_eesettings() 
.................... #define EEPROM_SN_START         0x30 
.................... #define EEPROM_SN_END           0x38 
....................  
.................... // Chip select and control lines 
.................... #define AD_CS           PIN_A0 
.................... #define DAC_CS          PIN_A1 
.................... #define USB_CS          PIN_A2 
.................... #define USB_RD          PIN_B2 
.................... #define USB_WR          PIN_B3 
.................... #define USB_A0          PIN_B4 
.................... #define USB_RESET       PIN_C1 
....................  
.................... // LED defines 
.................... #define LED_RED         PIN_G3 
.................... #define LED_GREEN       PIN_G4 
....................  
.................... // Current SPI mode defines 
.................... #define SPI_NOT_SET     0 
.................... #define SPI_ADC_FAST    2 
.................... #define SPI_DAC         2 
.................... #define SPI_ADC_SLOW    3 
....................  
....................  
.................... // Global variable declarations 
.................... #define EXPANDER_FLAG   1 
....................  
.................... int8    EEFlags = 0;            // EXPANDER)FLAG (invert digital), ... 
....................  
.................... int8    Adc_Control[16];        // EEPROM locations 0x11 to 0x20 
....................  
.................... int8    SpiMode = SPI_NOT_SET;  // Guarantees that setup_spi_mode() will be called the first time. 
....................  
.................... int8    StreamFlag = 0;          // Initially not streaming 
.................... int8    bWaitingTxFifoEmpty = 0; // Initially not waiting for USB TX FIFO 2 empty 
....................  
.................... int8    LedGreenFlag = 1;       // Controls the LED operation 
.................... int8    LedCount = 0; 
....................  
.................... int8    Port1_Dir = 0;          // Digital port direction (shadow) 
.................... int8    Port2_Dir = 0; 
.................... int16   DAC_CH0 = 0;            // DAC output (shadow) 
.................... int16   DAC_CH1 = 0; 
....................  
.................... int32   PulseCount = 0;         // Count the incoming pulses 
....................  
.................... int16   ADC_Buffer[32];         // A/D buffer for Streaming mode 
....................  
.................... char    CommandBuffer[8];       // Command and response buffers 
.................... char    ResponseBuffer[10]; 
....................  
.................... // Constant table definitions 
.................... const int8 BIN_TO_HEX_TBL[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; 
....................  
.................... // Forward function declarations 
.................... #separate 
.................... void trigger_led_red(void); 
.................... void led_on_green(void); 
....................  
.................... // Additional includes 
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
159E:  MOVFF  C8,CA
15A2:  MOVFF  C7,C9
15A6:  MOVFF  CA,03
15AA:  MOVFF  C9,FE9
15AE:  MOVFF  CA,FEA
15B2:  MOVF   FEF,F
15B4:  BZ    15BE
15B6:  INCF   xC9,F
15B8:  BTFSC  FD8.2
15BA:  INCF   xCA,F
15BC:  BRA    15A6
....................    return(sc - s); 
15BE:  MOVF   xC7,W
15C0:  SUBWF  xC9,W
15C2:  MOVWF  00
15C4:  MOVF   xC8,W
15C6:  SUBWFB xCA,W
15C8:  MOVWF  03
15CA:  MOVFF  00,01
15CE:  MOVWF  02
.................... } 
15D0:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... //----------------------------------------------------------------------------- 
.................... // setup_spi_fast() 
.................... // 
.................... // Used to configure the PIC SPI correctly since the built-in 
.................... // CCS routines are broken. CLK = Fosc / 16 = 2.5 Mhz 
.................... // 
.................... void setup_spi_fast(void) 
.................... { 
.................... //    SSPCON1 = 0x21;     // SSPCON1: SPEN=1, CKP=0 (idle high), Fosc/16 
....................     SSPCON1 = 0x20;     // SSPCON1: SPEN=1, CKP=0 (idle high), Fosc/4 
*
1234:  MOVLW  20
1236:  MOVWF  FC6
....................     SSPSTAT = 0xC0;     // SSPSTAT: SMP=1 (input sample at end of data output time) 
1238:  MOVLW  C0
123A:  MOVWF  FC7
....................                         //          CKE=1 (CKP=1 data transmitted on falling edge of SCK) 
....................     return; 
.................... } 
123C:  GOTO   1254 (RETURN)
....................  
....................  
.................... //----------------------------------------------------------------------------- 
.................... // setup_spi_clk64() 
.................... // 
.................... // Used to configure the PIC SPI correctly since the built-in 
.................... // CCS routines are broken. CLK = Fosc / 64 = 625 Khz 
.................... // 
.................... void setup_spi_clk64(void) 
.................... { 
....................     SSPCON1 = 0x22;     // SSPCON1: SPEN=1, CKP=0 (idle high), Fosc/64 
1240:  MOVLW  22
1242:  MOVWF  FC6
....................     SSPSTAT = 0xC0;     // SSPSTAT: SMP=1 (input sample at end of data output time) 
1244:  MOVLW  C0
1246:  MOVWF  FC7
....................                         //          CKE=1 (CKP=1 data transmitted on falling edge of SCK) 
....................     return; 
.................... } 
1248:  GOTO   125C (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... // setup_spi_mode() 
.................... // 
.................... // Used to setup the speed of the SPI clock depending on usage 
.................... // 
.................... void setup_spi_mode(int8 mode) 
.................... { 
....................     // SPI_ADC_FAST, SPI_DAC 
....................     if (mode == SPI_ADC_FAST) { 
124C:  MOVF   xCD,W
124E:  SUBLW  02
1250:  BNZ   125A
....................         setup_spi_fast(); 
1252:  BRA    1234
....................         SpiMode = SPI_ADC_FAST; 
1254:  MOVLW  02
1256:  MOVWF  2A
....................         return; 
1258:  BRA    1260
....................     } 
....................  
....................     // SPI_DAC 
....................     setup_spi_clk64(); 
125A:  BRA    1240
....................     SpiMode = SPI_ADC_SLOW; 
125C:  MOVLW  03
125E:  MOVWF  2A
....................     return; 
.................... } 
1260:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Include the USB code. Note that the USBN9603 uses the SPI port 
.................... #include <usbn9603.c> 
.................... //***************************************************************************** 
.................... // 
.................... // USBN9603 USB Controller firmware 
.................... // 
.................... // Target: Designed for USBM400 board 
.................... // 
.................... // Comments: 
.................... // ---------- 
.................... // Based on the original USBM300 firmware 
.................... // 
.................... // 
....................  
.................... // 
.................... // USB Device desriptor defines 
.................... // 
.................... #ifndef __USB_DESCRIPTORS__ 
....................    #include "USBM400_desc.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //  USBM300_DESC.H 
.................... // 
.................... //  USB descriptors for the Integrity Instruments, Inc. 
.................... //  Model: USBM400 I/O Module 
.................... // 
.................... //  Revision History 
.................... //  -------------------- 
.................... //  2-9-2008  (Anthony Kempka) 
.................... //  * Removed all compiler warnings (mostly void declarations and unused variables) 
.................... //  * Added Serial Number (S/N) support where S/N is located in EEPROM 
.................... // 
....................  
.................... #define __USB_DESCRIPTORS__ 
....................  
.................... // 
.................... // Note: Endpoint 0 doesnt count here since all devices have an EP0 for control 
.................... // 
.................... #define USB_NUM_ENDPOINTS      4 
....................  
....................  
.................... #define USB_NUM_CLASSES        0 
....................  
.................... // 
.................... // Standard USB request codes 
.................... // 
.................... #define GET_STATUS          0 
.................... #define CLEAR_FEATURE       1 
.................... #define SET_FEATURE         3 
.................... #define SET_ADDRESS         5 
.................... #define GET_DESCRIPTOR      6 
.................... #define SET_DESCRIPTOR      7 
.................... #define GET_CONFIGURATION   8 
.................... #define SET_CONFIGURATION   9 
.................... #define GET_INTERFACE       10 
.................... #define SET_INTERFACE       11 
.................... #define SYNCH_FRAME         12 
....................  
.................... // 
.................... // Descriptor types 
.................... // 
.................... #define USB_DEVICE_DESC_KEY      0x01 
.................... #define USB_CONFIG_DESC_KEY      0x02 
.................... #define USB_STRING_DESC_KEY      0x03 
.................... #define USB_INTERFACE_DESC_KEY   0x04 
.................... #define USB_ENDPOINT_DESC_KEY    0x05 
....................  
....................  
.................... #define USB_MAX_EP0_PACKET_LENGTH   8 
....................  
.................... // 
.................... // Descriptor lengths. Specific to our configuration 
.................... // 
.................... #define USB_DEVICE_DESC_LEN         18 
.................... #define USB_CONFIG_DESC_LEN         9 
.................... #define USB_CONFIG_DESC_TOTAL_LEN   46 
.................... #define USB_INTERFACE_DESC_LEN      9 
.................... #define USB_ENDPOINT_DESC_LEN       7 
....................  
.................... // NOTE: AAK added 2-9-2008 
.................... #define STR_INDX_NONE       0x00    // Unused string index (no string) 
.................... #define STR_INDX_LANG       0x00    // Language identifier 
.................... #define STR_INDX_MFG        0x01    // Manufacturer string index 
.................... #define STR_INDX_PROD       0x02    // Product string index 
.................... #define STR_INDX_SN         0x03    // Serial number string index 
....................  
.................... // 
.................... // Device descriptor 
.................... // 
.................... const int8 USB_DEVICE_DESC[USB_DEVICE_DESC_LEN] = { 
....................     USB_DEVICE_DESC_LEN,        // the length of this report 
....................     USB_DEVICE_DESC_KEY,        // constant DEVICE (0x01) 
....................     0x10,0x01,                  // usb version in bcd 
....................     0x00,                       // class code (if 0, then interface defines class.  FF is vendor defined) 
....................     0x00,                       // subclass code 
....................     0x00,                       // protocol code 
....................     8,                          // max packet size for endpoint 0 
....................     0xEF,0x10,                  // VID = 0x10EF   Integrity Instruments, Inc. 
....................     0x00,0x04,                  // PID = 0x0400  (USB400M) 
....................     0x00,0x01,                  // device release number  1.0 
....................     STR_INDX_MFG,               // (String) index of string description of manufacturer. therefore we point to string_1 array (see below) 
....................     STR_INDX_PROD,              // (String) index of string descriptor of the product 
....................     STR_INDX_SN,                // (String) index of string descriptor of serial number 
....................     1                           // number of possible configurations (only one) 
.................... }; 
....................  
.................... // 
.................... // Configuration descriptor 
.................... // 
.................... int8 const USB_CONFIG_DESC[USB_CONFIG_DESC_TOTAL_LEN] = { 
....................     // Config_descriptor for config index 1 
....................     USB_CONFIG_DESC_LEN,        // length of descriptor size 
....................     USB_CONFIG_DESC_KEY,        // constant CONFIGURATION (0x02) 
....................     USB_CONFIG_DESC_TOTAL_LEN,0,// size of all data returned for this config 
....................     0x01,                       // number of interfaces this device supports 
....................     0x01,                       // identifier for this configuration.  (IF we had more than one configurations) 
....................     STR_INDX_NONE,              // (String) index of string descriptor for this configuration 
....................     0x40,                       // bit 7=0 (reserved USB 1.0), bit 6=1 self powered, bit 5=1 remote wakeup , bits 0-4 reserved 
....................     0x00,                       // bus power required (maximum milliamperes/2)  (0x32 = 100mA) 
....................  
....................     // Interface descriptor 0 alt 0 
....................     USB_INTERFACE_DESC_LEN,     // length of descriptor 
....................     USB_INTERFACE_DESC_KEY,     // constant INTERFACE (0x04) 
....................     0x00,                       // number defining this interface (IF we had more than one interface) 
....................     0x00,                       // alternate setting 
....................     USB_NUM_ENDPOINTS,          // number of endpoints, except 0. 
....................     0xFF,                       // class code, FF = vendor defined 
....................     0x00,                       // subclass code 
....................     0x00,                       // protocol code 
....................     STR_INDX_NONE,              // (String) index of string descriptor for interface 
....................  
....................     // Endpoint descriptor EP1 - IN (to the Host) 
....................     // WDM = "PIPE0"  response (to command) 
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor 
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05) 
....................     0x81,                       // endpoint number and direction (0x81 = EPC1 IN) 
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................     0x40,0x00,                  // maximum packet size supported (64 bytes) 
....................     0x00,                       // polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................     // Endpoint descriptor EP2 - OUT (from the Host) 
....................     // WDM = "PIPE1"  command 
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor 
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05) 
....................     0x02,                       // endpoint number and direction (0x02 = EPC2 OUT) 
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................     0x40,0x00,                  // maximum packet size supported (64 bytes) 
....................     0x00,                       // polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................     // Endpoint descriptor EP3 - IN (to the Host) 
....................     // WDM = "PIPE2"  streaming 1 
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor 
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05) 
....................     0x83,                       // endpoint number and direction (0x83 = EPC3 IN) 
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................     0x40,0x00,                  // maximum packet size supported (64 bytes) 
....................     0x00,                       // polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................     // Endpoint descriptor EP4 - IN (to the Host) 
....................     // WDM = "PIPE3"  streaming 2 
....................     USB_ENDPOINT_DESC_LEN,      // length of descriptor 
....................     USB_ENDPOINT_DESC_KEY,      // constant ENDPOINT (0x05) 
....................     0x84,                       // endpoint number and direction (0x84 = EPC5 IN) 
....................     0x02,                       // transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................     0x40,0x00,                  // maximum packet size supported (64 bytes) 
....................     0x00                        // polling interval in ms. (for interrupt transfers ONLY) 
.................... };  
....................  
....................  
.................... // 
.................... // String descriptors and string lengths 
.................... // 
.................... #define USB_STRING_0_LEN    4 
.................... #define USB_STRING_1_LEN    56 
.................... #define USB_STRING_2_LEN    50 
.................... #define USB_STRING_SN_LEN   18 
....................  
.................... int8 const USB_STRING_0[USB_STRING_0_LEN] = {   
....................                                 // string index 0 is special 
....................          USB_STRING_0_LEN,      // length of string index 
....................          0x03,                  // descriptor type 0x03 (STRING) 
....................          0x09,0x04              // Microsoft Defined for US-English 
.................... }; 
....................  
.................... int8 const USB_STRING_1[USB_STRING_1_LEN] = {   
....................                                 // we defined string index 1 earlier as manuf string 
....................          USB_STRING_1_LEN,      // length of string index 
....................          0x03,                  // descriptor type 0x03 (STRING) 
....................          'I',0, 
....................          'n',0, 
....................          't',0, 
....................          'e',0, 
....................          'g',0, 
....................          'r',0, 
....................          'i',0, 
....................          't',0, 
....................          'y',0, 
....................          ' ',0, 
....................          'I',0, 
....................          'n',0, 
....................          's',0, 
....................          't',0, 
....................          'r',0, 
....................          'u',0, 
....................          'm',0, 
....................          'e',0, 
....................          'n',0, 
....................          't',0, 
....................          's',0, 
....................          ',',0, 
....................          ' ',0, 
....................          'I',0, 
....................          'n',0, 
....................          'c',0, 
....................          '.',0 
.................... }; 
....................  
.................... int8 const USB_STRING_2[USB_STRING_2_LEN] = {   
....................                                 // we defined string index 2 as description of product 
....................          USB_STRING_2_LEN,      // length of string index 
....................          0x03,                  // descriptor type 0x03 (STRING) 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          'M',0, 
....................          '4',0, 
....................          '0',0, 
....................          '0',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'a',0, 
....................          't',0, 
....................          'a',0, 
....................          ' ',0, 
....................          'A',0, 
....................          'c',0, 
....................          'q',0, 
....................          'u',0, 
....................          'i',0, 
....................          's',0, 
....................          'i',0, 
....................          't',0, 
....................          'i',0, 
....................          'o',0, 
....................          'n',0 
.................... }; 
....................  
....................  
.................... int8 const USB_STRING_SN[USB_STRING_SN_LEN] = {   
....................          USB_STRING_SN_LEN,   // length of string index 
....................          0x03,                // descriptor type 0x03 (STRING) 
....................          'D',0, 
....................          'E',0, 
....................          'A',0, 
....................          'D',0, 
....................          'B',0, 
....................          'E',0, 
....................          'E',0, 
....................          'F',0 
.................... }; 
....................  
.................... // Same as the const (ROM) structure above, but in RAM 
.................... int8 USB_STRING_SN_RAM[USB_STRING_SN_LEN]; 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define USB_MAX_ENDPOINTS 5     // number of bidrectional endpoints.  960x has 1 control port and 6 individual endpoints = 4 bidrectional endpoints 
....................  
.................... // 
.................... // USBN9603 register defines 
.................... // 
.................... #include "usbn9603_reg.h" 
.................... /*---------------------------------------------------------------------------- 
....................  *  Copyright (c) 2001 by National Semiconductor Corporation 
....................  *  National Semiconductor Corporation 
....................  *  2900 Semiconductor Drive 
....................  *  Santa Clara, California 95051 
....................  * 
....................  *  All rights reserved 
....................  * 
....................  *<<<------------------------------------------------------------------------- 
....................  * File Contents: 
....................  *	usb_reg.c - USB related definitions 
....................  * 
....................  *  Project: USB firmware 
....................  *  Author : Lev Solar 
....................  *  Date   : Jan 2001 
....................  *----------------------------------------------------------------------->>>*/ 
.................... #ifndef __usb_reg_h__ 
.................... #define __usb_reg_h__ 
....................  
.................... /*--------------------------------------------------------------------------*/ 
.................... /*-----------------------   Configuration Registers   ----------------------*/ 
.................... /*--------------------------------------------------------------------------*/ 
.................... #define MCNTRL     0x00                 /*Main control register   */ 
.................... #define CCONF      0x01                 /*Clk. config. register   */     
.................... #define RID        0x03                 /*Rev. ID      register   */   
.................... #define FAR        0x04                 /*Func address register   */   
.................... #define NFSR       0x05                 /*Node func st register   */    
.................... #define MAEV       0x06                 /*Main event   register   */   
.................... #define MAMSK      0x07                 /*Main mask    register   */   
.................... #define ALTEV      0x08                 /*Alt. event   register   */   
.................... #define ALTMSK     0x09                 /*ALT  mask    register   */   
.................... #define TXEV       0x0A                 /*TX   event   register   */  
.................... #define TXMSK      0x0B                 /*TX   mask    register   */    
.................... #define RXEV       0x0C                 /*RX   event   register   */  
.................... #define RXMSK      0x0D                 /*RX   mask    register   */    
.................... #define NAKEV      0x0E                 /*NAK  event   register   */   
.................... #define NAKMSK     0x0F                 /*NAK  mask    register   */   
.................... #define FWEV       0x10                 /*FIFO warning register   */    
.................... #define FWMSK      0x11                 /*FIFO warning mask       */   
.................... #define FNH        0x12                 /*Frame nbr hi register   */    
.................... #define FNL        0x13                 /*Frame nbr lo register   */   
.................... #define DMACNTRL   0x14                 /*DMA  control register   */   
.................... #define DMAEV	   0x15					/*DMA  event   register	  */ 
.................... #define DMAMSK	   0x16					/*DMA  mask	   register   */ 
.................... #define DMACNT	   0x18				    /*DMA  count   register   */ 
.................... #define DMAERR	   0x19					/*DMA  error counnt register */  
.................... #define WKUP	   0x1b 
....................   
.................... #define EPC0       0x20                 /*Endpoint0    register   */    
.................... #define TXD0       0x21                 /*TX   data    register 0 */   
.................... #define TXS0       0x22                 /*TX   status  register 0 */  
.................... #define TXC0       0x23                 /*TX   command register 0 */   
....................   
.................... #define RXD0       0x25                 /*RX   data    register 0 */    
.................... #define RXS0       0x26                 /*RX   status  register 0 */    
.................... #define RXC0       0x27                 /*RX   command register 0 */    
....................   
.................... #define EPC1       0x28                 /*Endpoint1    register   */    
.................... #define TXD1       0x29                 /*TX   data    register 1 */   
.................... #define TXS1       0x2A                 /*TX   status  register 1 */  
.................... #define TXC1       0x2B                 /*TX   command register 1 */   
....................   
.................... #define EPC2       0x2C                 /*Endpoint2    register   */    
.................... #define RXD1       0x2D                 /*RX   data    register 1 */    
.................... #define RXS1       0x2E                 /*RX   status  register 1 */    
.................... #define RXC1       0x2F                 /*RX   command register 1 */    
....................   
.................... #define EPC3       0x30                 /*Endpoint3    register   */    
.................... #define TXD2       0x31                 /*TX   data    register 2 */   
.................... #define TXS2       0x32                 /*TX   status  register 2 */  
.................... #define TXC2       0x33                 /*TX   command register 2 */   
....................   
.................... #define EPC4       0x34                 /*Endpoint4    register   */    
.................... #define RXD2       0x35                 /*RX   data    register 2 */    
.................... #define RXS2       0x36                 /*RX   status  register 2 */    
.................... #define RXC2       0x37                 /*RX   command register 2 */    
....................   
.................... #define EPC5       0x38                 /*Endpoint5    register   */    
.................... #define TXD3       0x39                 /*TX   data    register 3 */   
.................... #define TXS3       0x3A                 /*TX   status  register 3 */  
.................... #define TXC3       0x3B                 /*TX   command register 3 */   
....................   
.................... #define EPC6       0x3C                 /*Endpoint6    register   */    
.................... #define RXD3       0x3D                 /*RX   data    register 3 */    
.................... #define RXS3       0x3E                 /*RX   status  register 3 */    
.................... #define RXC3       0x3F                 /*RX   command register 3 */    
....................   
.................... /*--------------------------------------------------------------------*/ 
.................... /*-------------------   Configuration Register Bitmaps   -------------*/ 
.................... /*--------------------------------------------------------------------*/ 
....................  
.................... /*-------------------------------- MCNTRL ------------------------*/ 
.................... #define SRST       0x01                 /*software reset          */    
.................... #define DBG        0x02                 /*debug mode              */   
.................... #define VGE        0x04                 /*voltage regulator enable*/     
.................... #define NAT        0x08                 /*node attached           */   
.................... #define INT_DIS    0x00                 /*interrupts disabled     */   
.................... #define INT_L_O    0x40                 /*act lo ints, open drain */   
.................... #define INT_H_P    0x80                 /*act hi in	ts, push pull  */   
.................... #define INT_L_P    0xC0                 /*act lo ints, push pull  */   
....................   
.................... /*---------------------------------- FAR -------------------------*/ 
.................... #define AD_EN      0x80                 /*address enable          */    
....................   
.................... /*--------------------------------- EPCX -------------------------*/ 
.................... #define DEF        0x40                 /*force def. adr (0 only) */    
.................... #define STALL      0x80                 /*force stall handshakes  */   
.................... #define ISO        0x20                 /*set for isochr. (1-3)   */  
.................... #define EP_EN      0x10                 /*enables endpt.  (1-3)   */   
....................   
.................... /*--------------------------------- NFSR -------------------------*/ 
.................... #define RST_ST     0x00                 /*reset       state       */    
.................... #define RSM_ST     0x01                 /*resume      state       */   
.................... #define OPR_ST     0x02                 /*operational state       */   
.................... #define SUS_ST     0x03                 /*suspend     state       */   
....................   
.................... /*---------------------------- MAEV, MAMSK -----------------------*/ 
.................... #define WARN       0x01                 /*warning bit has been set*/    
.................... #define ALT        0x02                 /*alternate event         */   
.................... #define TX_EV      0x04                 /*transmit event          */   
.................... #define FRAME      0x08                 /*SOF packet received     */   
.................... #define NAK        0x10                 /*NAK event               */   
.................... #define ULD        0x20                 /*unlock locked detected  */    
.................... #define RX_EV      0x40                 /*receive event           */    
.................... #define INTR_E     0x80                 /*master interrupt enable */   
....................   
.................... /*---------------------------- ALTEV, ALTMSK ---------------------*/ 
.................... #define ALT_DMA	   0x04					/*DMA event				  */ 
.................... #define ALT_EOP    0x08                 /*end of packet           */    
.................... #define ALT_SD3    0x10                 /*3 ms suspend            */   
.................... #define ALT_SD5    0x20                 /*5 ms suspend            */   
.................... #define ALT_RESET  0x40                 /*reset  detected         */   
.................... #define ALT_RESUME 0x80                 /*resume detected         */  
....................   
.................... /*---------------------------- TXEV, TXMSK -----------------------*/ 
.................... #define TX_FIFO0    0x01                 /*TX_DONE, FIFO 0         */    
.................... #define TX_FIFO1    0x02                 /*TX_DONE, FIFO 1         */    
.................... #define TX_FIFO2    0x04                 /*TX_DONE, FIFO 2         */    
.................... #define TX_FIFO3    0x08                 /*TX_DONE, FIFO 3         */    
.................... #define TX_UDRN0    0x10                 /*TX_URUN, FIFO 0         */    
.................... #define TX_UDRN1    0x20                 /*TX_URUN, FIFO 1         */   
.................... #define TX_UDRN2    0x40                 /*TX_URUN, FIFO 2         */   
.................... #define TX_UDRN3    0x80                 /*TX_URUN, FIFO 3         */   
....................   
.................... /*---------------------------- RXEV, RXMSK -----------------------*/ 
.................... #define RX_FIFO0    0x01                 /*RX_DONE, FIFO 0         */    
.................... #define RX_FIFO1    0x02                 /*RX_DONE, FIFO 1         */    
.................... #define RX_FIFO2    0x04                 /*RX_DONE, FIFO 2         */    
.................... #define RX_FIFO3    0x08                 /*RX_DONE, FIFO 3         */    
.................... #define RX_OVRN0    0x10                 /*RX_OVRN, FIFO 0         */    
.................... #define RX_OVRN1    0x20                 /*RX_OVRN, FIFO 1         */   
.................... #define RX_OVRN2    0x40                 /*RX_OVRN, FIFO 2         */   
.................... #define RX_OVRN3    0x80                 /*RX_OVRN, FIFO 3         */   
....................   
.................... /*-------------------------- NAKEV, NAKMSK -----------------------*/ 
.................... #define NAK_IN0		0x01                 /*IN  NAK, FIFO 0         */    
.................... #define NAK_IN1     0x02                 /*IN  NAK, FIFO 1         */   
.................... #define NAK_IN2     0x04                 /*IN  NAK, FIFO 2         */   
.................... #define NAK_IN3     0x08                 /*IN  NAK, FIFO 3         */   
.................... #define NAK_OUT0	0x10                 /*OUT NAK, FIFO 0         */   
.................... #define NAK_OUT1    0x20                 /*OUT NAK, FIFO 1         */  
.................... #define NAK_OUT2    0x40                 /*OUT NAK, FIFO 2         */  
.................... #define NAK_OUT3    0x80                 /*OUT NAK, FIFO 3         */  
....................  
.................... /*-------------------------- DMAEV, DMAMSK ------------------------*/ 
.................... #define DMA_DSHLT	0x01				 /*DMA Software Halt	   */ 
.................... #define DMA_DERR	0x02				 /*DMA Error			   */ 
.................... #define DMA_DCNT	0x04				 /*DMA Count			   */ 
.................... #define DMA_DSIZ	0x08				 /*DMA Size				   */ 
.................... #define DMA_NTGL	0x20				 /*Next Toggle			   */ 
....................   
.................... /*------------------------------ DMACNTRL -------------------------*/ 
.................... #define DMA_DMOD	0x08				 /*DMA Mode				   */ 
.................... #define DMA_ADMA	0x10				 /*Automatic DMA		   */ 
.................... #define DMA_DTGL	0x20				 /*DMA Toggle			   */ 
.................... #define IGNRXTGL	0x40				 /*Ignore RX Toggle		   */ 
.................... #define	DMA_DEN		0x80				 /*DMA Enable			   */ 
....................  
.................... /*------------------------------ DMAERR ---------------------------*/ 
.................... #define DMA_AEH		0x80				 /*Automatic Error Handling*/  
....................  
.................... /*------------------------------- TXC0 ---------------------------*/ 
.................... #define IGN_IN     0x10                 /*ignore in  tokens       */    
....................  
.................... /*------------------------------- TXCx ---------------------------*/ 
.................... #define TX_EN      	0x01                /*transmit enable         */    
.................... #define TX_LAST    	0x02                /*specifies last byte     */  
.................... #define TX_TOGL    	0x04                /*specifies PID used      */  
.................... #define FLUSH      	0x08                /*flushes all FIFO data   */ 
.................... #define RFF		  	0x10				/*refill FIFO			  */ 
.................... #define IGN_ISOMSK	0x80				/*ignore ISO Mask		  */ 
....................  
.................... /*------------------------------- TXS0 ---------------------------*/ 
.................... #define TX_EBYTES  0x1F					/*available empty bytes   */ 
.................... #define TX_DONE    0x20                 /*transmit done           */    
.................... #define ACK_STAT   0x40                 /*ack status of xmission  */ 
....................   
.................... /*------------------------------- RXC0 ---------------------------*/ 
.................... #define RX_EN      0x01                 /*receive  enable         */    
.................... #define IGN_OUT    0x02                 /*ignore out tokens       */    
.................... #define IGN_SETUP  0x04                 /*ignore setup tokens     */   
....................  
.................... /*------------------------------- RXSx ---------------------------*/ 
.................... #define RX_LAST    0x10                 /*indicates RCOUNT valid  */    
.................... #define RX_TOGL    0x20                 /*last pkt was DATA1 PID  */    
.................... #define SETUP_R    0x40                 /*setup packet received   */   
.................... #define RX_ERR     0x80                 /*last packet had an error*/    
....................  
....................  
.................... #endif __usb_reg_h__ 
....................  
....................  
.................... // 
.................... // Forward function declarations 
.................... // 
.................... void usb_init(void); 
.................... int8 usbn_get_version(void); 
....................  
.................... // 
.................... // ISR prototypes and associated handlers 
.................... // 
.................... void usb_isr(void); 
.................... void handle_warn(void); 
.................... void handle_alt(void); 
.................... void handle_txev(void); 
.................... void handle_frame(void); 
.................... void handle_uld(void); 
.................... void handle_rxev(void); 
....................  
.................... // 
.................... // Functions that change with SPI vs. Memory Mapped interfaces 
.................... // 
.................... void usbn_write(int8 address, int8 data); 
.................... int8 usbn_read(int8 address); 
....................  
.................... // 
.................... // USBN9603 endpoints           EP Addressing 
.................... // ----------------------------------------------- 
.................... // EP0  TX/RX   8 byte FIFO 
.................... // EP1  TX      64 byte FIFO    bulk 1          WDM "PIPE0" 
.................... // EP2  RX      64 byte FIFO    bulk 2          WDM "PIPE1" 
.................... // EP3  TX      64 byte FIFO    not used 
.................... // EP4  RX      64 byte FIFO    not used 
.................... // EP5  TX      64 byte FIFO    not used 
.................... // EP6  RX      64 byte FIFO    not used 
....................  
.................... // BUGBUG: AAK these variables are not used (2-9-2008) 
.................... //DONT CHANGE THE FOLLOWING 3 CONSTANT ARRAYS 
.................... // const char EPCx[]=    {EPC0, EPC1, EPC2, EPC3, EPC4, EPC5, EPC6};   // epc_address[x] finds the constant EPCx 
.................... // const char TX_FIFOx[]={TXD0, TXD1, 0,    TXD2, 0,    TXD3, 0};      // ecp0,ecp1,ecp3,ecp5 have tx_fifos 
.................... // const char RX_FIFOx[]={RXD0, 0,    RXD1, 0,    RXD2, 0,    RXD3};   // ecp0,ecp2,ecp4,ecp6 have rx_fifos 
....................  
....................  
.................... /// BEGIN User Functions 
....................  
.................... int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................  
....................  
.................... // 
.................... // Types of Xfer's supported in control EP0 
.................... // 
.................... #define     NO_XFER         0 
.................... #define     DEVICE_DESC     1 
.................... #define     CONFIG_DESC     2 
.................... #define     STRING_DESC     3 
.................... #define     ZERO_LEN_XFER   4 
....................  
....................  
.................... struct { 
....................     int8    nXferType; 
....................     int8    nCurPosition; 
....................     int8    nLength; 
....................     int8    nStrIndex; 
.................... } XferEP0; 
....................  
....................  
.................... struct { 
....................     int8    toggle_bit; 
....................     int8    FIFO_status; 
.................... } endpoint_stat[USB_MAX_ENDPOINTS]; 
....................  
....................  
.................... typedef enum { 
....................       EMPTY, 
....................       FULL, 
....................       WAIT_FOR_ACK 
.................... } FIFO_status_t; 
....................  
....................  
.................... // 
.................... // 
.................... int8 alt_mask; 
.................... int8 setaddress = 0; 
....................  
.................... // Bits 0-6 correspond to each endpoint. Bit set = stalled 
.................... // Written by Set/Clear Feature, Read by Get Status 
.................... int8 stalld; 
....................  
.................... // Current USB configuration (only 1 here) 
.................... int8 usb_cfg; 
....................  
.................... void endpoint_status_init(void) 
.................... { 
....................    int8 i; 
....................  
....................    for(i=0; i<USB_MAX_ENDPOINTS; i++) 
*
0E22:  CLRF   xD4
0E24:  MOVF   xD4,W
0E26:  SUBLW  04
0E28:  BNC   0E84
....................     { 
....................         endpoint_stat[i].FIFO_status = EMPTY; 
0E2A:  BCF    FD8.0
0E2C:  RLCF   xD4,W
0E2E:  CLRF   xD6
0E30:  MOVWF  xD5
0E32:  MOVLW  01
0E34:  ADDWF  xD5,W
0E36:  MOVWF  01
0E38:  MOVLW  00
0E3A:  ADDWFC xD6,W
0E3C:  MOVWF  03
0E3E:  MOVF   01,W
0E40:  ADDLW  B3
0E42:  MOVWF  FE9
0E44:  MOVLW  00
0E46:  ADDWFC 03,W
0E48:  MOVWF  FEA
0E4A:  CLRF   FEF
....................         if (i == 0) 
0E4C:  MOVF   xD4,F
0E4E:  BNZ   0E6A
....................         { 
....................             // 
....................             // control endpoint - EP0 
....................             // 
....................             endpoint_stat[i].toggle_bit = 0x01; 
0E50:  BCF    FD8.0
0E52:  RLCF   xD4,W
0E54:  CLRF   xD6
0E56:  MOVWF  xD5
0E58:  MOVLW  B3
0E5A:  ADDWF  xD5,W
0E5C:  MOVWF  FE9
0E5E:  MOVLW  00
0E60:  ADDWFC xD6,W
0E62:  MOVWF  FEA
0E64:  MOVLW  01
0E66:  MOVWF  FEF
....................         } else { 
0E68:  BRA    0E80
....................             // 
....................             // tx & rx data endpoints 
....................             // 
....................             endpoint_stat[i].toggle_bit = 0x00; 
0E6A:  BCF    FD8.0
0E6C:  RLCF   xD4,W
0E6E:  CLRF   xD6
0E70:  MOVWF  xD5
0E72:  MOVLW  B3
0E74:  ADDWF  xD5,W
0E76:  MOVWF  FE9
0E78:  MOVLW  00
0E7A:  ADDWFC xD6,W
0E7C:  MOVWF  FEA
0E7E:  CLRF   FEF
....................         } 
....................    } 
0E80:  INCF   xD4,F
0E82:  BRA    0E24
....................     return; 
.................... } 
0E84:  RETLW  00
....................  
....................  
.................... void reset_usb(void) 
.................... { 
....................    usbn_write(EPC0, 0x00);                 // Default addres 0x00 for EP0 
0E86:  MOVLW  20
0E88:  MOVWF  xDE
0E8A:  CLRF   xDF
0E8C:  CALL   038E
....................     usbn_write(FAR, 0x00); 
0E90:  MOVLW  04
0E92:  MOVWF  xDE
0E94:  CLRF   xDF
0E96:  CALL   038E
....................  
.................... //   usbn_write(FAR, AD_EN | 0x00); // Default device addres in FAR 
.................... //   usbn_write(FAR, usbn_read(FAR) | AD_EN);// Enable FAR addressing 
....................  
....................     usbn_write(TXC0, FLUSH);         // flush fifos 
0E9A:  MOVLW  23
0E9C:  MOVWF  xDE
0E9E:  MOVLW  08
0EA0:  MOVWF  xDF
0EA2:  CALL   038E
....................     usbn_write(TXC1, FLUSH); 
0EA6:  MOVLW  2B
0EA8:  MOVWF  xDE
0EAA:  MOVLW  08
0EAC:  MOVWF  xDF
0EAE:  CALL   038E
....................     usbn_write(TXC2, FLUSH); 
0EB2:  MOVLW  33
0EB4:  MOVWF  xDE
0EB6:  MOVLW  08
0EB8:  MOVWF  xDF
0EBA:  CALL   038E
....................     usbn_write(TXC3, FLUSH); 
0EBE:  MOVLW  3B
0EC0:  MOVWF  xDE
0EC2:  MOVLW  08
0EC4:  MOVWF  xDF
0EC6:  CALL   038E
....................     usbn_write(RXC0, FLUSH); 
0ECA:  MOVLW  27
0ECC:  MOVWF  xDE
0ECE:  MOVLW  08
0ED0:  MOVWF  xDF
0ED2:  CALL   038E
....................     usbn_write(RXC1, FLUSH); 
0ED6:  MOVLW  2F
0ED8:  MOVWF  xDE
0EDA:  MOVLW  08
0EDC:  MOVWF  xDF
0EDE:  CALL   038E
....................     usbn_write(RXC2, FLUSH); 
0EE2:  MOVLW  37
0EE4:  MOVWF  xDE
0EE6:  MOVLW  08
0EE8:  MOVWF  xDF
0EEA:  CALL   038E
....................     usbn_write(RXC3, FLUSH); 
0EEE:  MOVLW  3F
0EF0:  MOVWF  xDE
0EF2:  MOVLW  08
0EF4:  MOVWF  xDF
0EF6:  CALL   038E
....................  
.................... //    usbn_write(EPC0, 0x40);        //  Default address on EP0 
....................  
.................... //    memset(ep0_rx_buffer, 0, USB_MAX_EP0_PACKET_LENGTH); 
.................... //    memset(ep0_tx_buffer, 0, USB_MAX_EP0_PACKET_LENGTH); 
....................    endpoint_status_init(); 
0EFA:  RCALL  0E22
....................  
....................    // Enable the receiver - EP0 
....................    usbn_write(RXC0, RX_EN); 
0EFC:  MOVLW  27
0EFE:  MOVWF  xDE
0F00:  MOVLW  01
0F02:  MOVWF  xDF
0F04:  CALL   038E
....................  
....................     return; 
.................... } 
0F08:  RETLW  00
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: Resets and initalizes USB code and USBN device.  You must call this 
.................... /*          first before using code. 
.................... /* 
.................... /*          NOTE: this enables interrupts. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_init(void) 
.................... { 
....................     usb_cfg = 0; 
*
133E:  CLRF   xC0
1340:  CLRF   18
1342:  BTFSC  FF2.7
1344:  BSF    18.7
1346:  BCF    FF2.7
....................  
....................     usbn_write(MCNTRL, SRST);               // Force the chip to RESET 
1348:  CLRF   xDE
134A:  MOVLW  01
134C:  MOVWF  xDF
134E:  CALL   038E
1352:  BTFSC  18.7
1354:  BSF    FF2.7
1356:  CLRF   18
1358:  BTFSC  FF2.7
135A:  BSF    18.7
135C:  BCF    FF2.7
....................     while (usbn_read(MCNTRL) & SRST);       // and wait for reset to complete 
135E:  CLRF   xDE
1360:  CALL   0324
1364:  BTFSC  18.7
1366:  BSF    FF2.7
1368:  BTFSC  01.0
136A:  BRA    1356
136C:  CLRF   18
136E:  BTFSC  FF2.7
1370:  BSF    18.7
1372:  BCF    FF2.7
....................  
....................     usbn_write(CCONF, 0x80);                // Disable clock output 
1374:  MOVLW  01
1376:  MOVWF  xDE
1378:  MOVLW  80
137A:  MOVWF  xDF
137C:  CALL   038E
1380:  BTFSC  18.7
1382:  BSF    FF2.7
1384:  CLRF   18
1386:  BTFSC  FF2.7
1388:  BSF    18.7
138A:  BCF    FF2.7
....................  
....................     usbn_write(MCNTRL, INT_L_P | VGE);      // Active low interrupts + VGE 
138C:  CLRF   xDE
138E:  MOVLW  C4
1390:  MOVWF  xDF
1392:  CALL   038E
1396:  BTFSC  18.7
1398:  BSF    FF2.7
139A:  CLRF   18
139C:  BTFSC  FF2.7
139E:  BSF    18.7
13A0:  BCF    FF2.7
....................  
....................     usbn_write(MAMSK, 0x00);                // Mask all interrupt events 
13A2:  MOVLW  07
13A4:  MOVWF  xDE
13A6:  CLRF   xDF
13A8:  CALL   038E
13AC:  BTFSC  18.7
13AE:  BSF    FF2.7
13B0:  CLRF   18
13B2:  BTFSC  FF2.7
13B4:  BSF    18.7
13B6:  BCF    FF2.7
....................     usbn_write(NAKMSK, NAK_OUT0);               // NAK mask 
13B8:  MOVLW  0F
13BA:  MOVWF  xDE
13BC:  MOVLW  10
13BE:  MOVWF  xDF
13C0:  CALL   038E
13C4:  BTFSC  18.7
13C6:  BSF    FF2.7
13C8:  CLRF   18
13CA:  BTFSC  FF2.7
13CC:  BSF    18.7
13CE:  BCF    FF2.7
....................     usbn_write(TXMSK, TX_FIFO0 | TX_FIFO1 | TX_FIFO2 | TX_FIFO3);     // TX mask  | TX_FIFO2 | TX_FIFO3 
13D0:  MOVLW  0B
13D2:  MOVWF  xDE
13D4:  MOVLW  0F
13D6:  MOVWF  xDF
13D8:  CALL   038E
13DC:  BTFSC  18.7
13DE:  BSF    FF2.7
13E0:  CLRF   18
13E2:  BTFSC  FF2.7
13E4:  BSF    18.7
13E6:  BCF    FF2.7
....................     usbn_write(RXMSK, RX_FIFO0 | RX_FIFO1);     // RX mask  | RX_FIFO2 | RX_FIFO3 
13E8:  MOVLW  0D
13EA:  MOVWF  xDE
13EC:  MOVLW  03
13EE:  MOVWF  xDF
13F0:  CALL   038E
13F4:  BTFSC  18.7
13F6:  BSF    FF2.7
....................     alt_mask = ALT_SD3 | ALT_RESET; 
13F8:  MOVLW  50
13FA:  MOVWF  xBD
13FC:  CLRF   18
13FE:  BTFSC  FF2.7
1400:  BSF    18.7
1402:  BCF    FF2.7
....................     usbn_write(ALTMSK, alt_mask);               // ALT mask 
1404:  MOVLW  09
1406:  MOVWF  xDE
1408:  MOVFF  BD,DF
140C:  CALL   038E
1410:  BTFSC  18.7
1412:  BSF    FF2.7
1414:  CLRF   18
1416:  BTFSC  FF2.7
1418:  BSF    18.7
141A:  BCF    FF2.7
....................  
....................     usbn_write(MAMSK, INTR_E | RX_EV | NAK | TX_EV | ALT);  // Enable node interrupts 
141C:  MOVLW  07
141E:  MOVWF  xDE
1420:  MOVLW  D6
1422:  MOVWF  xDF
1424:  CALL   038E
1428:  BTFSC  18.7
142A:  BSF    FF2.7
142C:  CLRF   18
142E:  BTFSC  FF2.7
1430:  BSF    18.7
1432:  BCF    FF2.7
....................  
....................     usbn_write(WKUP,0x0C); 
1434:  MOVLW  1B
1436:  MOVWF  xDE
1438:  MOVLW  0C
143A:  MOVWF  xDF
143C:  CALL   038E
1440:  BTFSC  18.7
1442:  BSF    FF2.7
1444:  CLRF   18
1446:  BTFSC  FF2.7
1448:  BSF    18.7
144A:  BCF    FF2.7
....................  
....................     usbn_write(0x1F,0x40);                          // 3.3V regulator work around 
144C:  MOVLW  1F
144E:  MOVWF  xDE
1450:  MOVLW  40
1452:  MOVWF  xDF
1454:  CALL   038E
1458:  BTFSC  18.7
145A:  BSF    FF2.7
145C:  CLRF   18
145E:  BTFSC  FF2.7
1460:  BSF    18.7
1462:  BCF    FF2.7
....................  
.................... //    usbn_write(FWMSK, FWMSK_ENABLES); 
....................  
....................     reset_usb();                                    // Reset USB interface 
1464:  RCALL  0E86
1466:  BTFSC  18.7
1468:  BSF    FF2.7
....................  
....................     ext_int_edge(H_TO_L);                           // Enable the PIC interrupts 
146A:  BCF    FF1.6
....................     enable_interrupts(int_ext); 
146C:  BSF    FF2.4
....................     enable_interrupts(global); 
146E:  MOVLW  C0
1470:  IORWF  FF2,F
1472:  CLRF   18
1474:  BTFSC  FF2.7
1476:  BSF    18.7
1478:  BCF    FF2.7
....................  
....................     delay_ms(5);                                    // Wait for the 3.3 V regulator to stabilize 
147A:  MOVLW  05
147C:  MOVWF  xD4
147E:  RCALL  0DFA
1480:  BTFSC  18.7
1482:  BSF    FF2.7
1484:  CLRF   18
1486:  BTFSC  FF2.7
1488:  BSF    18.7
148A:  BCF    FF2.7
....................     usbn_write(FAR, AD_EN); 
148C:  MOVLW  04
148E:  MOVWF  xDE
1490:  MOVLW  80
1492:  MOVWF  xDF
1494:  CALL   038E
1498:  BTFSC  18.7
149A:  BSF    FF2.7
149C:  CLRF   18
149E:  BTFSC  FF2.7
14A0:  BSF    18.7
14A2:  BCF    FF2.7
....................     usbn_write(EPC0, 0); 
14A4:  MOVLW  20
14A6:  MOVWF  xDE
14A8:  CLRF   xDF
14AA:  CALL   038E
14AE:  BTFSC  18.7
14B0:  BSF    FF2.7
14B2:  CLRF   18
14B4:  BTFSC  FF2.7
14B6:  BSF    18.7
14B8:  BCF    FF2.7
....................     usbn_write(NFSR, OPR_ST);                       // Go operational 
14BA:  MOVLW  05
14BC:  MOVWF  xDE
14BE:  MOVLW  02
14C0:  MOVWF  xDF
14C2:  CALL   038E
14C6:  BTFSC  18.7
14C8:  BSF    FF2.7
14CA:  CLRF   18
14CC:  BTFSC  FF2.7
14CE:  BSF    18.7
14D0:  BCF    FF2.7
....................     usbn_write(RXC0, RX_EN); 
14D2:  MOVLW  27
14D4:  MOVWF  xDE
14D6:  MOVLW  01
14D8:  MOVWF  xDF
14DA:  CALL   038E
14DE:  BTFSC  18.7
14E0:  BSF    FF2.7
14E2:  CLRF   18
14E4:  BTFSC  FF2.7
14E6:  BSF    18.7
14E8:  BCF    FF2.7
....................     usbn_write(MCNTRL, usbn_read(MCNTRL) | NAT);    // Attach node 
14EA:  CLRF   xDE
14EC:  CALL   0324
14F0:  BTFSC  18.7
14F2:  BSF    FF2.7
14F4:  MOVF   01,W
14F6:  IORLW  08
14F8:  MOVWF  xC8
14FA:  CLRF   18
14FC:  BTFSC  FF2.7
14FE:  BSF    18.7
1500:  BCF    FF2.7
1502:  CLRF   xDE
1504:  MOVWF  xDF
1506:  CALL   038E
150A:  BTFSC  18.7
150C:  BSF    FF2.7
....................     return; 
.................... } 
150E:  GOTO   1870 (RETURN)
....................  
....................  
....................  
....................  
.................... /**********************************************************************/ 
.................... /* Transmit on USB endpoint 0                                         */ 
.................... /*   Must setup structure XP0 before calling this function            */ 
.................... /**********************************************************************/ 
.................... void XmitOnUSB0(void) { 
....................    int8    i = 0; 
*
04B4:  CLRF   xDB
....................    int8    j; 
....................  
....................     // 
....................     // 
....................     j = XferEP0.nCurPosition; 
04B6:  MOVFF  B0,DC
....................     if (j > 0x80) { 
04BA:  MOVF   xDC,W
04BC:  SUBLW  80
04BE:  BC    04C4
....................       i = 9; 
04C0:  MOVLW  09
04C2:  MOVWF  xDB
....................     } 
....................  
.................... //    memset(ep0_tx_buffer, 0, 8); 
....................  
....................    //switch on descriptor type in location 3 (high order of wValue) 
....................    switch (XferEP0.nXferType){ 
04C4:  MOVF   xAF,W
04C6:  BZ    04DC
04C8:  XORLW  01
04CA:  BZ    04E2
04CC:  XORLW  03
04CE:  BZ    052A
04D0:  XORLW  01
04D2:  BZ    0572
04D4:  XORLW  07
04D6:  BTFSC  FD8.2
04D8:  BRA    068E
04DA:  BRA    0696
....................         case NO_XFER:                   // No xfer - ERROR! 
....................             i = 99; 
04DC:  MOVLW  63
04DE:  MOVWF  xDB
....................             break; 
04E0:  BRA    0698
....................       case DEVICE_DESC:               // DEVICE descriptor 
....................            // Load the buffer 
....................             for (i=0; i<8; i++) { 
04E2:  CLRF   xDB
04E4:  MOVF   xDB,W
04E6:  SUBLW  07
04E8:  BNC   0528
....................                 if (j > USB_DEVICE_DESC_LEN) 
04EA:  MOVF   xDC,W
04EC:  SUBLW  12
04EE:  BC    04F4
....................                    i = 9; 
04F0:  MOVLW  09
04F2:  MOVWF  xDB
....................  
....................                 ep0_tx_buffer[i] = USB_DEVICE_DESC[j]; 
04F4:  CLRF   03
04F6:  MOVF   xDB,W
04F8:  ADDLW  A7
04FA:  MOVWF  FE9
04FC:  MOVLW  00
04FE:  ADDWFC 03,W
0500:  MOVWF  FEA
0502:  CLRF   03
0504:  MOVF   xDC,W
0506:  MOVFF  FF2,DF
050A:  BCF    FF2.7
050C:  RCALL  00E0
050E:  BTFSC  xDF.7
0510:  BSF    FF2.7
0512:  MOVWF  FEF
....................                 j++; 
0514:  INCF   xDC,F
....................                 XferEP0.nLength--; 
0516:  DECF   xB1,F
....................                 if(XferEP0.nLength == 0) { 
0518:  MOVF   xB1,F
051A:  BNZ   0524
....................                     XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer 
051C:  MOVLW  04
051E:  MOVWF  xAF
....................                     i++; 
0520:  INCF   xDB,F
....................                     break; 
0522:  BRA    0528
....................                 } 
....................             } 
0524:  INCF   xDB,F
0526:  BRA    04E4
....................          break; 
0528:  BRA    0698
....................       case CONFIG_DESC:               // CONFIGURATION descriptor includes INTERFACE and ENDPOINT descriptors 
....................             // Load the buffer 
....................             for (i=0; i<8; i++) { 
052A:  CLRF   xDB
052C:  MOVF   xDB,W
052E:  SUBLW  07
0530:  BNC   0570
....................                 if (j > USB_CONFIG_DESC_TOTAL_LEN) 
0532:  MOVF   xDC,W
0534:  SUBLW  2E
0536:  BC    053C
....................                     i = 9; 
0538:  MOVLW  09
053A:  MOVWF  xDB
....................  
....................                 ep0_tx_buffer[i] = USB_CONFIG_DESC[j]; 
053C:  CLRF   03
053E:  MOVF   xDB,W
0540:  ADDLW  A7
0542:  MOVWF  FE9
0544:  MOVLW  00
0546:  ADDWFC 03,W
0548:  MOVWF  FEA
054A:  CLRF   03
054C:  MOVF   xDC,W
054E:  MOVFF  FF2,DF
0552:  BCF    FF2.7
0554:  RCALL  0102
0556:  BTFSC  xDF.7
0558:  BSF    FF2.7
055A:  MOVWF  FEF
....................                 j++; 
055C:  INCF   xDC,F
....................                 XferEP0.nLength--; 
055E:  DECF   xB1,F
....................                 if(XferEP0.nLength == 0) { 
0560:  MOVF   xB1,F
0562:  BNZ   056C
....................                     XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer 
0564:  MOVLW  04
0566:  MOVWF  xAF
....................                     i++; 
0568:  INCF   xDB,F
....................                     break; 
056A:  BRA    0570
....................                 } 
....................             } 
056C:  INCF   xDB,F
056E:  BRA    052C
....................          break; 
0570:  BRA    0698
....................         case STRING_DESC:               // STRING descriptor 
....................             // 
....................             // NOTE: AAK  - Strings were hard-coded, so I changed them to defined values. 
....................             //              These need to match the index values found in the USB descriptor definitions. 
....................             switch (XferEP0.nStrIndex ) { 
0572:  MOVF   xB2,W
0574:  BZ    0584
0576:  XORLW  01
0578:  BZ    05C2
057A:  XORLW  03
057C:  BZ    0600
057E:  XORLW  01
0580:  BZ    063E
0582:  BRA    068A
....................                 case STR_INDX_LANG:         // Language ID string 
....................                     // Load the buffer 
....................                     for (i=0; i<8; i++)  { 
0584:  CLRF   xDB
0586:  MOVF   xDB,W
0588:  SUBLW  07
058A:  BNC   05C0
....................                         ep0_tx_buffer[i] = USB_STRING_0[j]; 
058C:  CLRF   03
058E:  MOVF   xDB,W
0590:  ADDLW  A7
0592:  MOVWF  FE9
0594:  MOVLW  00
0596:  ADDWFC 03,W
0598:  MOVWF  FEA
059A:  CLRF   03
059C:  MOVF   xDC,W
059E:  MOVFF  FF2,DF
05A2:  BCF    FF2.7
05A4:  RCALL  0140
05A6:  BTFSC  xDF.7
05A8:  BSF    FF2.7
05AA:  MOVWF  FEF
....................                         j++; 
05AC:  INCF   xDC,F
....................                         XferEP0.nLength--; 
05AE:  DECF   xB1,F
....................                         if(XferEP0.nLength == 0) { 
05B0:  MOVF   xB1,F
05B2:  BNZ   05BC
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer 
05B4:  MOVLW  04
05B6:  MOVWF  xAF
....................                             i++; 
05B8:  INCF   xDB,F
....................                             break; 
05BA:  BRA    05C0
....................                         } 
....................                     } 
05BC:  INCF   xDB,F
05BE:  BRA    0586
....................                     break; 
05C0:  BRA    068C
....................                 case STR_INDX_MFG:          // Manufacturer string 
....................                     // Load the buffer 
....................                     for (i=0; i<8; i++) { 
05C2:  CLRF   xDB
05C4:  MOVF   xDB,W
05C6:  SUBLW  07
05C8:  BNC   05FE
....................                         ep0_tx_buffer[i] = USB_STRING_1[j]; 
05CA:  CLRF   03
05CC:  MOVF   xDB,W
05CE:  ADDLW  A7
05D0:  MOVWF  FE9
05D2:  MOVLW  00
05D4:  ADDWFC 03,W
05D6:  MOVWF  FEA
05D8:  CLRF   03
05DA:  MOVF   xDC,W
05DC:  MOVFF  FF2,DF
05E0:  BCF    FF2.7
05E2:  RCALL  0154
05E4:  BTFSC  xDF.7
05E6:  BSF    FF2.7
05E8:  MOVWF  FEF
....................                         j++; 
05EA:  INCF   xDC,F
....................                         XferEP0.nLength--; 
05EC:  DECF   xB1,F
....................                         if(XferEP0.nLength == 0) { 
05EE:  MOVF   xB1,F
05F0:  BNZ   05FA
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer 
05F2:  MOVLW  04
05F4:  MOVWF  xAF
....................                             i++; 
05F6:  INCF   xDB,F
....................                             break; 
05F8:  BRA    05FE
....................                         } 
....................                     } 
05FA:  INCF   xDB,F
05FC:  BRA    05C4
....................                     break; 
05FE:  BRA    068C
....................                 case STR_INDX_PROD:             // Product Description string 
....................                     // Load the buffer 
....................                     for (i=0; i<8; i++) { 
0600:  CLRF   xDB
0602:  MOVF   xDB,W
0604:  SUBLW  07
0606:  BNC   063C
....................                         ep0_tx_buffer[i] = USB_STRING_2[j]; 
0608:  CLRF   03
060A:  MOVF   xDB,W
060C:  ADDLW  A7
060E:  MOVWF  FE9
0610:  MOVLW  00
0612:  ADDWFC 03,W
0614:  MOVWF  FEA
0616:  CLRF   03
0618:  MOVF   xDC,W
061A:  MOVFF  FF2,DF
061E:  BCF    FF2.7
0620:  RCALL  019C
0622:  BTFSC  xDF.7
0624:  BSF    FF2.7
0626:  MOVWF  FEF
....................                         j++; 
0628:  INCF   xDC,F
....................                         XferEP0.nLength--; 
062A:  DECF   xB1,F
....................                         if(XferEP0.nLength == 0) { 
062C:  MOVF   xB1,F
062E:  BNZ   0638
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer 
0630:  MOVLW  04
0632:  MOVWF  xAF
....................                             i++; 
0634:  INCF   xDB,F
....................                             break; 
0636:  BRA    063C
....................                         } 
....................                     } 
0638:  INCF   xDB,F
063A:  BRA    0602
....................                     break; 
063C:  BRA    068C
....................                 case STR_INDX_SN:               // Serial Number string 
....................                     // Load the buffer 
....................                     for (i=0; i<8; i++) { 
063E:  CLRF   xDB
0640:  MOVF   xDB,W
0642:  SUBLW  07
0644:  BNC   0688
....................                         // BUGBUG: AAK - get S/N from EEPROM 
....................                         ep0_tx_buffer[i] = USB_STRING_SN_RAM[j]; 
0646:  CLRF   03
0648:  MOVF   xDB,W
064A:  ADDLW  A7
064C:  MOVWF  01
064E:  MOVLW  00
0650:  ADDWFC 03,F
0652:  MOVFF  03,DE
0656:  CLRF   03
0658:  MOVF   xDC,W
065A:  ADDLW  8D
065C:  MOVWF  FE9
065E:  MOVLW  00
0660:  ADDWFC 03,W
0662:  MOVWF  FEA
0664:  MOVFF  FEF,DF
0668:  MOVFF  DE,FEA
066C:  MOVFF  01,FE9
0670:  MOVFF  DF,FEF
....................                         j++; 
0674:  INCF   xDC,F
....................                         XferEP0.nLength--; 
0676:  DECF   xB1,F
....................                         if(XferEP0.nLength == 0) { 
0678:  MOVF   xB1,F
067A:  BNZ   0684
....................                             XferEP0.nXferType = ZERO_LEN_XFER;  // Finish up with a zero length Xfer 
067C:  MOVLW  04
067E:  MOVWF  xAF
....................                             i++; 
0680:  INCF   xDB,F
....................                             break; 
0682:  BRA    0688
....................                         } 
....................                     } 
0684:  INCF   xDB,F
0686:  BRA    0640
....................                     break; 
0688:  BRA    068C
....................                      
....................                 default:                // Error - unknown string 
....................                     break; 
068A:  BRA    068C
....................             } 
....................             break; 
068C:  BRA    0698
....................         case ZERO_LEN_XFER:             // Zero length xfer - Sent after other descriptors are sent 
....................             i = j = 0; 
068E:  CLRF   xDC
0690:  MOVFF  DC,DB
....................             break; 
0694:  BRA    0698
....................       default: 
....................          break; 
0696:  BRA    0698
....................    } 
....................  
....................     // Adjust current position for next write 
....................     XferEP0.nCurPosition += i; 
0698:  MOVF   xDB,W
069A:  ADDWF  xB0,F
....................     for (j=0; j<i; j++) { 
069C:  CLRF   xDC
069E:  MOVF   xDB,W
06A0:  SUBWF  xDC,W
06A2:  BC    06C4
....................        usbn_write(TXD0, ep0_tx_buffer[j]); 
06A4:  CLRF   03
06A6:  MOVF   xDC,W
06A8:  ADDLW  A7
06AA:  MOVWF  FE9
06AC:  MOVLW  00
06AE:  ADDWFC 03,W
06B0:  MOVWF  FEA
06B2:  MOVFF  FEF,DD
06B6:  MOVLW  21
06B8:  MOVWF  xDE
06BA:  MOVFF  DD,DF
06BE:  RCALL  038E
....................     } 
06C0:  INCF   xDC,F
06C2:  BRA    069E
....................  
....................     return; 
.................... } 
06C4:  RETLW  00
....................  
....................  
.................... /**********************************************************************/ 
.................... /* The GET_DESCRIPTOR request is done here                            */ 
.................... /**********************************************************************/ 
.................... void getdescriptor(int8 *buf) { 
....................  
....................     // Set the information for sending this descriptor over multiple packets 
....................     XferEP0.nCurPosition = 0; 
06C6:  CLRF   xB0
....................     XferEP0.nXferType = buf[3]; 
06C8:  MOVLW  03
06CA:  ADDWF  xD9,W
06CC:  MOVWF  FE9
06CE:  MOVLW  00
06D0:  ADDWFC xDA,W
06D2:  MOVWF  FEA
06D4:  MOVFF  FEF,AF
....................     XferEP0.nStrIndex = buf[2]; 
06D8:  MOVLW  02
06DA:  ADDWF  xD9,W
06DC:  MOVWF  FE9
06DE:  MOVLW  00
06E0:  ADDWFC xDA,W
06E2:  MOVWF  FEA
06E4:  MOVFF  FEF,B2
....................  
....................    //switch on descriptor type in location 3 (high order of wValue) 
....................    switch (XferEP0.nXferType){ 
06E8:  MOVF   xAF,W
06EA:  XORLW  01
06EC:  BZ    06F8
06EE:  XORLW  03
06F0:  BZ    06FE
06F2:  XORLW  01
06F4:  BZ    0704
06F6:  BRA    0732
....................       case DEVICE_DESC:               // DEVICE descriptor 
....................          XferEP0.nLength = USB_DEVICE_DESC_LEN; 
06F8:  MOVLW  12
06FA:  MOVWF  xB1
....................          break; 
06FC:  BRA    0734
....................       case CONFIG_DESC:               // CONFIGURATION descriptor includes INTERFACE and ENDPOINT descriptors 
....................          XferEP0.nLength = USB_CONFIG_DESC_TOTAL_LEN; 
06FE:  MOVLW  2E
0700:  MOVWF  xB1
....................          break; 
0702:  BRA    0734
....................         case STRING_DESC:               // STRING descriptor 
....................                                         // index in location 2 (low order of wValue) 
....................             switch (XferEP0.nStrIndex) { 
0704:  MOVF   xB2,W
0706:  BZ    0716
0708:  XORLW  01
070A:  BZ    071C
070C:  XORLW  03
070E:  BZ    0722
0710:  XORLW  01
0712:  BZ    0728
0714:  BRA    072E
....................                 case STR_INDX_LANG:         // Language ID string 
....................                   XferEP0.nLength = USB_STRING_0_LEN; 
0716:  MOVLW  04
0718:  MOVWF  xB1
....................                     break; 
071A:  BRA    0730
....................                 case STR_INDX_MFG:          // Manufacturer string 
....................                     XferEP0.nLength = USB_STRING_1_LEN; 
071C:  MOVLW  38
071E:  MOVWF  xB1
....................                     break; 
0720:  BRA    0730
....................                 case STR_INDX_PROD:         // Product Description string 
....................                     XferEP0.nLength = USB_STRING_2_LEN; 
0722:  MOVLW  32
0724:  MOVWF  xB1
....................                     break; 
0726:  BRA    0730
....................                 case STR_INDX_SN:           // Serial Number  
....................                     XferEP0.nLength = USB_STRING_SN_LEN; 
0728:  MOVLW  12
072A:  MOVWF  xB1
....................                     break; 
072C:  BRA    0730
....................  
....................                 default:                // Error - unknown string 
....................                     return; 
072E:  BRA    075A
....................             } 
....................             break; 
0730:  BRA    0734
....................       default: 
....................          return; 
0732:  BRA    075A
....................    } 
....................  
....................     // Limit the number of bytes to the request length 
....................     if(XferEP0.nLength > buf[6]) 
0734:  MOVLW  06
0736:  ADDWF  xD9,W
0738:  MOVWF  FE9
073A:  MOVLW  00
073C:  ADDWFC xDA,W
073E:  MOVWF  FEA
0740:  MOVF   FEF,W
0742:  SUBWF  xB1,W
0744:  BZ    0758
0746:  BNC   0758
....................         XferEP0.nLength = buf[6]; 
0748:  MOVLW  06
074A:  ADDWF  xD9,W
074C:  MOVWF  FE9
074E:  MOVLW  00
0750:  ADDWFC xDA,W
0752:  MOVWF  FEA
0754:  MOVFF  FEF,B1
....................  
....................    // Start to transmit 
....................    XmitOnUSB0(); 
0758:  RCALL  04B4
.................... } 
075A:  GOTO   0A90 (RETURN)
....................  
.................... void clrfeature(void) 
.................... { 
....................     switch (ep0_rx_buffer[0]&0x03)      // Find the request target 
....................     { 
*
03C0:  MOVF   x9F,W
03C2:  ANDLW  03
03C4:  BZ    03D0
03C6:  XORLW  01
03C8:  BZ    03D2
03CA:  XORLW  03
03CC:  BZ    03D4
03CE:  BRA    04AE
....................         case 0:                         // DEVICE 
....................             break; 
03D0:  BRA    04B0
....................  
....................         case 1:                         // INTERFACE 
....................             break; 
03D2:  BRA    04B0
....................  
....................         case 2:                         // ENDPOINT 
....................             // 
....................             // Find the endpoint. Strip off direction bit 
....................             // 
....................             switch (ep0_rx_buffer[4]&0x0F) 
....................             { 
03D4:  MOVF   xA3,W
03D6:  ANDLW  0F
03D8:  BZ    03F4
03DA:  XORLW  01
03DC:  BZ    040E
03DE:  XORLW  03
03E0:  BZ    0428
03E2:  XORLW  01
03E4:  BZ    0442
03E6:  XORLW  07
03E8:  BZ    045C
03EA:  XORLW  01
03EC:  BZ    0476
03EE:  XORLW  03
03F0:  BZ    0490
03F2:  BRA    04AA
....................                 case 0: 
....................                     usbn_write(EPC0, usbn_read(EPC0) & ~STALL);     // CLEAR_STALL_EP0 
03F4:  MOVLW  20
03F6:  MOVWF  xDE
03F8:  RCALL  0324
03FA:  MOVF   01,W
03FC:  ANDLW  7F
03FE:  MOVWF  xDA
0400:  MOVLW  20
0402:  MOVWF  xDE
0404:  MOVFF  DA,DF
0408:  RCALL  038E
....................                     bit_clear(stalld,0); 
040A:  BCF    xBF.0
....................                     break; 
040C:  BRA    04AC
....................                 case 1: 
....................                     usbn_write(EPC1, usbn_read(EPC1) & ~STALL);     // CLEAR_STALL_EP1 
040E:  MOVLW  28
0410:  MOVWF  xDE
0412:  RCALL  0324
0414:  MOVF   01,W
0416:  ANDLW  7F
0418:  MOVWF  xDA
041A:  MOVLW  28
041C:  MOVWF  xDE
041E:  MOVFF  DA,DF
0422:  RCALL  038E
....................                     bit_clear(stalld,1); 
0424:  BCF    xBF.1
....................                     break; 
0426:  BRA    04AC
....................                 case 2: 
....................                     usbn_write(EPC2, usbn_read(EPC2) & ~STALL);     // CLEAR_STALL_EP2 
0428:  MOVLW  2C
042A:  MOVWF  xDE
042C:  RCALL  0324
042E:  MOVF   01,W
0430:  ANDLW  7F
0432:  MOVWF  xDA
0434:  MOVLW  2C
0436:  MOVWF  xDE
0438:  MOVFF  DA,DF
043C:  RCALL  038E
....................                     bit_clear(stalld,2); 
043E:  BCF    xBF.2
....................                     break; 
0440:  BRA    04AC
....................                 case 3: 
....................                     usbn_write(EPC3, usbn_read(EPC3) & ~STALL);     // CLEAR_STALL_EP3 
0442:  MOVLW  30
0444:  MOVWF  xDE
0446:  RCALL  0324
0448:  MOVF   01,W
044A:  ANDLW  7F
044C:  MOVWF  xDA
044E:  MOVLW  30
0450:  MOVWF  xDE
0452:  MOVFF  DA,DF
0456:  RCALL  038E
....................                     bit_clear(stalld,3); 
0458:  BCF    xBF.3
....................                     break; 
045A:  BRA    04AC
....................                 case 4: 
....................                     usbn_write(EPC4, usbn_read(EPC4) & ~STALL);     // CLEAR_STALL_EP4 
045C:  MOVLW  34
045E:  MOVWF  xDE
0460:  RCALL  0324
0462:  MOVF   01,W
0464:  ANDLW  7F
0466:  MOVWF  xDA
0468:  MOVLW  34
046A:  MOVWF  xDE
046C:  MOVFF  DA,DF
0470:  RCALL  038E
....................                     bit_clear(stalld,4); 
0472:  BCF    xBF.4
....................                     break; 
0474:  BRA    04AC
....................                 case 5: 
....................                     usbn_write(EPC5, usbn_read(EPC5) & ~STALL);     // CLEAR_STALL_EP5 
0476:  MOVLW  38
0478:  MOVWF  xDE
047A:  RCALL  0324
047C:  MOVF   01,W
047E:  ANDLW  7F
0480:  MOVWF  xDA
0482:  MOVLW  38
0484:  MOVWF  xDE
0486:  MOVFF  DA,DF
048A:  RCALL  038E
....................                     bit_clear(stalld,5); 
048C:  BCF    xBF.5
....................                     break; 
048E:  BRA    04AC
....................                 case 6: 
....................                     usbn_write(EPC6, usbn_read(EPC6) & ~STALL);     // CLEAR_STALL_EP6 
0490:  MOVLW  3C
0492:  MOVWF  xDE
0494:  RCALL  0324
0496:  MOVF   01,W
0498:  ANDLW  7F
049A:  MOVWF  xDA
049C:  MOVLW  3C
049E:  MOVWF  xDE
04A0:  MOVFF  DA,DF
04A4:  RCALL  038E
....................                     bit_clear(stalld,6); 
04A6:  BCF    xBF.6
....................                     break; 
04A8:  BRA    04AC
....................                 default: 
....................                     break; 
04AA:  BRA    04AC
....................             } 
....................             break; 
04AC:  BRA    04B0
....................  
....................         default:                        // UNDEFINED 
....................             break; 
04AE:  BRA    04B0
....................     } 
....................     return; 
.................... } 
04B0:  GOTO   0A90 (RETURN)
....................  
.................... void setconfiguration(void) 
.................... { 
....................     int8 i; 
....................  
....................     usb_cfg = ep0_rx_buffer[2];         // Save off the configuration # 
*
0872:  MOVFF  A1,C0
....................  
....................     if (ep0_rx_buffer[2] != 0)          // Non-zero = set the configuration 
0876:  MOVF   xA1,F
0878:  BZ    091E
....................     { 
....................         // First PID is DATA0 
....................         // Don't muck with EP0 
....................        for(i=1; i<USB_MAX_ENDPOINTS; i++) 
087A:  MOVLW  01
087C:  MOVWF  xD9
087E:  MOVF   xD9,W
0880:  SUBLW  04
0882:  BNC   08C0
....................         { 
....................             endpoint_stat[i].toggle_bit = 0x00; 
0884:  BCF    FD8.0
0886:  RLCF   xD9,W
0888:  CLRF   xDB
088A:  MOVWF  xDA
088C:  MOVLW  B3
088E:  ADDWF  xDA,W
0890:  MOVWF  FE9
0892:  MOVLW  00
0894:  ADDWFC xDB,W
0896:  MOVWF  FEA
0898:  CLRF   FEF
....................             endpoint_stat[i].FIFO_status = EMPTY; 
089A:  BCF    FD8.0
089C:  RLCF   xD9,W
089E:  CLRF   xDB
08A0:  MOVWF  xDA
08A2:  MOVLW  01
08A4:  ADDWF  xDA,W
08A6:  MOVWF  01
08A8:  MOVLW  00
08AA:  ADDWFC xDB,W
08AC:  MOVWF  03
08AE:  MOVF   01,W
08B0:  ADDLW  B3
08B2:  MOVWF  FE9
08B4:  MOVLW  00
08B6:  ADDWFC 03,W
08B8:  MOVWF  FEA
08BA:  CLRF   FEF
....................         } 
08BC:  INCF   xD9,F
08BE:  BRA    087E
....................  
....................         stalld = 0;                     // Nothing stalled yet 
08C0:  CLRF   xBF
....................  
....................         // Enable Pipe 0, EPC1, address 1 
....................         usbn_write(TXC1,FLUSH);         // Flush  TX1 and disable 
08C2:  MOVLW  2B
08C4:  MOVWF  xDE
08C6:  MOVLW  08
08C8:  MOVWF  xDF
08CA:  RCALL  038E
....................         usbn_write(EPC1,EP_EN+01);      // Enable EP1 at adr 1 
08CC:  MOVLW  28
08CE:  MOVWF  xDE
08D0:  MOVLW  11
08D2:  MOVWF  xDF
08D4:  RCALL  038E
....................  
....................         // Enable Pipe 1, EPC2, address 2 
....................         usbn_write(RXC1,FLUSH);         // Flush  RX1 and disable 
08D6:  MOVLW  2F
08D8:  MOVWF  xDE
08DA:  MOVLW  08
08DC:  MOVWF  xDF
08DE:  RCALL  038E
....................         usbn_write(EPC2,EP_EN+02);      // Enable EP2 at adr 2 
08E0:  MOVLW  2C
08E2:  MOVWF  xDE
08E4:  MOVLW  12
08E6:  MOVWF  xDF
08E8:  RCALL  038E
....................         usbn_write(RXC1,RX_EN);         // Enable RX1 
08EA:  MOVLW  2F
08EC:  MOVWF  xDE
08EE:  MOVLW  01
08F0:  MOVWF  xDF
08F2:  RCALL  038E
....................  
....................         // Enable Pipe 2, EPC3, address 3 
....................         usbn_write(TXC2,FLUSH);         // Flush  TX1 and disable 
08F4:  MOVLW  33
08F6:  MOVWF  xDE
08F8:  MOVLW  08
08FA:  MOVWF  xDF
08FC:  RCALL  038E
....................         usbn_write(EPC3,EP_EN+03);      // Enable EP1 at adr 3 
08FE:  MOVLW  30
0900:  MOVWF  xDE
0902:  MOVLW  13
0904:  MOVWF  xDF
0906:  RCALL  038E
....................  
....................         // Enable Pipe 3, EPC5, address 4 
....................         usbn_write(TXC3,FLUSH);         // Flush  TX1 and disable 
0908:  MOVLW  3B
090A:  MOVWF  xDE
090C:  MOVLW  08
090E:  MOVWF  xDF
0910:  RCALL  038E
....................         usbn_write(EPC5,EP_EN+04);      // Enable EP1 at adr 4 
0912:  MOVLW  38
0914:  MOVWF  xDE
0916:  MOVLW  14
0918:  MOVWF  xDF
091A:  RCALL  038E
....................  
....................     } else {                            // Zero = unconfigure the device 
091C:  BRA    094E
....................  
....................         usbn_write(EPC1,0);             // Disable EP1 
091E:  MOVLW  28
0920:  MOVWF  xDE
0922:  CLRF   xDF
0924:  RCALL  038E
....................         usbn_write(EPC2,0);             // Disable EP2 
0926:  MOVLW  2C
0928:  MOVWF  xDE
092A:  CLRF   xDF
092C:  RCALL  038E
....................         usbn_write(EPC3,0);             // Disable EP3 
092E:  MOVLW  30
0930:  MOVWF  xDE
0932:  CLRF   xDF
0934:  RCALL  038E
....................         usbn_write(EPC4,0);             // Disable EP4 
0936:  MOVLW  34
0938:  MOVWF  xDE
093A:  CLRF   xDF
093C:  RCALL  038E
....................         usbn_write(EPC5,0);             // Disable EP5 
093E:  MOVLW  38
0940:  MOVWF  xDE
0942:  CLRF   xDF
0944:  RCALL  038E
....................         usbn_write(EPC6,0);             // Disable EP6 
0946:  MOVLW  3C
0948:  MOVWF  xDE
094A:  CLRF   xDF
094C:  RCALL  038E
....................     } 
....................     return; 
.................... } 
094E:  GOTO   0A90 (RETURN)
....................  
....................  
.................... void setfeature(void) 
.................... { 
....................     switch (ep0_rx_buffer[0]&0x03)      // Find the request target 
....................     { 
0952:  MOVF   x9F,W
0954:  ANDLW  03
0956:  BZ    0962
0958:  XORLW  01
095A:  BZ    0964
095C:  XORLW  03
095E:  BZ    0966
0960:  BRA    0A2A
....................         case 0:                         // DEVICE 
....................             break; 
0962:  BRA    0A2C
....................  
....................         case 1:                         // INTERFACE 
....................             break; 
0964:  BRA    0A2C
....................  
....................         case 2:                         // ENDPOINT 
....................             // 
....................             // Find the endpoint. Strip off direction bit 
....................             // 
....................             switch (ep0_rx_buffer[4]&0x0F) 
....................             { 
0966:  MOVF   xA3,W
0968:  ANDLW  0F
096A:  BZ    0986
096C:  XORLW  01
096E:  BZ    098A
0970:  XORLW  03
0972:  BZ    09A4
0974:  XORLW  01
0976:  BZ    09BE
0978:  XORLW  07
097A:  BZ    09D8
097C:  XORLW  01
097E:  BZ    09F2
0980:  XORLW  03
0982:  BZ    0A0C
0984:  BRA    0A26
....................                 case 0: 
....................                     // Control pipes must accept setup requests even if 
....................                     // stalled. So we log the stall here, but don't actually do it 
....................                     // usbn_write(EPC0, usbn_read(EPC0) | STALL);      // STALL EP0 
....................                     bit_set(stalld,0); 
0986:  BSF    xBF.0
....................                     break; 
0988:  BRA    0A28
....................                 case 1: 
....................                     usbn_write(EPC1, usbn_read(EPC1) | STALL);      // STALL EP1 
098A:  MOVLW  28
098C:  MOVWF  xDE
098E:  RCALL  0324
0990:  MOVF   01,W
0992:  IORLW  80
0994:  MOVWF  xDA
0996:  MOVLW  28
0998:  MOVWF  xDE
099A:  MOVFF  DA,DF
099E:  RCALL  038E
....................                     bit_set(stalld,1); 
09A0:  BSF    xBF.1
....................                     break; 
09A2:  BRA    0A28
....................                 case 2: 
....................                     usbn_write(EPC2, usbn_read(EPC2) | STALL);      // STALL EP2 
09A4:  MOVLW  2C
09A6:  MOVWF  xDE
09A8:  RCALL  0324
09AA:  MOVF   01,W
09AC:  IORLW  80
09AE:  MOVWF  xDA
09B0:  MOVLW  2C
09B2:  MOVWF  xDE
09B4:  MOVFF  DA,DF
09B8:  RCALL  038E
....................                     bit_set(stalld,2); 
09BA:  BSF    xBF.2
....................                     break; 
09BC:  BRA    0A28
....................                 case 3: 
....................                     usbn_write(EPC3, usbn_read(EPC3) | STALL);      // STALL EP3 
09BE:  MOVLW  30
09C0:  MOVWF  xDE
09C2:  RCALL  0324
09C4:  MOVF   01,W
09C6:  IORLW  80
09C8:  MOVWF  xDA
09CA:  MOVLW  30
09CC:  MOVWF  xDE
09CE:  MOVFF  DA,DF
09D2:  RCALL  038E
....................                     bit_set(stalld,3); 
09D4:  BSF    xBF.3
....................                     break; 
09D6:  BRA    0A28
....................                 case 4: 
....................                     usbn_write(EPC4, usbn_read(EPC4) | STALL);      // STALL EP4 
09D8:  MOVLW  34
09DA:  MOVWF  xDE
09DC:  RCALL  0324
09DE:  MOVF   01,W
09E0:  IORLW  80
09E2:  MOVWF  xDA
09E4:  MOVLW  34
09E6:  MOVWF  xDE
09E8:  MOVFF  DA,DF
09EC:  RCALL  038E
....................                     bit_set(stalld,4); 
09EE:  BSF    xBF.4
....................                     break; 
09F0:  BRA    0A28
....................                 case 5: 
....................                     usbn_write(EPC5, usbn_read(EPC5) | STALL);      // STALL EP5 
09F2:  MOVLW  38
09F4:  MOVWF  xDE
09F6:  RCALL  0324
09F8:  MOVF   01,W
09FA:  IORLW  80
09FC:  MOVWF  xDA
09FE:  MOVLW  38
0A00:  MOVWF  xDE
0A02:  MOVFF  DA,DF
0A06:  RCALL  038E
....................                     bit_set(stalld,5); 
0A08:  BSF    xBF.5
....................                     break; 
0A0A:  BRA    0A28
....................                 case 6: 
....................                     usbn_write(EPC6, usbn_read(EPC6) | STALL);      // STALL EP6 
0A0C:  MOVLW  3C
0A0E:  MOVWF  xDE
0A10:  RCALL  0324
0A12:  MOVF   01,W
0A14:  IORLW  80
0A16:  MOVWF  xDA
0A18:  MOVLW  3C
0A1A:  MOVWF  xDE
0A1C:  MOVFF  DA,DF
0A20:  RCALL  038E
....................                     bit_set(stalld,6); 
0A22:  BSF    xBF.6
....................                     break; 
0A24:  BRA    0A28
....................                 default: 
....................                     break; 
0A26:  BRA    0A28
....................             } 
....................             break; 
0A28:  BRA    0A2C
....................  
....................         default:                        // UNDEFINED 
....................             break; 
0A2A:  BRA    0A2C
....................     } 
....................     return; 
.................... } 
0A2C:  GOTO   0A90 (RETURN)
....................  
.................... void getstatus(void) 
.................... { 
....................     switch (ep0_rx_buffer[0]&0x03)      // Find the request target 
....................     { 
*
075E:  MOVF   x9F,W
0760:  ANDLW  03
0762:  BZ    076E
0764:  XORLW  01
0766:  BZ    0778
0768:  XORLW  03
076A:  BZ    0782
076C:  BRA    085C
....................         case 0:                         // DEVICE 
....................             usbn_write(TXD0,0);         // First byte is reserved 
076E:  MOVLW  21
0770:  MOVWF  xDE
0772:  CLRF   xDF
0774:  RCALL  038E
....................             break; 
0776:  BRA    0866
....................  
....................         case 1:                         // INTERFACE 
....................             usbn_write(TXD0,0);         // First byte is reserved 
0778:  MOVLW  21
077A:  MOVWF  xDE
077C:  CLRF   xDF
077E:  RCALL  038E
....................             break; 
0780:  BRA    0866
....................  
....................         case 2:                         // ENDPOINT 
....................             // 
....................             // Find the endpoint. Strip off direction bit 
....................             // 
....................             switch (ep0_rx_buffer[4]&0x0F) 
....................             { 
0782:  MOVF   xA3,W
0784:  ANDLW  0F
0786:  BZ    07A2
0788:  XORLW  01
078A:  BZ    07BC
078C:  XORLW  03
078E:  BZ    07D6
0790:  XORLW  01
0792:  BZ    07F0
0794:  XORLW  07
0796:  BZ    080A
0798:  XORLW  01
079A:  BZ    0824
079C:  XORLW  03
079E:  BZ    083E
07A0:  BRA    0858
....................                 case 0: 
....................                     if (bit_test(stalld, 0))    // EP0 
07A2:  BTFSS  xBF.0
07A4:  BRA    07B2
....................                         usbn_write(TXD0,1); 
07A6:  MOVLW  21
07A8:  MOVWF  xDE
07AA:  MOVLW  01
07AC:  MOVWF  xDF
07AE:  RCALL  038E
....................                     else 
07B0:  BRA    07BA
....................                         usbn_write(TXD0,0); 
07B2:  MOVLW  21
07B4:  MOVWF  xDE
07B6:  CLRF   xDF
07B8:  RCALL  038E
....................                     break; 
07BA:  BRA    085A
....................                 case 1: 
....................                     if (bit_test(stalld, 1))    // EP1 
07BC:  BTFSS  xBF.1
07BE:  BRA    07CC
....................                         usbn_write(TXD0,1); 
07C0:  MOVLW  21
07C2:  MOVWF  xDE
07C4:  MOVLW  01
07C6:  MOVWF  xDF
07C8:  RCALL  038E
....................                     else 
07CA:  BRA    07D4
....................                         usbn_write(TXD0,0); 
07CC:  MOVLW  21
07CE:  MOVWF  xDE
07D0:  CLRF   xDF
07D2:  RCALL  038E
....................                     break; 
07D4:  BRA    085A
....................                 case 2: 
....................                     if (bit_test(stalld, 2))    // EP2 
07D6:  BTFSS  xBF.2
07D8:  BRA    07E6
....................                         usbn_write(TXD0,1); 
07DA:  MOVLW  21
07DC:  MOVWF  xDE
07DE:  MOVLW  01
07E0:  MOVWF  xDF
07E2:  RCALL  038E
....................                     else 
07E4:  BRA    07EE
....................                         usbn_write(TXD0,0); 
07E6:  MOVLW  21
07E8:  MOVWF  xDE
07EA:  CLRF   xDF
07EC:  RCALL  038E
....................                     break; 
07EE:  BRA    085A
....................                 case 3: 
....................                     if (bit_test(stalld, 3))    // EP3 
07F0:  BTFSS  xBF.3
07F2:  BRA    0800
....................                         usbn_write(TXD0,1); 
07F4:  MOVLW  21
07F6:  MOVWF  xDE
07F8:  MOVLW  01
07FA:  MOVWF  xDF
07FC:  RCALL  038E
....................                     else 
07FE:  BRA    0808
....................                         usbn_write(TXD0,0); 
0800:  MOVLW  21
0802:  MOVWF  xDE
0804:  CLRF   xDF
0806:  RCALL  038E
....................                     break; 
0808:  BRA    085A
....................                 case 4: 
....................                     if (bit_test(stalld, 4))    // EP4 
080A:  BTFSS  xBF.4
080C:  BRA    081A
....................                         usbn_write(TXD0,1); 
080E:  MOVLW  21
0810:  MOVWF  xDE
0812:  MOVLW  01
0814:  MOVWF  xDF
0816:  RCALL  038E
....................                     else 
0818:  BRA    0822
....................                         usbn_write(TXD0,0); 
081A:  MOVLW  21
081C:  MOVWF  xDE
081E:  CLRF   xDF
0820:  RCALL  038E
....................                     break; 
0822:  BRA    085A
....................                 case 5: 
....................                     if (bit_test(stalld, 5))    // EP5 
0824:  BTFSS  xBF.5
0826:  BRA    0834
....................                         usbn_write(TXD0,1); 
0828:  MOVLW  21
082A:  MOVWF  xDE
082C:  MOVLW  01
082E:  MOVWF  xDF
0830:  RCALL  038E
....................                     else 
0832:  BRA    083C
....................                         usbn_write(TXD0,0); 
0834:  MOVLW  21
0836:  MOVWF  xDE
0838:  CLRF   xDF
083A:  RCALL  038E
....................                     break; 
083C:  BRA    085A
....................                 case 6: 
....................                     if (bit_test(stalld, 6))    // EP6 
083E:  BTFSS  xBF.6
0840:  BRA    084E
....................                         usbn_write(TXD0,1); 
0842:  MOVLW  21
0844:  MOVWF  xDE
0846:  MOVLW  01
0848:  MOVWF  xDF
084A:  RCALL  038E
....................                     else 
084C:  BRA    0856
....................                         usbn_write(TXD0,0); 
084E:  MOVLW  21
0850:  MOVWF  xDE
0852:  CLRF   xDF
0854:  RCALL  038E
....................                     break; 
0856:  BRA    085A
....................                 default: 
....................                     break; 
0858:  BRA    085A
....................             } 
....................             break; 
085A:  BRA    0866
....................  
....................         default:                        // UNDEFINED 
....................             usbn_write(TXD0,0);         // First byte is reserved 
085C:  MOVLW  21
085E:  MOVWF  xDE
0860:  CLRF   xDF
0862:  RCALL  038E
....................             break; 
0864:  BRA    0866
....................     } 
....................     usbn_write(TXD0,0);                 // Second byte is reserved 
0866:  MOVLW  21
0868:  MOVWF  xDE
086A:  CLRF   xDF
086C:  RCALL  038E
....................     return; 
.................... } 
086E:  GOTO   0A90 (RETURN)
....................  
.................... // 
.................... // #separate means not #inline 
.................... // 
.................... #separate 
.................... void handle_setup() 
.................... { 
....................     int8 i; 
....................  
....................     if ((ep0_rx_buffer[0] & 0x60) == 0x00)      // if a standard request 
*
0A30:  MOVF   x9F,W
0A32:  ANDLW  60
0A34:  BNZ   0A92
....................     { 
....................         switch (ep0_rx_buffer[1]) {             // find request target 
0A36:  MOVF   xA0,W
0A38:  XORLW  01
0A3A:  BZ    0A56
0A3C:  XORLW  09
0A3E:  BZ    0A5C
0A40:  XORLW  0E
0A42:  BZ    0A6C
0A44:  XORLW  06
0A46:  BZ    0A74
0A48:  XORLW  05
0A4A:  BZ    0A76
0A4C:  XORLW  0C
0A4E:  BZ    0A7E
0A50:  XORLW  0A
0A52:  BZ    0A84
0A54:  BRA    0A8A
....................  
....................             case CLEAR_FEATURE:                 // CLEAR Feature (device = remote wakeip, endpoint = stall) 
....................                 i = 1; 
0A56:  MOVLW  01
0A58:  MOVWF  xD8
....................                 clrfeature(); 
0A5A:  BRA    03C0
....................                 break; 
....................  
....................             case GET_CONFIGURATION: 
....................                 i = 2; 
0A5C:  MOVLW  02
0A5E:  MOVWF  xD8
....................                 usbn_write(TXD0, usb_cfg);      // Only have one configuration - return value from setconfiguration() 
0A60:  MOVLW  21
0A62:  MOVWF  xDE
0A64:  MOVFF  C0,DF
0A68:  RCALL  038E
....................                 break; 
0A6A:  BRA    0A90
....................  
....................             case GET_DESCRIPTOR: 
....................                 getdescriptor(ep0_rx_buffer);   // Process the descriptor request 
0A6C:  CLRF   xDA
0A6E:  MOVLW  9F
0A70:  MOVWF  xD9
0A72:  BRA    06C6
....................                 break; 
....................  
....................             case GET_STATUS:                    // GET status (endpoint = stall) 
....................                 getstatus(); 
0A74:  BRA    075E
....................                 break; 
....................  
....................             case SET_ADDRESS: 
....................                 // 
....................                 // Save off the new address, but do not set until the TX handshake completes 
....................                 // 
....................                 setaddress = ep0_rx_buffer[2] | AD_EN; 
0A76:  MOVF   xA1,W
0A78:  IORLW  80
0A7A:  MOVWF  xBE
....................                 break; 
0A7C:  BRA    0A90
....................  
....................             case SET_CONFIGURATION: 
....................                 i = 3; 
0A7E:  MOVLW  03
0A80:  MOVWF  xD8
....................                 setconfiguration(); 
0A82:  BRA    0872
....................                 break; 
....................  
....................             case SET_FEATURE:                   // SET Feature (device = remote wakeip, endpoint = stall) 
....................                 i = 4; 
0A84:  MOVLW  04
0A86:  MOVWF  xD8
....................                 setfeature(); 
0A88:  BRA    0952
....................                 break; 
....................  
....................             default: 
....................                 i = 5; 
0A8A:  MOVLW  05
0A8C:  MOVWF  xD8
....................                 //unsupported standard req 
....................                 break; 
0A8E:  BRA    0A90
....................            } // end switch 
....................     } else { 
0A90:  BRA    0A96
....................         i =9; 
0A92:  MOVLW  09
0A94:  MOVWF  xD8
....................     } 
....................  
....................     // Start with TOGGLE = 1 
....................     endpoint_stat[0].toggle_bit = 0x01; 
0A96:  MOVLW  01
0A98:  MOVWF  xB3
....................     i = endpoint_stat[0].toggle_bit << 2; 
0A9A:  RLCF   xB3,W
0A9C:  MOVWF  xD8
0A9E:  RLCF   xD8,F
0AA0:  MOVLW  FC
0AA2:  ANDWF  xD8,F
....................  
....................     // the following is done for all setup packets.  Note that if 
....................     // no data was stuffed into the FIFO, the result of the fol- 
....................     // lowing will be a zero-length response. 
....................  
....................     usbn_write(TXC0, TX_EN | i);   // enable the TX (DATA1) and toggle PID 
0AA4:  MOVF   xD8,W
0AA6:  IORLW  01
0AA8:  MOVWF  xD9
0AAA:  MOVLW  23
0AAC:  MOVWF  xDE
0AAE:  MOVFF  D9,DF
0AB2:  RCALL  038E
....................  
....................     endpoint_stat[0].toggle_bit ^= 0x01; 
0AB4:  MOVLW  01
0AB6:  XORWF  xB3,F
....................     return; 
.................... } 
0AB8:  GOTO   0C5A (RETURN)
....................  
....................  
.................... void tx_1(void) 
.................... { 
....................     int8    txstat; 
....................  
....................     txstat = usbn_read(TXS1);       // Get transmitter status 
*
0C98:  MOVLW  2A
0C9A:  MOVWF  xDE
0C9C:  CALL   0324
0CA0:  MOVFF  01,D6
....................     usbn_write(TXC1, FLUSH);        // Flush the FIFO 
0CA4:  MOVLW  2B
0CA6:  MOVWF  xDE
0CA8:  MOVLW  08
0CAA:  MOVWF  xDF
0CAC:  CALL   038E
....................     // 
....................     // If a transmission has completed successfully, update the data and toggle the PID 
....................     // 
....................     if ((txstat & ACK_STAT) && (txstat & TX_DONE)) { 
0CB0:  BTFSS  xD6.6
0CB2:  BRA    0CC0
0CB4:  BTFSS  xD6.5
0CB6:  BRA    0CC0
....................         // This is where we know there's been a successful transmission to Host. 
....................         // So we can re-enable RX1 for reception. Allowing new commands 
....................         // 
....................         endpoint_stat[1].toggle_bit ^= 0x01;    // Flip the PID bit on EP1 
0CB8:  MOVLW  01
0CBA:  XORWF  xB5,F
....................         endpoint_stat[1].FIFO_status = EMPTY; 
0CBC:  CLRF   xB6
....................         // usbn_write(RXC1,RX_EN);                 // Enable command receive (EP2) 
....................     } else { 
0CBE:  BRA    0CC2
....................         // 
....................         // TODO: Resend data 
....................         endpoint_stat[1].FIFO_status = EMPTY; 
0CC0:  CLRF   xB6
....................         // usbn_write(RXC1,RX_EN);                 // Enable command receive (EP2) 
....................     } 
....................     return; 
.................... } 
0CC2:  GOTO   0DE4 (RETURN)
....................  
.................... void tx_2(void) 
.................... { 
....................     int8    txstat; 
....................  
....................     txstat = usbn_read(TXS2);       // Get transmitter status 
0CC6:  MOVLW  32
0CC8:  MOVWF  xDE
0CCA:  CALL   0324
0CCE:  MOVFF  01,D6
....................     usbn_write(TXC2, FLUSH);        // Flush the FIFO 
0CD2:  MOVLW  33
0CD4:  MOVWF  xDE
0CD6:  MOVLW  08
0CD8:  MOVWF  xDF
0CDA:  CALL   038E
....................     // 
....................     // If a transmission has completed successfully, update the data and toggle the PID 
....................     // 
....................     if ((txstat & ACK_STAT) && (txstat & TX_DONE)) { 
0CDE:  BTFSS  xD6.6
0CE0:  BRA    0CEE
0CE2:  BTFSS  xD6.5
0CE4:  BRA    0CEE
....................         // This is where we know there's been a successful transmission to Host. 
....................         endpoint_stat[2].toggle_bit ^= 0x01;    // Flip the PID bit on EP2 
0CE6:  MOVLW  01
0CE8:  XORWF  xB7,F
....................         endpoint_stat[2].FIFO_status = EMPTY; 
0CEA:  CLRF   xB8
....................     } else { 
0CEC:  BRA    0CF0
....................         endpoint_stat[2].FIFO_status = EMPTY; 
0CEE:  CLRF   xB8
....................     } 
....................     return; 
.................... } 
0CF0:  GOTO   0DE4 (RETURN)
....................  
.................... void tx_3(void) 
.................... { 
....................     int8    txstat; 
....................  
....................     txstat = usbn_read(TXS3);       // Get transmitter status 
0CF4:  MOVLW  3A
0CF6:  MOVWF  xDE
0CF8:  CALL   0324
0CFC:  MOVFF  01,D6
....................     usbn_write(TXC3, FLUSH);        // Flush the FIFO 
0D00:  MOVLW  3B
0D02:  MOVWF  xDE
0D04:  MOVLW  08
0D06:  MOVWF  xDF
0D08:  CALL   038E
....................     // 
....................     // If a transmission has completed successfully, update the data and toggle the PID 
....................     // 
....................     if ((txstat & ACK_STAT) && (txstat & TX_DONE)) { 
0D0C:  BTFSS  xD6.6
0D0E:  BRA    0D1C
0D10:  BTFSS  xD6.5
0D12:  BRA    0D1C
....................         // This is where we know there's been a successful transmission to Host. 
....................         // So we can re-enable RX1 for reception. Allowing new commands and/or data 
....................         // to be received 
....................         endpoint_stat[3].toggle_bit ^= 0x01;    // Flip the PID bit on EP3 
0D14:  MOVLW  01
0D16:  XORWF  xB9,F
....................         endpoint_stat[3].FIFO_status = EMPTY; 
0D18:  CLRF   xBA
....................     } else { 
0D1A:  BRA    0D1E
....................         endpoint_stat[3].FIFO_status = EMPTY; 
0D1C:  CLRF   xBA
....................     } 
....................     return; 
.................... } 
0D1E:  GOTO   0DE4 (RETURN)
....................  
.................... void rx_1(void) 
.................... { 
....................     int8    i, len, rxstatus, toggle; 
....................  
....................     rxstatus = usbn_read(RXS1);     // Get the receiver status 
*
0ABC:  MOVLW  2E
0ABE:  MOVWF  xDE
0AC0:  RCALL  0324
0AC2:  MOVFF  01,DA
....................  
.................... //    if(rxstatus & SETUP_R) {        // We don't do setup packets on RX1 
.................... //        usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable 
.................... //        return; 
.................... //    } 
....................  
....................     if (rxstatus & RX_ERR) {        // If Error, flush fifo and re-enable, i.e. simply ignore it 
0AC6:  BTFSS  xDA.7
0AC8:  BRA    0AE0
....................         usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable 
0ACA:  MOVLW  2F
0ACC:  MOVWF  xDE
0ACE:  MOVLW  08
0AD0:  MOVWF  xDF
0AD2:  RCALL  038E
....................         usbn_write(RXC1, RX_EN);    // Re-Enable receiving 
0AD4:  MOVLW  2F
0AD6:  MOVWF  xDE
0AD8:  MOVLW  01
0ADA:  MOVWF  xDF
0ADC:  RCALL  038E
....................         return; 
0ADE:  BRA    0B84
....................     } 
....................  
....................     len = rxstatus & 0x0F;      // Get data length 
0AE0:  MOVF   xDA,W
0AE2:  ANDLW  0F
0AE4:  MOVWF  xD9
....................  
....................     if ((rxstatus & RX_LAST) && (len != 0)) { 
0AE6:  BTFSS  xDA.4
0AE8:  BRA    0B70
0AEA:  MOVF   xD9,F
0AEC:  BZ    0B70
....................  
....................  
....................         toggle = endpoint_stat[4].toggle_bit << 5; 
0AEE:  SWAPF  xBB,W
0AF0:  MOVWF  xDB
0AF2:  RLCF   xDB,F
0AF4:  MOVLW  E0
0AF6:  ANDWF  xDB,F
....................         if ((rxstatus & RX_TOGL) == toggle) { 
0AF8:  MOVF   xDA,W
0AFA:  ANDLW  20
0AFC:  SUBWF  xDB,W
0AFE:  BNZ   0B06
....................  
....................             endpoint_stat[4].toggle_bit ^= 0x01; 
0B00:  MOVLW  01
0B02:  XORWF  xBB,F
....................         } else { 
0B04:  BRA    0B1C
....................             usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable 
0B06:  MOVLW  2F
0B08:  MOVWF  xDE
0B0A:  MOVLW  08
0B0C:  MOVWF  xDF
0B0E:  RCALL  038E
....................             usbn_write(RXC1, RX_EN);    // Re-Enable receiving 
0B10:  MOVLW  2F
0B12:  MOVWF  xDE
0B14:  MOVLW  01
0B16:  MOVWF  xDF
0B18:  RCALL  038E
....................             return; 
0B1A:  BRA    0B84
....................         } 
....................         // 
....................         // Read the data out of the FIFO 
....................         // 
....................         for (i=0; i<len; i++) 
0B1C:  CLRF   xD8
0B1E:  MOVF   xD9,W
0B20:  SUBWF  xD8,W
0B22:  BC    0B64
....................         { 
....................             if (len >= 8) {         // Cap at 8 (shovel the rest into the bit bucket) 
0B24:  MOVF   xD9,W
0B26:  SUBLW  07
0B28:  BC    0B38
....................                 rxstatus = usbn_read(RXD1); 
0B2A:  MOVLW  2D
0B2C:  MOVWF  xDE
0B2E:  CALL   0324
0B32:  MOVFF  01,DA
....................             } else {                // Stuff the data into the command buffer 
0B36:  BRA    0B60
....................                 CommandBuffer[i] = usbn_read(RXD1); 
0B38:  CLRF   03
0B3A:  MOVF   xD8,W
0B3C:  ADDLW  79
0B3E:  MOVWF  01
0B40:  MOVLW  00
0B42:  ADDWFC 03,F
0B44:  MOVFF  01,DC
0B48:  MOVFF  03,DD
0B4C:  MOVLW  2D
0B4E:  MOVWF  xDE
0B50:  CALL   0324
0B54:  MOVFF  DD,FEA
0B58:  MOVFF  DC,FE9
0B5C:  MOVFF  01,FEF
....................             } 
....................         } 
0B60:  INCF   xD8,F
0B62:  BRA    0B1E
....................  
....................         usbn_write(RXC1,FLUSH);     // Flush  RX1 and disable 
0B64:  MOVLW  2F
0B66:  MOVWF  xDE
0B68:  MOVLW  08
0B6A:  MOVWF  xDF
0B6C:  RCALL  038E
....................         // 
....................         // NOTE: Reciever will be re-enable after a response is sent 
....................         // 
....................     } else { 
0B6E:  BRA    0B84
....................         // 
....................         // Zero length packet. 
....................         // 
....................         usbn_write(RXC1, FLUSH);    // Flush  RX1 and disable 
0B70:  MOVLW  2F
0B72:  MOVWF  xDE
0B74:  MOVLW  08
0B76:  MOVWF  xDF
0B78:  RCALL  038E
....................         usbn_write(RXC1, RX_EN);    // Re-Enable receiving 
0B7A:  MOVLW  2F
0B7C:  MOVWF  xDE
0B7E:  MOVLW  01
0B80:  MOVWF  xDF
0B82:  RCALL  038E
....................     } 
....................     return; 
.................... } 
0B84:  GOTO   0C88 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usbn_get_version() 
.................... /* 
.................... /* Summary: Stictly for debugging, this function gets the revision number of the 
.................... /*          USBN960x you are connected to.  Good to see if you're connection 
.................... /*          to the USBN960x is good. 
.................... /* 
.................... /********************************************************************************/ 
.................... int8 usbn_get_version(void) { 
*
1324:  CLRF   18
1326:  BTFSC  FF2.7
1328:  BSF    18.7
132A:  BCF    FF2.7
....................    return(usbn_read(RID)); 
132C:  MOVLW  03
132E:  MOVWF  xDE
1330:  CALL   0324
1334:  BTFSC  18.7
1336:  BSF    FF2.7
1338:  MOVF   01,W
.................... } 
133A:  GOTO   185C (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr() 
.................... /* 
.................... /* Summary: Checks the Main Event interrupt register, and acts upon USB interrupts. 
.................... /*          ALT interrupt happens for the misc interrupts (reset, idle, wakeup, etc.) 
.................... /*          NAK interrupt happens when the USBN device generated a NAK to an IN or OUT/SETUP token 
.................... /*          TX interrupt happens when an IN token has happend (PIC -> HOST) 
.................... /*          RX interrupt happens when an OUT/SETUP token has happened. (HOST -> PIC). 
.................... /*          Majority of USB token handling is done through the RX event. 
.................... /* 
.................... /*          If you choose to use a polling method instead of by interrupt then call 
.................... /*          this function on any free time.  Use great care if you choose to poll: 
.................... /*          some USB requests require a response within a few milli-seconds. 
.................... /* 
.................... /********************************************************************************/ 
.................... #int_ext NOCLEAR 
.................... void usb_isr(void) 
.................... { 
....................     int8 usbn_event, i; 
....................  
....................     // Clear the interrupt manually and immediately so another can come in 
....................     // BUGBUG: Fix this 
....................     bit_clear(*0xFF2, 1); 
*
0FF2:  BCF    FF2.1
....................  
....................     // 
....................     // Loop until all ISR events are handled 
....................     // 
....................     do { 
....................         usbn_event = usbn_read(MAEV); 
0FF4:  MOVLW  06
0FF6:  MOVWF  xDE
0FF8:  CALL   0324
0FFC:  MOVFF  01,D0
....................  
....................         if (usbn_event & RX_EV)          // RX_EV - OUT and SETUP tokens (data from HOST) 
1000:  BTFSS  xD0.6
1002:  BRA    100A
....................         { 
....................             trigger_led_red(); 
1004:  CALL   0364
....................             handle_rxev(); 
1008:  BRA    0B88
....................             continue; 
....................         } 
....................  
....................         if (usbn_event & TX_EV)        // TX_EV - IN token (DEVICE sending data) 
100A:  BTFSS  xD0.2
100C:  BRA    1014
....................         { 
....................             trigger_led_red(); 
100E:  CALL   0364
....................             handle_txev(); 
1012:  BRA    0D22
....................             continue; 
....................         } 
....................  
....................         if (usbn_event & ALT)           // ALT - Resets, Idles, Suspends, etc. 
1014:  BTFSS  xD0.1
1016:  BRA    101C
....................         { 
....................             led_on_green(); 
1018:  RCALL  0DF4
....................          handle_alt(); 
101A:  BRA    0F0A
....................             continue; 
....................         } 
....................  
....................       if (usbn_event & NAK)           // NAK - PC tried to send us data, but 960x nak'd it 
101C:  BTFSS  xD0.4
101E:  BRA    1052
....................       { 
....................             // NAK on EP0 
....................          if (usbn_read(NAKEV) & 0x10) 
1020:  MOVLW  0E
1022:  MOVWF  xDE
1024:  CALL   0324
1028:  BTFSS  01.4
102A:  BRA    104C
....................          { 
....................                 // 
....................                 // IF we're in the middle of a multipacket transfer, then the 
....................                 // host has NAL'd us and wants us to stop transmitting. 
....................                 // 
....................                if ( XferEP0.nXferType != NO_XFER) { 
102C:  MOVF   xAF,F
102E:  BZ    104A
....................                     // clear any output transmission 
....................                     XferEP0.nXferType = NO_XFER; 
1030:  CLRF   xAF
....................                     // Flush xmitter, disable transmitting, enable reception 
....................                     usbn_write(TXC0, FLUSH); 
1032:  MOVLW  23
1034:  MOVWF  xDE
1036:  MOVLW  08
1038:  MOVWF  xDF
103A:  CALL   038E
....................                     usbn_write(RXC0, RX_EN); 
103E:  MOVLW  27
1040:  MOVWF  xDE
1042:  MOVLW  01
1044:  MOVWF  xDF
1046:  CALL   038E
....................                 } 
....................          } else { 
104A:  BRA    1050
....................               i = 9; 
104C:  MOVLW  09
104E:  MOVWF  xD1
....................            } 
....................             continue; 
1050:  BRA    1066
....................       } 
....................         // 
....................         // TODO: This events should not  happen 
....................         // 
....................         if (usbn_event & WARN)          // WARN - FIFO warn event (FWEV) 
1052:  BTFSS  xD0.0
1054:  BRA    105A
....................             handle_warn(); 
1056:  GOTO   0004
....................  
....................         if (usbn_event & FRAME)         // FRAME - frame counter updated 
105A:  BTFSS  xD0.3
105C:  BRA    1060
....................             handle_frame(); 
105E:  BRA    0FEA
....................  
....................         if (usbn_event & ULD)           // ULD - Unlock/Lock deteced 
1060:  BTFSS  xD0.5
1062:  BRA    1066
....................             handle_uld(); 
1064:  BRA    0FEE
....................  
....................     } while (usbn_event); 
1066:  MOVF   xD0,F
1068:  BNZ   0FF4
....................  
....................     return; 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* handle_alt() 
.................... /* 
.................... /* Summary:  This interrupt happens when an RESET, SUSPEND or RESUME event has happened. 
.................... /*            RESET - USBN device is reset, USB token handling code is put into initial state 
.................... /*            SUSPEND - Resume interrupt is enabled, USBN device put into suspended mode 
.................... /*            RESUME - Suspend interrupt is enabled, USBN device put into operational state, EP0 reception enabled 
.................... /* 
.................... /********************************************************************************/ 
106A:  GOTO   0070
.................... void handle_alt(void) { 
....................     int8 alt_event, i; 
....................  
....................     alt_event = usbn_read(ALTEV); 
*
0F0A:  MOVLW  08
0F0C:  MOVWF  xDE
0F0E:  CALL   0324
0F12:  MOVFF  01,D2
....................     alt_event &= alt_mask; 
0F16:  MOVF   xBD,W
0F18:  ANDWF  xD2,F
....................  
....................     // 
....................     // Loop through and handle all events one at a time 
....................     // 
....................     if (alt_event & ALT_RESET)                  // RESET 
0F1A:  BTFSS  xD2.6
0F1C:  BRA    0F92
....................     { 
....................         usbn_write(EPC0, usbn_read(EPC0) & ~STALL);     // CLEAR_STALL_EP0 
0F1E:  MOVLW  20
0F20:  MOVWF  xDE
0F22:  CALL   0324
0F26:  MOVF   01,W
0F28:  ANDLW  7F
0F2A:  MOVWF  xD5
0F2C:  MOVLW  20
0F2E:  MOVWF  xDE
0F30:  MOVFF  D5,DF
0F34:  CALL   038E
....................         usbn_write(NFSR, RST_ST);                       // Enter RESET state 
0F38:  MOVLW  05
0F3A:  MOVWF  xDE
0F3C:  CLRF   xDF
0F3E:  CALL   038E
....................         delay_ms(1);                                    // Must stay in RESET for at least 100 us) 
0F42:  MOVLW  01
0F44:  MOVWF  xD4
0F46:  RCALL  0DFA
....................         usbn_write(FAR, AD_EN+0);                       // set default address 0x00 
0F48:  MOVLW  04
0F4A:  MOVWF  xDE
0F4C:  MOVLW  80
0F4E:  MOVWF  xDF
0F50:  CALL   038E
....................         usbn_write(EPC0, 0x00);                         // enable EP0 only 
0F54:  MOVLW  20
0F56:  MOVWF  xDE
0F58:  CLRF   xDF
0F5A:  CALL   038E
....................  
....................        reset_usb(); 
0F5E:  RCALL  0E86
....................        // TODO: Set device state 
....................         // usb_device_reset(); 
....................  
....................         XferEP0.nXferType = NO_XFER; 
0F60:  CLRF   xAF
....................  
....................        usbn_write(NFSR, OPR_ST);                       // Enter OPERATIONAL state 
0F62:  MOVLW  05
0F64:  MOVWF  xDE
0F66:  MOVLW  02
0F68:  MOVWF  xDF
0F6A:  CALL   038E
....................  
....................         usbn_write(FAR, AD_EN+0);                       // set default address 0x00 
0F6E:  MOVLW  04
0F70:  MOVWF  xDE
0F72:  MOVLW  80
0F74:  MOVWF  xDF
0F76:  CALL   038E
....................         usbn_write(EPC0, 0x00);                         // default address 
0F7A:  MOVLW  20
0F7C:  MOVWF  xDE
0F7E:  CLRF   xDF
0F80:  CALL   038E
....................         usbn_write(RXC0, RX_EN);                        // enable reception 
0F84:  MOVLW  27
0F86:  MOVWF  xDE
0F88:  MOVLW  01
0F8A:  MOVWF  xDF
0F8C:  CALL   038E
....................  
....................     } else if (alt_event & ALT_SD3) { 
0F90:  BRA    0FE6
0F92:  BTFSS  xD2.4
0F94:  BRA    0FB4
....................         // 
....................         // Enable the RESUME interrupt 
....................         alt_mask = ALT_RESET | ALT_RESUME; 
0F96:  MOVLW  C0
0F98:  MOVWF  xBD
....................         usbn_write(ALTMSK, alt_mask); 
0F9A:  MOVLW  09
0F9C:  MOVWF  xDE
0F9E:  MOVFF  BD,DF
0FA2:  CALL   038E
....................         // 
....................         // Enter SUSPENDED state 
....................       usbn_write(NFSR, SUS_ST); 
0FA6:  MOVLW  05
0FA8:  MOVWF  xDE
0FAA:  MOVLW  03
0FAC:  MOVWF  xDF
0FAE:  CALL   038E
....................  
....................     } else if (alt_event & ALT_RESUME) { 
0FB2:  BRA    0FE6
0FB4:  BTFSS  xD2.7
0FB6:  BRA    0FE2
....................         // 
....................         // Disable the RESUME interrupt 
....................         alt_mask = ALT_SD3 | ALT_RESET; 
0FB8:  MOVLW  50
0FBA:  MOVWF  xBD
....................         usbn_write(ALTMSK, alt_mask); 
0FBC:  MOVLW  09
0FBE:  MOVWF  xDE
0FC0:  MOVFF  BD,DF
0FC4:  CALL   038E
....................         // 
....................         // Enter operation state 
....................         usbn_write(NFSR, OPR_ST); 
0FC8:  MOVLW  05
0FCA:  MOVWF  xDE
0FCC:  MOVLW  02
0FCE:  MOVWF  xDF
0FD0:  CALL   038E
....................         // 
....................         // Enable receiving 
....................         usbn_write(RXC0, RX_EN); 
0FD4:  MOVLW  27
0FD6:  MOVWF  xDE
0FD8:  MOVLW  01
0FDA:  MOVWF  xDF
0FDC:  CALL   038E
....................     } else { 
0FE0:  BRA    0FE6
....................         // 
....................         // Spurious ALT event 
....................         // 
....................         i = 99; 
0FE2:  MOVLW  63
0FE4:  MOVWF  xD3
....................     } 
....................     return; 
.................... } 
0FE6:  GOTO   1066 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* handle_txev() 
.................... /* 
.................... /* The TX interrupt happens whenever an IN token has been processed.  (PIC -> HOST). 
.................... /* 
.................... /********************************************************************************/ 
.................... void handle_txev(void) { 
....................    int8 txs; 
....................    int8 tx_event, i; 
....................    int8 event_mask = 1; 
*
0D22:  MOVLW  01
0D24:  MOVWF  xD5
....................  
....................     tx_event = usbn_read(TXEV); 
0D26:  MOVLW  0A
0D28:  MOVWF  xDE
0D2A:  CALL   0324
0D2E:  MOVFF  01,D3
....................  
....................     // 
....................     // Loop through and handle all events one at a time 
....................     // 
....................     while(tx_event) 
....................     { 
0D32:  MOVF   xD3,F
0D34:  BZ    0DF0
....................         switch(tx_event & event_mask) 
....................         { 
0D36:  MOVF   xD3,W
0D38:  ANDWF  xD5,W
0D3A:  XORLW  01
0D3C:  BZ    0D5C
0D3E:  XORLW  03
0D40:  BZ    0DDC
0D42:  XORLW  06
0D44:  BZ    0DDE
0D46:  XORLW  0C
0D48:  BZ    0DE0
0D4A:  XORLW  18
0D4C:  BZ    0DE2
0D4E:  XORLW  30
0D50:  BZ    0DE2
0D52:  XORLW  60
0D54:  BZ    0DE2
0D56:  XORLW  C0
0D58:  BZ    0DE2
0D5A:  BRA    0DE2
....................             case TX_FIFO0:              // EP0 
....................  
....................                 txs=usbn_read(TXS0);    // Read TX status for EP0 
0D5C:  MOVLW  22
0D5E:  MOVWF  xDE
0D60:  CALL   0324
0D64:  MOVFF  01,D2
....................  
....................                 if (txs & TX_DONE) 
0D68:  BTFSS  xD2.5
0D6A:  BRA    0DD6
....................                 { 
....................                     // FLUSH - disable TX 
....................                     usbn_write(TXC0, FLUSH); 
0D6C:  MOVLW  23
0D6E:  MOVWF  xDE
0D70:  MOVLW  08
0D72:  MOVWF  xDF
0D74:  CALL   038E
....................  
....................                     if (txs & ACK_STAT)     // ACK status 
0D78:  BTFSS  xD2.6
0D7A:  BRA    0DC6
....................                     { 
....................                         // 
....................                         if (XferEP0.nXferType != NO_XFER) {    // if we are processing a report then send the next part 
0D7C:  MOVF   xAF,F
0D7E:  BZ    0DA6
....................                             // Continue transmitting descriptor 
....................                            XmitOnUSB0(); 
0D80:  CALL   04B4
....................                             i = endpoint_stat[0].toggle_bit << 2; 
0D84:  RLCF   xB3,W
0D86:  MOVWF  xD4
0D88:  RLCF   xD4,F
0D8A:  MOVLW  FC
0D8C:  ANDWF  xD4,F
....................                             endpoint_stat[0].toggle_bit ^= 0x01; 
0D8E:  MOVLW  01
0D90:  XORWF  xB3,F
....................                             usbn_write(TXC0, TX_EN | i);   // enable the TX (DATA1) and toggle PID 
0D92:  MOVF   xD4,W
0D94:  IORLW  01
0D96:  MOVWF  xD6
0D98:  MOVLW  23
0D9A:  MOVWF  xDE
0D9C:  MOVFF  D6,DF
0DA0:  CALL   038E
....................  
....................                         } else { 
0DA4:  BRA    0DC4
....................  
....................                             if (setaddress) { 
0DA6:  MOVF   xBE,F
0DA8:  BZ    0DB8
....................                                 usbn_write(FAR, setaddress); 
0DAA:  MOVLW  04
0DAC:  MOVWF  xDE
0DAE:  MOVFF  BE,DF
0DB2:  CALL   038E
....................                                 setaddress = 0; 
0DB6:  CLRF   xBE
....................                             } 
....................  
....................                             usbn_write(RXC0, RX_EN);  // enable reception 
0DB8:  MOVLW  27
0DBA:  MOVWF  xDE
0DBC:  MOVLW  01
0DBE:  MOVWF  xDF
0DC0:  CALL   038E
....................                         } 
....................                     } else { 
0DC4:  BRA    0DD4
....................  
....................                         XferEP0.nXferType = NO_XFER; 
0DC6:  CLRF   xAF
....................                    /*------------------- 
....................                    * there is no ACK 
....................                    * Re-enable receiving 
....................                    *--------------------*/ 
....................                         usbn_write(RXC0, RX_EN); 
0DC8:  MOVLW  27
0DCA:  MOVWF  xDE
0DCC:  MOVLW  01
0DCE:  MOVWF  xDF
0DD0:  CALL   038E
....................                     } 
....................                 } else { 
0DD4:  BRA    0DDA
....................                     i =9; 
0DD6:  MOVLW  09
0DD8:  MOVWF  xD4
....................                 } 
....................                 break; 
0DDA:  BRA    0DE4
....................  
....................             case TX_FIFO1:              // TX event - FIFO1 
....................                 tx_1(); 
0DDC:  BRA    0C98
....................                 break; 
....................             case TX_FIFO2:              // TX event - FIFO2 
....................                 tx_2(); 
0DDE:  BRA    0CC6
....................                 break; 
....................             case TX_FIFO3:              // TX event - FIFO3 
....................                 tx_3(); 
0DE0:  BRA    0CF4
....................                 break; 
....................             case TX_UDRN0: 
....................             case TX_UDRN1: 
....................             case TX_UDRN2: 
....................             case TX_UDRN3: 
....................             default: 
....................  
.................... #if 0 
....................                 txs=usbn_read(TXS1); 
....................                 if (txs & ACK_STAT)     // ACK status 
....................                 { 
....................                     // Done transmitting data 
....................                 } else { 
....................                     // Retransmit data 
....................                 } 
.................... #endif 
....................                 break; 
0DE2:  BRA    0DE4
....................  
....................       } 
....................         tx_event &= ~event_mask; 
0DE4:  MOVF   xD5,W
0DE6:  XORLW  FF
0DE8:  ANDWF  xD3,F
....................         event_mask = event_mask << 1; 
0DEA:  BCF    FD8.0
0DEC:  RLCF   xD5,F
....................     } 
0DEE:  BRA    0D32
....................     return; 
.................... } 
0DF0:  GOTO   1066 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* handle_rxev() 
.................... /* 
.................... /* Summary: Handles the RX interrupt.  This happens when an OUT/SETUP token has happened (HOST -> PIC) 
.................... /*          and there is data in the RX buffers. 
.................... /* 
.................... /*          If there is data in the EP0 buffer and it is a SETUP token, it is processed by the 
.................... /*          SETUP token handler.  The SETUP token handler is the bulk of this code. 
.................... /* 
.................... /********************************************************************************/ 
.................... void handle_rxev(void) { 
....................     int8    rxstatus, len, i; 
....................     int8    rx_event, rx_event2; 
....................     int8    event_mask = 1; 
*
0B88:  MOVLW  01
0B8A:  MOVWF  xD7
....................  
....................     // 
....................     // Get the RX event status 
....................     // 
....................  
....................     rx_event = usbn_read(RXEV); 
0B8C:  MOVLW  0C
0B8E:  MOVWF  xDE
0B90:  CALL   0324
0B94:  MOVFF  01,D5
....................     rx_event2= rx_event; 
0B98:  MOVFF  D5,D6
....................  
....................     while(rx_event) 
....................     { 
0B9C:  MOVF   xD5,F
0B9E:  BTFSC  FD8.2
0BA0:  BRA    0C94
....................         switch(rx_event & event_mask) 
....................         { 
0BA2:  MOVF   xD5,W
0BA4:  ANDWF  xD7,W
0BA6:  XORLW  01
0BA8:  BZ    0BC8
0BAA:  XORLW  03
0BAC:  BTFSC  FD8.2
0BAE:  BRA    0C7C
0BB0:  XORLW  06
0BB2:  BTFSC  FD8.2
0BB4:  BRA    0C82
0BB6:  XORLW  0C
0BB8:  BZ    0C82
0BBA:  XORLW  18
0BBC:  BZ    0C82
0BBE:  XORLW  30
0BC0:  BZ    0C82
0BC2:  XORLW  60
0BC4:  BZ    0C82
0BC6:  BRA    0C82
....................             case RX_FIFO0:              // RX0, EP0 - Main control and Setup endpoint 
....................                 memset(ep0_rx_buffer, 0, USB_MAX_EP0_PACKET_LENGTH); 
0BC8:  CLRF   FEA
0BCA:  MOVLW  9F
0BCC:  MOVWF  FE9
0BCE:  CLRF   xD8
0BD0:  CLRF   xDA
0BD2:  MOVLW  08
0BD4:  MOVWF  xD9
0BD6:  GOTO   0372
....................                 rxstatus = usbn_read(RXS0);     // Get Receiver 0 status 
0BDA:  MOVLW  26
0BDC:  MOVWF  xDE
0BDE:  CALL   0324
0BE2:  MOVFF  01,D2
....................                 len = rxstatus & 0x0F;          // Get the length 
0BE6:  MOVF   xD2,W
0BE8:  ANDLW  0F
0BEA:  MOVWF  xD3
....................  
....................              if (rxstatus & SETUP_R)         // SETUP packet 
0BEC:  BTFSS  xD2.6
0BEE:  BRA    0C5C
....................              { 
....................  
....................                     // 
....................                     // Ignore zero length packets 
....................                     if ((rxstatus & RX_LAST) && (len == 0)) { 
0BF0:  BTFSS  xD2.4
0BF2:  BRA    0BFE
0BF4:  MOVF   xD3,F
0BF6:  BNZ   0BFE
....................                         i = 1; 
0BF8:  MOVLW  01
0BFA:  MOVWF  xD4
....................                         break; 
0BFC:  BRA    0C88
....................                     } 
....................  
.................... //                    usbn_write(EPC0, usbn_read(EPC0) & ~STALL); // clear STALL 
....................                     endpoint_stat[0].toggle_bit = 0x01;         // Initial TOGGLE status 
0BFE:  MOVLW  01
0C00:  MOVWF  xB3
....................  
....................                     // 
....................                     // Establish maximum length 
....................                     if (len > USB_MAX_EP0_PACKET_LENGTH) 
0C02:  MOVF   xD3,W
0C04:  SUBLW  08
0C06:  BC    0C0C
....................                         len = USB_MAX_EP0_PACKET_LENGTH; 
0C08:  MOVLW  08
0C0A:  MOVWF  xD3
....................                     // Read EP0 FIFO data 
....................                     for (i=0; i<len; i++) 
0C0C:  CLRF   xD4
0C0E:  MOVF   xD3,W
0C10:  SUBWF  xD4,W
0C12:  BC    0C40
....................                     { 
....................                         ep0_rx_buffer[i] = usbn_read(RXD0); 
0C14:  CLRF   03
0C16:  MOVF   xD4,W
0C18:  ADDLW  9F
0C1A:  MOVWF  01
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,F
0C20:  MOVFF  01,D8
0C24:  MOVFF  03,D9
0C28:  MOVLW  25
0C2A:  MOVWF  xDE
0C2C:  CALL   0324
0C30:  MOVFF  D9,FEA
0C34:  MOVFF  D8,FE9
0C38:  MOVFF  01,FEF
....................                     } 
0C3C:  INCF   xD4,F
0C3E:  BRA    0C0E
....................  
....................                     usbn_write(TXC0, FLUSH);    // Flush TX and RX fifo's 
0C40:  MOVLW  23
0C42:  MOVWF  xDE
0C44:  MOVLW  08
0C46:  MOVWF  xDF
0C48:  CALL   038E
....................                     usbn_write(RXC0, FLUSH); 
0C4C:  MOVLW  27
0C4E:  MOVWF  xDE
0C50:  MOVLW  08
0C52:  MOVWF  xDF
0C54:  CALL   038E
....................                     handle_setup();             // Process setup packet 
0C58:  BRA    0A30
....................                 } else { 
0C5A:  BRA    0C7A
....................                     // 
....................                     // OUT packet of Status stage in control read/write sequence 
....................                     // This signals the normal completion of a CONTROL IN 
....................                     // such as Descriptor data sent to host. 
....................                     // 
....................                     if (XferEP0.nXferType != NO_XFER) { 
0C5C:  MOVF   xAF,F
0C5E:  BZ    0C6E
....................                         XferEP0.nXferType = NO_XFER; 
0C60:  CLRF   xAF
....................                         usbn_write(TXC0, FLUSH);    // Flush TX and RX fifo's 
0C62:  MOVLW  23
0C64:  MOVWF  xDE
0C66:  MOVLW  08
0C68:  MOVWF  xDF
0C6A:  CALL   038E
....................                     } 
....................                     usbn_write(RXC0, RX_EN);        // Enable receiving on EP0 
0C6E:  MOVLW  27
0C70:  MOVWF  xDE
0C72:  MOVLW  01
0C74:  MOVWF  xDF
0C76:  CALL   038E
....................                 } 
....................                 break; 
0C7A:  BRA    0C88
....................  
....................             case RX_FIFO1: 
....................                 i = 8; 
0C7C:  MOVLW  08
0C7E:  MOVWF  xD4
....................                 rx_1(); 
0C80:  BRA    0ABC
....................                 break; 
....................  
....................             case RX_FIFO2: 
....................             case RX_FIFO3: 
....................             case RX_OVRN0: 
....................             case RX_OVRN1: 
....................             case RX_OVRN2: 
....................             default: 
....................               i = 9; 
0C82:  MOVLW  09
0C84:  MOVWF  xD4
....................                 break; 
0C86:  BRA    0C88
....................         } 
....................         rx_event &= ~event_mask; 
0C88:  MOVF   xD7,W
0C8A:  XORLW  FF
0C8C:  ANDWF  xD5,F
....................         event_mask = event_mask << 1; 
0C8E:  BCF    FD8.0
0C90:  RLCF   xD7,F
....................     } 
0C92:  BRA    0B9C
....................  
....................     return; 
.................... } 
0C94:  GOTO   1066 (RETURN)
....................  
....................  
....................  
.................... /******************************************************************************* 
.................... /* handle_warn() 
.................... /* 
.................... /* Summary: The WARN event happens when a USBN buffer reaches a desired state. 
.................... /*          This requires the user to setup the WARN setting for each buffer. 
.................... /* 
.................... /********************************************************************************/ 
.................... void handle_warn(void) { 
....................  
....................    // TODO: add code to handle when FIFOs get near full / empty 
....................  
.................... } 
*
0004:  GOTO   105A (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* handle_frame() 
.................... /* 
.................... /* Summary: Handles a FRAME event interrupt. 
.................... /*          Only relevant to users using isochronous. 
.................... /* 
.................... /********************************************************************************/ 
.................... void handle_frame(void) { 
....................  
....................    // TODO: add code if needed 
.................... } 
*
0FEA:  GOTO   1060 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* handle_uld() 
.................... /* 
.................... /* Summary:  Handles ULD interrupt. 
.................... /* 
.................... /********************************************************************************/ 
.................... void handle_uld(void) { 
....................  
....................    // TODO: add code if needed 
.................... } 
0FEE:  GOTO   1066 (RETURN)
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////// 
.................... // usbn_write(address, data) 
.................... // 
.................... // Input: address - address of USBN960x register to write to 
.................... //        data - data to write to USBN960x 
.................... // 
.................... // Summary: Writes a byte of memory to specified address on USBN960x 
.................... // 
.................... void usbn_write(int8 address, int8 data) { 
....................  
....................     // Mask off bits address 7 and 6 
....................     address &= 0x3F; 
*
038E:  MOVLW  3F
0390:  ANDWF  xDE,F
....................  
....................     // PORT D to output 
....................     set_tris_d(0x00); 
0392:  MOVLW  00
0394:  MOVWF  F95
....................     // Write the register address 
....................     PORT_D = address; 
0396:  MOVFF  DE,F83
....................     // A0 = 1 (register access) 
....................     output_high(USB_A0); 
039A:  BSF    F8A.4
....................     // Chip select enable / Write enable 
....................     output_low(USB_CS); 
039C:  BCF    F89.2
....................     output_low(USB_WR); 
039E:  BCF    F8A.3
....................     // Wait about 1 clock for the data to be latched into the USBN9603 
.................... #asm 
....................     nop 
03A0:  NOP   
.................... #endasm 
....................     // Chip select disable 
....................     output_high(USB_CS); 
03A2:  BSF    F89.2
....................     // Write disable 
....................     output_high(USB_WR); 
03A4:  BSF    F8A.3
....................     // Wait at least 3 clocks before next access to USBN9603 
.................... #asm 
....................     nop 
03A6:  NOP   
....................     nop 
03A8:  NOP   
....................     nop 
03AA:  NOP   
.................... #endasm 
....................  
....................     // A0 = 0 (data access) 
....................     output_low(USB_A0); 
03AC:  BCF    F8A.4
....................     // Write the data 
....................     PORT_D = data; 
03AE:  MOVFF  DF,F83
....................     // Chip select enable / Write enable 
....................     output_low(USB_CS); 
03B2:  BCF    F89.2
....................     output_low(USB_WR); 
03B4:  BCF    F8A.3
....................     // Wait about 1 clock for the data to be valid out of the USBN9603 
.................... #asm 
....................     nop 
03B6:  NOP   
.................... #endasm 
....................     // Chip select, Write, Read disable 
....................     output_high(USB_CS); 
03B8:  BSF    F89.2
....................     output_high(USB_RD); 
03BA:  BSF    F8A.2
....................     output_high(USB_WR); 
03BC:  BSF    F8A.3
....................     return; 
.................... } 
03BE:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////// 
.................... // usbn_read(address) 
.................... // 
.................... // Input:   address - address of USBN960x register to read 
.................... // Output:  data (byte) in specified address. 
.................... // 
.................... // Summary: Reads a byte of memory from specified address on USBN960x 
.................... // 
.................... int8 usbn_read(int8 address) { 
....................     int8 data; 
....................  
....................     // Mask off bits address 7 and 6 
....................     address &= 0x3F; 
*
0324:  MOVLW  3F
0326:  ANDWF  xDE,F
....................  
....................     // PORT D to output 
....................     set_tris_d(0x00); 
0328:  MOVLW  00
032A:  MOVWF  F95
....................     // Write the register address 
....................     PORT_D = address; 
032C:  MOVFF  DE,F83
....................     // A0 = 1 (register access) 
....................     output_high(USB_A0); 
0330:  BSF    F8A.4
....................     // Chip select enable / Write enable 
....................     output_low(USB_CS); 
0332:  BCF    F89.2
....................     output_low(USB_WR); 
0334:  BCF    F8A.3
....................     // Wait about 1 clock for the data to be latched into the USBN9603 
.................... #asm 
....................     nop 
0336:  NOP   
.................... #endasm 
....................     // Chip select disable 
....................     output_high(USB_CS); 
0338:  BSF    F89.2
....................     // Write disable 
....................     output_high(USB_WR); 
033A:  BSF    F8A.3
....................     // Wait at least 3 clocks before next access to USBN9603 
.................... #asm 
....................     nop 
033C:  NOP   
....................     nop 
033E:  NOP   
....................     nop 
0340:  NOP   
.................... #endasm 
....................  
....................     // Now we can issue the data command 
....................     // PORT D to input 
....................     set_tris_d(0xFF); 
0342:  MOVLW  FF
0344:  MOVWF  F95
....................     // A0 = 0 (data access) 
....................     output_low(USB_A0); 
0346:  BCF    F8A.4
....................     // Chip select enable / Read enable 
....................     output_low(USB_CS); 
0348:  BCF    F89.2
....................     output_low(USB_RD); 
034A:  BCF    F8A.2
....................     // Wait about 1 clock for the data to be valid out of the USBN9603 
.................... #asm 
....................     nop 
034C:  NOP   
.................... #endasm 
....................     // Read the data in 
....................     data = PORT_D; 
034E:  MOVFF  F83,DF
....................  
....................     // Chip select, Write, Read disable 
....................     output_high(USB_CS); 
0352:  BSF    F89.2
....................     output_high(USB_RD); 
0354:  BSF    F8A.2
....................     output_high(USB_WR); 
0356:  BSF    F8A.3
....................  
....................     // Wait at least 3 clock cycles before next USBN9603 access 
....................     // This is implied here. 
....................     return(data); 
0358:  MOVFF  DF,01
.................... } 
035C:  RETLW  00
....................  
....................  
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Read EEPROM 
.................... // The PIC18F6520 has an internal EEPROM 
.................... // 
.................... #separate 
.................... int8 rd_eeprom(int8 address) 
.................... { 
....................     int8    data; 
....................  
....................     EEADRH = 0;         // Upper bits of 10 bit address = 0 
*
10D0:  CLRF   FAA
....................     EEADR = address;    // Lower bits of 10 bit address = address 
10D2:  MOVFF  CC,FA9
....................     EECON1 = 0x00;      // Clear EEPGD and CFGS (access EEPROM) 
10D6:  CLRF   FA6
....................     EECON1 = 0x01;      // Initiate read RD=1 
10D8:  MOVLW  01
10DA:  MOVWF  FA6
....................     data = EEDATA;      // Read the data out of the EEPROM 
10DC:  MOVFF  FA8,CD
....................     return (data); 
10E0:  MOVFF  CD,01
.................... } 
10E4:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Write EEPROM 
.................... // The PIC18F6520 has an internal EEPROM 
.................... // 
.................... #separate 
.................... void wr_eeprom(int8 address, int8 data) 
.................... { 
....................     int8 i; 
....................      
....................     // Wait for any previous WRITE to complete 
....................     do { 
....................         delay_cycles(5); 
*
11C0:  BRA    11C2
11C2:  BRA    11C4
11C4:  NOP   
....................         i = EECON1; 
11C6:  MOVFF  FA6,CA
....................     } while (i & 0x02);         // Bit 1 = WR (write status) 
11CA:  BTFSC  xCA.1
11CC:  BRA    11C0
....................  
....................     EEADRH = 0;         // Upper bits of 10 bit address = 0 
11CE:  CLRF   FAA
....................     EEADR = address;    // Lower bits of 10 bit address = address 
11D0:  MOVFF  C8,FA9
....................     EEDATA = data;      // Data to write to the EEPROM 
11D4:  MOVFF  C9,FA8
....................     EECON1 = 0x00;      // Clear EEPGD and CFGS (access EEPROM) 
11D8:  CLRF   FA6
....................     EECON1 = 0x04;      // Set write enable - WREN 
11DA:  MOVLW  04
11DC:  MOVWF  FA6
....................  
....................     bit_clear(INTCON, 7); // bcf     0x0B, 7     ; Disable INT's INTCON GIE 
11DE:  BCF    FF2.7
....................     // Do not change a single line in the following #asm block 
....................     // The assembly output must match the Microchip documentation exactly 
....................     // and changing anything will screw it up since the compiler shoves 
....................     // its crap in-line also. 
.................... #asm 
....................     movlw   0x55        ; Write unlock sequence 
11E0:  MOVLW  55
....................     movwf   EECON2      ; EECON2 
11E2:  MOVWF  FA7
....................     movlw   0xAA 
11E4:  MOVLW  AA
....................     movwf   EECON2      ; EECON2 
11E6:  MOVWF  FA7
....................     bsf     EECON1, 1   ; Initiate write - WR 
11E8:  BSF    FA6.1
.................... #endasm 
....................  
....................     bit_set(INTCON, 7);// bsf     0x0B, 7     ; enable INT's - INTCON GIE 
11EA:  BSF    FF2.7
....................     EECON1 = 0x00;      // WREN 
11EC:  CLRF   FA6
....................     return; 
.................... } 
11EE:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Output an updated DAC value in LTC1448 
.................... // 
.................... // DAC output values in DAC_CH0 and DAC_CH1. These 12 bit values need to be put 
.................... // together into 3 bytes (24 bits) for the DAC output update sequence. 
.................... // 
.................... void update_dac(void) 
.................... { 
....................     int8    data; 
....................  
....................     // Check and set SPI mode 
....................     if (SpiMode != SPI_DAC) 
*
1262:  MOVF   2A,W
1264:  SUBLW  02
1266:  BZ    126E
....................         setup_spi_mode(SPI_DAC); 
1268:  MOVLW  02
126A:  MOVWF  xCD
126C:  RCALL  124C
....................  
....................     output_low(DAC_CS);     // Select the D/A converter 
126E:  BCF    F89.1
....................  
....................     data = ((DAC_CH0 & 0x0FF0) >> 4); 
1270:  MOVF   31,W
1272:  ANDLW  F0
1274:  MOVWF  xC8
1276:  MOVF   32,W
1278:  ANDLW  0F
127A:  MOVWF  xC9
127C:  RRCF   xC9,W
127E:  MOVWF  03
1280:  RRCF   xC8,W
1282:  MOVWF  02
1284:  RRCF   03,F
1286:  RRCF   02,F
1288:  RRCF   03,F
128A:  RRCF   02,F
128C:  RRCF   03,F
128E:  RRCF   02,F
1290:  MOVFF  02,C7
....................     spi_write(data); 
1294:  MOVF   FC9,W
1296:  MOVFF  C7,FC9
129A:  RRCF   FC7,W
129C:  BNC   129A
....................  
....................     data = ((DAC_CH0 & 0x000F) << 4); 
129E:  MOVF   31,W
12A0:  ANDLW  0F
12A2:  MOVWF  xC8
12A4:  CLRF   xC9
12A6:  RLCF   xC8,W
12A8:  MOVWF  02
12AA:  RLCF   xC9,W
12AC:  MOVWF  03
12AE:  RLCF   02,F
12B0:  RLCF   03,F
12B2:  RLCF   02,F
12B4:  RLCF   03,F
12B6:  RLCF   02,F
12B8:  RLCF   03,F
12BA:  MOVLW  F0
12BC:  ANDWF  02,F
12BE:  MOVFF  02,C7
....................     data = data | ((DAC_CH1 & 0x0F00) >> 8); 
12C2:  CLRF   xC8
12C4:  MOVF   34,W
12C6:  ANDLW  0F
12C8:  IORWF  xC7,F
....................     spi_write(data); 
12CA:  MOVF   FC9,W
12CC:  MOVFF  C7,FC9
12D0:  RRCF   FC7,W
12D2:  BNC   12D0
....................  
....................     data = (DAC_CH1 & 0x00FF); 
12D4:  MOVFF  33,C7
....................     spi_write(data); 
12D8:  MOVF   FC9,W
12DA:  MOVFF  C7,FC9
12DE:  RRCF   FC7,W
12E0:  BNC   12DE
....................  
....................     output_high(DAC_CS);    // De-Select the D/A converter 
12E2:  BSF    F89.1
....................     return; 
.................... } 
12E4:  RETLW  00
....................  
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Acquire an A/D value from ADS7871 
.................... // 
.................... int16 acquire_adc(int8 control) 
.................... { 
....................     int16   ad_sample = 0; 
*
1512:  CLRF   xCA
1514:  CLRF   xCB
....................     int8    data; 
....................  
....................     // Check and configure SPI if needed 
....................     if (SpiMode != SPI_ADC_FAST) 
1516:  MOVF   2A,W
1518:  SUBLW  02
151A:  BZ    1522
....................         setup_spi_mode(SPI_ADC_FAST); 
151C:  MOVLW  02
151E:  MOVWF  xCD
1520:  RCALL  124C
....................  
....................     output_low(AD_CS);          // Select the A/D converter 
1522:  BCF    F89.0
....................  
....................     data = control | 0x80;      // OR in Direct Mode (Start Conversion) in bit 7 
1524:  MOVF   xC9,W
1526:  IORLW  80
1528:  MOVWF  xCC
....................     spi_write(data); 
152A:  MOVF   FC9,W
152C:  MOVFF  CC,FC9
1530:  RRCF   FC7,W
1532:  BNC   1530
....................  
....................     while (PORT_B & 0x02)       // Wait for the conversion to complete (BUSY = 0) 
....................     { 
1534:  BTFSS  F81.1
1536:  BRA    1540
....................         ad_sample++; 
1538:  INCF   xCA,F
153A:  BTFSC  FD8.2
153C:  INCF   xCB,F
....................     } 
153E:  BRA    1534
....................      
....................     // 8 bit read = (0x40 | Addr) 
....................     spi_write(0x40 | 0x01); 
1540:  MOVF   FC9,W
1542:  MOVLW  41
1544:  MOVWF  FC9
1546:  RRCF   FC7,W
1548:  BNC   1546
....................     data = spi_read(0);         // A/D Sample Bits 11-4 
154A:  MOVF   FC9,W
154C:  CLRF   FC9
154E:  RRCF   FC7,W
1550:  BNC   154E
1552:  MOVFF  FC9,CC
....................     ad_sample = data;           // To get around shitty type conversion 
1556:  CLRF   xCB
1558:  MOVFF  CC,CA
....................     ad_sample = (ad_sample << 4); 
155C:  RLCF   xCA,F
155E:  RLCF   xCB,F
1560:  RLCF   xCA,F
1562:  RLCF   xCB,F
1564:  RLCF   xCA,F
1566:  RLCF   xCB,F
1568:  RLCF   xCA,F
156A:  RLCF   xCB,F
156C:  MOVLW  F0
156E:  ANDWF  xCA,F
....................     spi_write(0x40 | 0x00); 
1570:  MOVF   FC9,W
1572:  MOVLW  40
1574:  MOVWF  FC9
1576:  RRCF   FC7,W
1578:  BNC   1576
....................     data = spi_read(0);         // A/D Sample Bits 3-0 
157A:  MOVF   FC9,W
157C:  CLRF   FC9
157E:  RRCF   FC7,W
1580:  BNC   157E
1582:  MOVFF  FC9,CC
....................     // TODO: Check for OVR (Bit 0) 
....................     ad_sample |= (data >> 4); 
1586:  SWAPF  xCC,W
1588:  MOVWF  00
158A:  MOVLW  0F
158C:  ANDWF  00,F
158E:  MOVF   00,W
1590:  IORWF  xCA,F
....................     output_high(AD_CS);         // De-Select the A/D converter 
1592:  BSF    F89.0
....................     return (ad_sample); 
1594:  MOVFF  CA,01
1598:  MOVFF  CB,02
.................... } 
159C:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // config_adc(void) 
.................... // 
.................... // Configures the A/D converter for usage 
.................... // 
.................... void config_adc(void) 
.................... { 
....................     int8    data; 
....................  
....................     // Check and set SPI mode 
....................     if (SpiMode != SPI_ADC_FAST) 
*
12E6:  MOVF   2A,W
12E8:  SUBLW  02
12EA:  BZ    12F2
....................         setup_spi_mode(SPI_ADC_FAST); 
12EC:  MOVLW  02
12EE:  MOVWF  xCD
12F0:  RCALL  124C
....................  
....................     output_low(AD_CS);          // Select the A/D converter 
12F2:  BCF    F89.0
....................  
....................     // 8 bit read = (0x40 | Addr) 
....................  
....................     spi_write(0x40 | 31);       // Read the ID register 
12F4:  MOVF   FC9,W
12F6:  MOVLW  5F
12F8:  MOVWF  FC9
12FA:  RRCF   FC7,W
12FC:  BNC   12FA
....................     data = spi_read(0); 
12FE:  MOVF   FC9,W
1300:  CLRF   FC9
1302:  RRCF   FC7,W
1304:  BNC   1302
1306:  MOVFF  FC9,C7
....................  
....................     // Check if the chip has a valid ID 
.................... // BUGBUG: Removed since a Digital only unit does not have a ADS7871 
.................... //    if (data != 1) 
.................... //    { 
.................... //        while (TRUE) 
.................... //        { 
.................... //            restart_wdt(); 
.................... //            led_on_green(); 
.................... //        } 
.................... //    } 
....................  
....................     // 8 bit write = (0x00 | Addr) 
....................  
....................     // Configre the Buffer driver (turn on) Reg Addr 7, Bit 2 (ON) 
....................     spi_write(0x00 | 7); 
130A:  MOVF   FC9,W
130C:  MOVLW  07
130E:  MOVWF  FC9
1310:  RRCF   FC7,W
1312:  BNC   1310
....................     spi_write(0x04); 
1314:  MOVF   FC9,W
1316:  MOVLW  04
1318:  MOVWF  FC9
131A:  RRCF   FC7,W
131C:  BNC   131A
....................  
....................     output_high(AD_CS);         // De-Select the A/D converter 
131E:  BSF    F89.0
....................  
....................     return; 
.................... } 
1320:  GOTO   183E (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Turn LED on (RED) 
.................... // 
.................... void led_on_red(void) 
.................... { 
....................     output_high(LED_RED); 
*
035E:  BSF    F8F.3
....................     output_low(LED_GREEN); 
0360:  BCF    F8F.4
....................     return; 
.................... } 
0362:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Turn LED on (GREEN) 
.................... // 
.................... void led_on_green(void) 
.................... { 
....................     output_high(LED_GREEN); 
*
0DF4:  BSF    F8F.4
....................     output_low(LED_RED); 
0DF6:  BCF    F8F.3
....................     return; 
.................... } 
0DF8:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Turn LED off 
.................... // 
.................... void led_off(void) 
.................... { 
....................     output_low(LED_RED); 
*
107E:  BCF    F8F.3
....................     output_low(LED_GREEN); 
1080:  BCF    F8F.4
....................     return; 
.................... } 
1082:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Turn LED on (RED) only if it was previously GREEN 
.................... // 
.................... #separate 
.................... void trigger_led_red(void) 
.................... { 
....................     // Only start the Red sequence if it was Green 
....................     if (LedGreenFlag) { 
*
0364:  MOVF   2D,F
0366:  BZ    0370
....................         LedGreenFlag = 0; 
0368:  CLRF   2D
....................         LedCount = 90;          // To make a faster Red LED blink, put a value here (0 ... 100) 
036A:  MOVLW  5A
036C:  MOVWF  2E
....................                                 // Full blink gets a 0 
....................         led_on_red(); 
036E:  RCALL  035E
....................     } 
.................... } 
0370:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Write the digital output to PORT1 
.................... // PORT_E 
.................... // 
.................... #separate 
.................... void write_port1(int8 value) 
.................... { 
....................     // Expander inversion 
....................     if (EEFlags & EXPANDER_FLAG) 
*
1218:  BTFSS  19.0
121A:  BRA    1220
....................         value = value ^ 0xFF; 
121C:  MOVLW  FF
121E:  XORWF  xC7,F
....................  
....................     // Write port data out 
....................     PORT_E = value; 
1220:  MOVFF  C7,F84
....................     return; 
.................... } 
1224:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Read the digital input of PORT1 
.................... // PORT_E 
.................... // 
.................... #separate 
.................... int8 read_port1(void) 
.................... { 
....................     int8 value; 
....................  
....................     // Read port data in 
....................     value = PORT_E; 
*
15D2:  MOVFF  F84,C7
....................  
....................     // Expander inversion 
....................     if (EEFlags & EXPANDER_FLAG) 
15D6:  BTFSS  19.0
15D8:  BRA    15DE
....................         value = value ^ 0xFF; 
15DA:  MOVLW  FF
15DC:  XORWF  xC7,F
....................     return (value); 
15DE:  MOVFF  C7,01
.................... } 
15E2:  GOTO   1A7A (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Write the digital output to PORT2 
.................... // PORT_F 
.................... // 
.................... void write_port2(int8 value) 
.................... { 
....................     // Expander inversion 
....................     if (EEFlags & EXPANDER_FLAG) 
*
1226:  BTFSS  19.0
1228:  BRA    122E
....................         value = value ^ 0xFF; 
122A:  MOVLW  FF
122C:  XORWF  xC7,F
....................     // Write port data out 
....................     PORT_F = value; 
122E:  MOVFF  C7,F85
....................     return; 
.................... } 
1232:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Read the digital input of PORT2 
.................... // PORT_F 
.................... // 
.................... int8 read_port2(void) 
.................... { 
....................     int8 value; 
....................  
....................     // Read port data in 
....................     value = PORT_F; 
*
164C:  MOVFF  F85,C7
....................  
....................     // Expander inversion 
....................     if (EEFlags & EXPANDER_FLAG) 
1650:  BTFSS  19.0
1652:  BRA    1658
....................         value = value ^ 0xFF; 
1654:  MOVLW  FF
1656:  XORWF  xC7,F
....................     return (value); 
1658:  MOVFF  C7,01
.................... } 
165C:  GOTO   1A8C (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Set the data direction of PORT1 
.................... // PORT_E 
.................... // 
.................... void set_dir_port1(int8 direction) 
.................... { 
....................     Port1_Dir = direction; 
*
11F0:  MOVFF  C7,2F
....................     // Save to EEPROM 
....................     wr_eeprom(EEPROM_DIR_PORT1, Port1_Dir); 
11F4:  MOVLW  02
11F6:  MOVWF  xC8
11F8:  MOVFF  2F,C9
11FC:  RCALL  11C0
....................     set_tris_e(direction); 
11FE:  MOVFF  C7,F96
....................     return; 
.................... } 
1202:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Returns the data line direction for Port1. 
.................... // Per digital line (bit) 1=IN and 0=OUT 
.................... //  
.................... int8 get_dir_port1(void) 
.................... { 
....................     return (Port1_Dir); 
*
16E8:  MOVF   2F,W
16EA:  MOVWF  01
.................... } 
16EC:  GOTO   1B56 (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Set the data direction of PORT2 
.................... // PORT_F 
.................... // 
.................... void set_dir_port2(int8 direction) 
.................... { 
....................     Port2_Dir = direction; 
*
1204:  MOVFF  C7,30
....................     // Save to EEPROM 
....................     wr_eeprom(EEPROM_DIR_PORT2, Port2_Dir); 
1208:  MOVLW  03
120A:  MOVWF  xC8
120C:  MOVFF  30,C9
1210:  RCALL  11C0
....................     set_tris_f(Port2_Dir); 
1212:  MOVFF  30,F97
....................     return; 
.................... } 
1216:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Returns the data line direction for Port2. 
.................... // Per digital line (bit) 1=IN and 0=OUT 
.................... //  
.................... int8 get_dir_port2(void) 
.................... { 
....................     return (Port2_Dir); 
*
16F0:  MOVF   30,W
16F2:  MOVWF  01
.................... } 
16F4:  GOTO   1B68 (RETURN)
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Converts 2 hexadecimal ASCII characters pointed to *ptr to a binary value 
.................... // 
.................... #separate 
.................... int8 hex_to_bin(int8 *ptr) 
.................... { 
....................     int8 value, i; 
....................     int8 *tmp_ptr; 
....................  
....................     tmp_ptr = ptr; 
*
1660:  MOVFF  C8,CC
1664:  MOVFF  C7,CB
....................  
....................     // MSB conversion 
....................     for (i=0; i<16; i++) { 
1668:  CLRF   xCA
166A:  MOVF   xCA,W
166C:  SUBLW  0F
166E:  BNC   16A4
....................         if (BIN_TO_HEX_TBL[i] == *tmp_ptr) { 
1670:  CLRF   03
1672:  MOVF   xCA,W
1674:  MOVFF  FF2,CD
1678:  BCF    FF2.7
167A:  CALL   00B6
167E:  BTFSC  xCD.7
1680:  BSF    FF2.7
1682:  MOVWF  xCE
1684:  MOVFF  CC,03
1688:  MOVFF  CB,FE9
168C:  MOVFF  CC,FEA
1690:  MOVF   FEF,W
1692:  SUBWF  xCE,W
1694:  BNZ   16A0
....................             value = i * 16; 
1696:  MOVF   xCA,W
1698:  MULLW  10
169A:  MOVFF  FF3,C9
....................             break; 
169E:  BRA    16A4
....................         } 
....................     } 
16A0:  INCF   xCA,F
16A2:  BRA    166A
....................  
....................     // LSB conversion 
....................     tmp_ptr++; 
16A4:  INCF   xCB,F
16A6:  BTFSC  FD8.2
16A8:  INCF   xCC,F
....................     for (i=0; i<16; i++) { 
16AA:  CLRF   xCA
16AC:  MOVF   xCA,W
16AE:  SUBLW  0F
16B0:  BNC   16E2
....................         if (BIN_TO_HEX_TBL[i] == *tmp_ptr) { 
16B2:  CLRF   03
16B4:  MOVF   xCA,W
16B6:  MOVFF  FF2,CD
16BA:  BCF    FF2.7
16BC:  CALL   00B6
16C0:  BTFSC  xCD.7
16C2:  BSF    FF2.7
16C4:  MOVWF  xCE
16C6:  MOVFF  CC,03
16CA:  MOVFF  CB,FE9
16CE:  MOVFF  CC,FEA
16D2:  MOVF   FEF,W
16D4:  SUBWF  xCE,W
16D6:  BNZ   16DE
....................             value = value + i; 
16D8:  MOVF   xCA,W
16DA:  ADDWF  xC9,F
....................             break; 
16DC:  BRA    16E2
....................         } 
....................     } 
16DE:  INCF   xCA,F
16E0:  BRA    16AC
....................  
....................     return (value); 
16E2:  MOVFF  C9,01
.................... } 
16E6:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Converts binary value to two hexadecimal ASCII characters 
.................... // 
.................... #separate 
.................... void bin_to_hex(int8 value, int8 *ptr) 
.................... { 
....................     int8 tbl_index; 
....................     int8 *tmp_ptr; 
....................  
....................     tmp_ptr = ptr; 
*
15E6:  MOVFF  C9,CC
15EA:  MOVFF  C8,CB
....................  
....................     // MSB first 
....................     tbl_index = value; 
15EE:  MOVFF  C7,CA
....................     tbl_index = tbl_index & 0xF0; 
15F2:  MOVLW  F0
15F4:  ANDWF  xCA,F
....................     tbl_index = tbl_index >> 4; 
15F6:  SWAPF  xCA,F
15F8:  MOVLW  0F
15FA:  ANDWF  xCA,F
....................     *tmp_ptr = BIN_TO_HEX_TBL[tbl_index]; 
15FC:  MOVFF  CC,03
1600:  MOVFF  CB,FE9
1604:  MOVFF  CC,FEA
1608:  CLRF   03
160A:  MOVF   xCA,W
160C:  MOVFF  FF2,CF
1610:  BCF    FF2.7
1612:  CALL   00B6
1616:  BTFSC  xCF.7
1618:  BSF    FF2.7
161A:  MOVWF  FEF
....................     // LSB last 
....................     tbl_index = value; 
161C:  MOVFF  C7,CA
....................     tbl_index = tbl_index & 0x0F; 
1620:  MOVLW  0F
1622:  ANDWF  xCA,F
....................     tmp_ptr++; 
1624:  INCF   xCB,F
1626:  BTFSC  FD8.2
1628:  INCF   xCC,F
....................     *tmp_ptr = BIN_TO_HEX_TBL[tbl_index]; 
162A:  MOVFF  CC,03
162E:  MOVFF  CB,FE9
1632:  MOVFF  CC,FEA
1636:  CLRF   03
1638:  MOVF   xCA,W
163A:  MOVFF  FF2,CF
163E:  BCF    FF2.7
1640:  CALL   00B6
1644:  BTFSC  xCF.7
1646:  BSF    FF2.7
1648:  MOVWF  FEF
....................     return; 
.................... } 
164A:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // RTCC/Timer0 interrupt - pulse counter is redirected to Timer0 
.................... // 
.................... #int_timer0 
.................... void timer0_isr(void) 
.................... { 
....................     PulseCount = PulseCount + 0x100; 
*
106E:  MOVLW  01
1070:  ADDWF  36,F
1072:  MOVLW  00
1074:  ADDWFC 37,F
1076:  ADDWFC 38,F
....................     return; 
.................... } 
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Timer1 interrupt - 10 milliseconds 
.................... // 
1078:  BCF    FF2.2
107A:  GOTO   0070
.................... #int_timer1 
.................... void timer1_isr(void) 
.................... { 
.................... // (40Mhz Clk / 4) = 10 Mhz source to Timer1 
.................... // 10ms = 65536-(.01/(1/(10000000/4))) = 0x9E58 
....................     set_timer1(0x9E58); 
*
1084:  MOVLW  9E
1086:  MOVWF  FCF
1088:  MOVLW  58
108A:  MOVWF  FCE
....................  
....................     LedCount++; 
108C:  INCF   2E,F
....................     if (LedCount < 100) {                   // One second count (LED on) 
108E:  MOVF   2E,W
1090:  SUBLW  63
1092:  BNC   10AA
....................         if (LedCount & 1) { 
1094:  BTFSS  2E.0
1096:  BRA    10A6
....................             if (LedGreenFlag)               // LED on (Red or Green) 
1098:  MOVF   2D,F
109A:  BZ    10A0
....................                 led_on_green(); 
109C:  RCALL  0DF4
....................             else 
109E:  BRA    10A4
....................                 led_on_red(); 
10A0:  CALL   035E
....................         } else { 
10A4:  BRA    10A8
....................             led_off();                      // Toggle off every other cycle (100 Hz) 
10A6:  RCALL  107E
....................         } 
....................     } else { 
10A8:  BRA    10CA
....................         led_off(); 
10AA:  RCALL  107E
....................         if (LedGreenFlag) { 
10AC:  MOVF   2D,F
10AE:  BZ    10BE
....................             // Green LED timing 
....................             if (LedCount > 200) {               // Two second count (LED off) 
10B0:  MOVF   2E,W
10B2:  SUBLW  C8
10B4:  BC    10BC
....................                 LedCount = 0; 
10B6:  CLRF   2E
....................                 LedGreenFlag = 1; 
10B8:  MOVLW  01
10BA:  MOVWF  2D
....................             } 
....................         } else { 
10BC:  BRA    10CA
....................             // Red LED timing 
....................             if (LedCount > 110) {               // short off phase (250 ms.) 
10BE:  MOVF   2E,W
10C0:  SUBLW  6E
10C2:  BC    10CA
....................                 LedCount = 0; 
10C4:  CLRF   2E
....................                 LedGreenFlag = 1; 
10C6:  MOVLW  01
10C8:  MOVWF  2D
....................             } 
....................         } 
....................     } 
....................     return; 
.................... } 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
.................... // update_eesettings - updates the EEPROM based flags and vriables 
.................... // 
10CA:  BCF    F9E.0
10CC:  GOTO   0070
.................... #separate 
.................... void update_eesettings(void) 
.................... { 
....................     int8 i, j; 
....................  
....................     // 
....................     // Read flags out of EEPROM 
....................     // 1) Expander flag 
....................     // 
....................     i = rd_eeprom(EEPROM_EXPANDER_FLAG); 
*
10E6:  MOVLW  08
10E8:  MOVWF  xCC
10EA:  RCALL  10D0
10EC:  MOVFF  01,C7
....................     if (i) { 
10F0:  MOVF   xC7,F
10F2:  BZ    10F8
....................         EEFlags = EEFLags | EXPANDER_FLAG; 
10F4:  BSF    19.0
....................     } else { 
10F6:  BRA    10FA
....................         EEFlags = EEFLags & (~EXPANDER_FLAG); 
10F8:  BCF    19.0
....................     } 
....................  
....................     // A/D Control nibble. In EEPROM locations 0x11 to 0x18 
....................     for (i=0; i<16; i++) { 
10FA:  CLRF   xC7
10FC:  MOVF   xC7,W
10FE:  SUBLW  0F
1100:  BNC   1130
....................         Adc_Control[i] = rd_eeprom(EEPROM_AD_CONFIG+i); 
1102:  CLRF   03
1104:  MOVF   xC7,W
1106:  ADDLW  1A
1108:  MOVWF  01
110A:  MOVLW  00
110C:  ADDWFC 03,F
110E:  MOVFF  01,C9
1112:  MOVFF  03,CA
1116:  MOVLW  11
1118:  ADDWF  xC7,W
111A:  MOVWF  xCB
111C:  MOVWF  xCC
111E:  RCALL  10D0
1120:  MOVFF  CA,FEA
1124:  MOVFF  C9,FE9
1128:  MOVFF  01,FEF
....................     } 
112C:  INCF   xC7,F
112E:  BRA    10FC
....................      
....................     // Get the USB serial number out of the EEPROM 
....................     // First, copy the ROM structure into RAM structure 
....................     for (i=0; i<USB_STRING_SN_LEN; i++) { 
1130:  CLRF   xC7
1132:  MOVF   xC7,W
1134:  SUBLW  11
1136:  BNC   115E
....................       USB_STRING_SN_RAM[i] = USB_STRING_SN[i]; 
1138:  CLRF   03
113A:  MOVF   xC7,W
113C:  ADDLW  8D
113E:  MOVWF  FE9
1140:  MOVLW  00
1142:  ADDWFC 03,W
1144:  MOVWF  FEA
1146:  CLRF   03
1148:  MOVF   xC7,W
114A:  MOVFF  FF2,CB
114E:  BCF    FF2.7
1150:  CALL   01DE
1154:  BTFSC  xCB.7
1156:  BSF    FF2.7
1158:  MOVWF  FEF
....................     } 
115A:  INCF   xC7,F
115C:  BRA    1132
....................     // First two (2) bytes of a USB string are length and type,  
....................     // and we've already copied those above. We are going to copy 
....................     // just the ASCII string since USB_STRING_SN[] already contains 
....................     // the UNICODE 0. This means copying every-other byte into USB_STRING_SN_RAM[] 
....................     j = 2; 
115E:  MOVLW  02
1160:  MOVWF  xC8
....................     for (i=EEPROM_SN_START; i<EEPROM_SN_END; i++) { 
1162:  MOVLW  30
1164:  MOVWF  xC7
1166:  MOVF   xC7,W
1168:  SUBLW  37
116A:  BNC   11BE
....................       USB_STRING_SN_RAM[j] = rd_eeprom(i); 
116C:  CLRF   03
116E:  MOVF   xC8,W
1170:  ADDLW  8D
1172:  MOVWF  01
1174:  MOVLW  00
1176:  ADDWFC 03,F
1178:  MOVFF  01,C9
117C:  MOVFF  03,CA
1180:  MOVFF  C7,CC
1184:  RCALL  10D0
1186:  MOVFF  CA,FEA
118A:  MOVFF  C9,FE9
118E:  MOVFF  01,FEF
....................       // If the EEPROM hasn't been programmed, all values = 0xFF. So default to S/N 0000000 
....................       if (USB_STRING_SN_RAM[j] == 0xFF)  
1192:  CLRF   03
1194:  MOVF   xC8,W
1196:  ADDLW  8D
1198:  MOVWF  FE9
119A:  MOVLW  00
119C:  ADDWFC 03,W
119E:  MOVWF  FEA
11A0:  INCFSZ FEF,W
11A2:  BRA    11B6
....................         USB_STRING_SN_RAM[j] = '0'; 
11A4:  CLRF   03
11A6:  MOVF   xC8,W
11A8:  ADDLW  8D
11AA:  MOVWF  FE9
11AC:  MOVLW  00
11AE:  ADDWFC 03,W
11B0:  MOVWF  FEA
11B2:  MOVLW  30
11B4:  MOVWF  FEF
....................       j += 2; 
11B6:  MOVLW  02
11B8:  ADDWF  xC8,F
....................     } 
11BA:  INCF   xC7,F
11BC:  BRA    1166
....................     return; 
.................... } 
11BE:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Main program entry point. 
.................... // 
.................... void main(void) { 
*
16F8:  CLRF   FF8
16FA:  BCF    FD0.7
16FC:  BSF    0D.7
16FE:  CLRF   FEA
1700:  CLRF   FE9
1702:  MOVF   FC1,W
1704:  ANDLW  C0
1706:  IORLW  0F
1708:  MOVWF  FC1
170A:  MOVLW  07
170C:  MOVWF  FB4
170E:  CLRF   19
1710:  CLRF   2A
1712:  CLRF   2B
1714:  CLRF   2C
1716:  MOVLW  01
1718:  MOVWF  2D
171A:  CLRF   2E
171C:  CLRF   2F
171E:  CLRF   30
1720:  CLRF   31
1722:  CLRF   32
1724:  CLRF   33
1726:  CLRF   34
1728:  CLRF   35
172A:  CLRF   36
172C:  CLRF   37
172E:  CLRF   38
1730:  CLRF   x8B
1732:  CLRF   x8C
1734:  CLRF   xBE
....................  
....................     int8    i, j, k, x; 
....................     int16   temp; 
....................  
....................     // Setup the built-int ADC. The enables all PORT_A to general purpose I/O 
....................     setup_adc_ports(NO_ANALOGS); 
1736:  MOVF   FC1,W
1738:  ANDLW  C0
173A:  IORLW  0F
173C:  MOVWF  FC1
....................     setup_adc(ADC_OFF); 
173E:  BCF    FC2.0
....................  
....................     // Setup the remaining CCS peripherals 
....................     setup_psp(PSP_DISABLED); 
1740:  BCF    FB0.4
....................     setup_spi(FALSE); 
1742:  BCF    FC6.5
1744:  MOVLW  00
1746:  MOVWF  FC6
1748:  MOVWF  FC7
....................     setup_wdt(WDT_OFF); 
174A:  BCF    FD1.0
....................     setup_timer_0(RTCC_INTERNAL); 
174C:  MOVLW  80
174E:  MOVWF  FD5
....................     setup_timer_1(T1_DISABLED); 
1750:  CLRF   FCD
....................     setup_timer_2(T2_DISABLED,0,1); 
1752:  MOVLW  00
1754:  MOVWF  FCA
1756:  MOVLW  00
1758:  MOVWF  FCB
....................     setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
175A:  MOVF   FB1,W
175C:  ANDLW  48
175E:  MOVWF  FB1
....................     setup_timer_4(T4_DISABLED,0,1); 
1760:  MOVLW  00
1762:  MOVWF  F76
1764:  MOVLW  00
1766:  MOVWF  F77
....................     setup_comparator(NC_NC_NC_NC); 
1768:  MOVLW  07
176A:  MOVWF  FB4
176C:  MOVF   F97,W
176E:  MOVLW  21
1770:  MOVWF  00
1772:  DECFSZ 00,F
1774:  BRA    1772
1776:  MOVF   FB4,W
1778:  BCF    FA1.6
....................     setup_vref(FALSE); 
177A:  CLRF   FB5
....................  
....................     // 
....................     // Setup the TRIS registers and initial port outputs 
....................     // 
....................     set_tris_a(0x10);   // A0-3=O, A4=I, A5=O 
177C:  MOVLW  10
177E:  MOVWF  F92
....................  
....................     // Set the chip select outputs on PORT_A 
....................     output_high(AD_CS); 
1780:  BSF    F89.0
....................     output_high(DAC_CS); 
1782:  BSF    F89.1
....................     output_high(USB_CS); 
1784:  BSF    F89.2
....................  
....................     // Set the remaining data direction registers. 
....................     set_tris_b(0xE3);   // B0-1=I, B2-4=O, B5-7=I 
1786:  MOVLW  E3
1788:  MOVWF  F93
....................     set_tris_c(0xD0);   // C0-3=O, C4=I, C5=0, C6=I, C7=I 
178A:  MOVLW  D0
178C:  MOVWF  F94
....................     set_tris_d(0xFF);   // D0-7=I (used by USBN9603) 
178E:  MOVLW  FF
1790:  MOVWF  F95
....................  
....................     set_tris_e(0xFF);   // PORT1 
1792:  MOVWF  F96
....................     set_tris_f(0xFF);   // PORT2 
1794:  MOVWF  F97
....................  
....................     set_tris_g(0x00);   // G0-4=O 
1796:  MOVLW  00
1798:  MOVWF  F98
....................  
....................     // Set the remaining select and control lines 
....................     output_high(USB_RD); 
179A:  BSF    F8A.2
....................     output_high(USB_WR); 
179C:  BSF    F8A.3
....................     output_high(USB_RESET); 
179E:  BSF    F8B.1
....................  
....................     // Get EEPROM settings 
....................     update_eesettings(); 
17A0:  RCALL  10E6
....................  
.................... //    while (TRUE) { 
.................... //        temp = acquire_adc(8, 1); 
.................... //    } 
....................  
....................     // 
....................     // Set Port data direction from EEPROM 
....................     // 
....................     i = rd_eeprom(EEPROM_DIR_PORT1); 
17A2:  MOVLW  02
17A4:  MOVWF  xCC
17A6:  RCALL  10D0
17A8:  MOVFF  01,C1
....................     set_dir_port1(i); 
17AC:  MOVFF  C1,C7
17B0:  RCALL  11F0
....................     i = rd_eeprom(EEPROM_DIR_PORT2); 
17B2:  MOVLW  03
17B4:  MOVWF  xCC
17B6:  RCALL  10D0
17B8:  MOVFF  01,C1
....................     set_dir_port2(i); 
17BC:  MOVFF  C1,C7
17C0:  RCALL  1204
....................  
....................     // 
....................     // Output power on default for I/O ports from EEPROM 
....................     // 
....................     i = rd_eeprom(EEPROM_POD_PORT1); 
17C2:  MOVLW  06
17C4:  MOVWF  xCC
17C6:  RCALL  10D0
17C8:  MOVFF  01,C1
....................     write_port1(i); 
17CC:  MOVFF  C1,C7
17D0:  RCALL  1218
....................     i = rd_eeprom(EEPROM_POD_PORT2); 
17D2:  MOVLW  07
17D4:  MOVWF  xCC
17D6:  RCALL  10D0
17D8:  MOVFF  01,C1
....................     write_port2(i); 
17DC:  MOVFF  C1,C7
17E0:  RCALL  1226
....................  
....................     // 
....................     // Output power on default for D/A converter 
....................     // 
....................     i = rd_eeprom(EEPROM_POD_DA_MSB_CH0); 
17E2:  MOVLW  09
17E4:  MOVWF  xCC
17E6:  RCALL  10D0
17E8:  MOVFF  01,C1
....................     temp = i; 
17EC:  CLRF   xC6
17EE:  MOVFF  C1,C5
....................     temp = temp << 8; 
17F2:  MOVFF  C5,C6
17F6:  CLRF   xC5
....................     i = rd_eeprom(EEPROM_POD_DA_LSB_CH0); 
17F8:  MOVLW  0A
17FA:  MOVWF  xCC
17FC:  RCALL  10D0
17FE:  MOVFF  01,C1
....................     temp = temp | i; 
1802:  MOVF   xC1,W
1804:  IORWF  xC5,F
....................     DAC_CH0 = temp; 
1806:  MOVFF  C6,32
180A:  MOVFF  C5,31
....................     i = rd_eeprom(EEPROM_POD_DA_MSB_CH1); 
180E:  MOVLW  0B
1810:  MOVWF  xCC
1812:  RCALL  10D0
1814:  MOVFF  01,C1
....................     temp = i; 
1818:  CLRF   xC6
181A:  MOVFF  C1,C5
....................     temp = temp << 8; 
181E:  MOVFF  C5,C6
1822:  CLRF   xC5
....................     i = rd_eeprom(EEPROM_POD_DA_LSB_CH1); 
1824:  MOVLW  0C
1826:  MOVWF  xCC
1828:  RCALL  10D0
182A:  MOVFF  01,C1
....................     temp = temp | i; 
182E:  MOVF   xC1,W
1830:  IORWF  xC5,F
....................     DAC_CH1 = temp; 
1832:  MOVFF  C6,34
1836:  MOVFF  C5,33
....................  
....................     update_dac();                       // Send the new values to the D/A converter 
183A:  RCALL  1262
....................  
....................     // Configure and setup the ADS7871 A/D 
....................     config_adc(); 
183C:  BRA    12E6
....................  
....................     // Clear the command buffer 
....................     for (i=0; i<8; i++) { 
183E:  CLRF   xC1
1840:  MOVF   xC1,W
1842:  SUBLW  07
1844:  BNC   185A
....................         CommandBuffer[i] = 0; 
1846:  CLRF   03
1848:  MOVF   xC1,W
184A:  ADDLW  79
184C:  MOVWF  FE9
184E:  MOVLW  00
1850:  ADDWFC 03,W
1852:  MOVWF  FEA
1854:  CLRF   FEF
....................     } 
1856:  INCF   xC1,F
1858:  BRA    1840
....................  
....................     // Get the version out of the USB chip 
....................     i = usbn_get_version(); 
185A:  BRA    1324
185C:  MOVFF  01,C1
....................  
....................     // USBN9603 and USBN9604 rev = 0x02 
....................     if (i != 0x02) { 
1860:  MOVF   xC1,W
1862:  SUBLW  02
1864:  BZ    186E
....................         // Sit here with a solid RED LED on 
....................         while (TRUE) 
....................         { 
....................             restart_wdt(); 
1866:  CLRWDT
....................             led_on_red(); 
1868:  CALL   035E
....................         } 
186C:  BRA    1866
....................     } 
....................  
....................     // Initialize the USB chip. Now ready to communicate 
....................     usb_init(); 
186E:  BRA    133E
....................  
....................     // 
....................     // Initialize the other interrupts. 
....................     // Note: enable_interrupts(global) is called in usb_init() 
....................     // 
....................     set_timer0(0); 
1870:  CLRF   FD7
1872:  CLRF   FD6
....................     setup_timer_0(RTCC_EXT_H_TO_L | RTCC_DIV_1); 
1874:  MOVLW  B8
1876:  MOVWF  FD5
....................     enable_interrupts(int_timer0);              // Timer0 RTCC Pulse counter input 
1878:  BSF    FF2.5
....................     setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);     // setup interrupts 
187A:  MOVLW  A5
187C:  MOVWF  FCD
....................     enable_interrupts(int_timer1);              // Timer1 Periodic 1 ms. timer 
187E:  BSF    F9D.0
....................     enable_interrupts(global); 
1880:  MOVLW  C0
1882:  IORWF  FF2,F
....................  
.................... // Output a string to the RS-232 port 
.................... //   printf("\r\n\Running...ABCDEFGHIJKLMNOPQRSTUVWXYZ1\r\n"); 
....................  
.................... //    CommandBuffer[0] = 0; 
....................  
....................     // 
....................     // Main Loop - never exits 
....................     // 
....................     while (TRUE) 
....................     { 
....................         // Wait for an ASCII command character in the USB Command buffer 
....................         if (CommandBuffer[0] == 0) { 
1884:  MOVF   x79,F
1886:  BTFSS  FD8.2
1888:  BRA    19D0
....................          
....................             // Check stream mode 
....................             if (StreamFlag) { 
188A:  MOVF   2B,F
188C:  BTFSC  FD8.2
188E:  BRA    19CE
....................              
....................                 // We have plenty of RAM, so we read A/D values into memory. 
....................                 // When the USB TX FIFO2 is empty, then we copy the A/D values  
....................                 // into the USB FIFO. This sort of acts like a ping-pong-buffer 
....................  
....................                 // Is TX FIFO2 empty? 
....................                 if (!bWaitingTxFifoEmpty) { 
1890:  MOVF   2C,F
1892:  BNZ   1922
....................  
....................                     // A/D data to TX FIFO2 = 64 bytes.  
....................                     // 2 sets of 16 samples of 16 bite seach (saved BINARY) 
....................                     i = 0; 
1894:  CLRF   xC1
....................                     for (k=0; k<2; k++)  
1896:  CLRF   xC3
1898:  MOVF   xC3,W
189A:  SUBLW  01
189C:  BNC   191C
....................                     { 
....................                         // Initial sample to flush out previous sample in A/D 
....................                         x = Adc_Control[0]; 
189E:  MOVFF  1A,C4
....................                         temp = acquire_adc(x); 
18A2:  MOVFF  C4,C9
18A6:  RCALL  1512
18A8:  MOVFF  02,C6
18AC:  MOVFF  01,C5
....................                          
....................                         for (j=1; j<17; j++) 
18B0:  MOVLW  01
18B2:  MOVWF  xC2
18B4:  MOVF   xC2,W
18B6:  SUBLW  10
18B8:  BNC   1918
....................                         { 
....................                             if (j >= 16)  
18BA:  MOVF   xC2,W
18BC:  SUBLW  0F
18BE:  BC    18C6
....................                                 x = Adc_Control[15]; 
18C0:  MOVFF  29,C4
....................                             else  
18C4:  BRA    18D8
....................                                 x = Adc_Control[j]; 
18C6:  CLRF   03
18C8:  MOVF   xC2,W
18CA:  ADDLW  1A
18CC:  MOVWF  FE9
18CE:  MOVLW  00
18D0:  ADDWFC 03,W
18D2:  MOVWF  FEA
18D4:  MOVFF  FEF,C4
....................                                  
....................                             // turn off interrupts to grant exclusive SPI acess 
....................                             disable_interrupts(global); 
18D8:  BCF    FF2.6
18DA:  BCF    FF2.7
18DC:  BTFSC  FF2.7
18DE:  BRA    18DA
....................                              
....................                             // A/D Conversion 
....................                             ADC_Buffer[i] = acquire_adc(x); 
18E0:  BCF    FD8.0
18E2:  RLCF   xC1,W
18E4:  CLRF   03
18E6:  ADDLW  39
18E8:  MOVWF  01
18EA:  MOVLW  00
18EC:  ADDWFC 03,F
18EE:  MOVFF  01,C7
18F2:  MOVFF  03,C8
18F6:  MOVFF  C4,C9
18FA:  RCALL  1512
18FC:  MOVFF  C8,FEA
1900:  MOVFF  C7,FE9
1904:  MOVFF  02,FEC
1908:  MOVF   FED,F
190A:  MOVFF  01,FEF
....................                              
....................                             // turn on interrupts 
....................                             enable_interrupts(global); 
190E:  MOVLW  C0
1910:  IORWF  FF2,F
....................                             i++; 
1912:  INCF   xC1,F
....................                         } 
1914:  INCF   xC2,F
1916:  BRA    18B4
....................                     } 
1918:  INCF   xC3,F
191A:  BRA    1898
....................                     // We've copied the A/D values into memory. Now wait until 
....................                     // TX FIFO2 is empty before we copy data and send out USB. 
....................                     bWaitingTxFifoEmpty = 1; 
191C:  MOVLW  01
191E:  MOVWF  2C
....................                 } else {    // if (!bWaitingTxFifoEmpty) { 
1920:  BRA    19CE
....................                     // bWaitingTxFifoEmpty = 1 
....................                     // When TX FIFO2 is empty, then copy data into buffer 
....................                     if (endpoint_stat[2].FIFO_status == EMPTY) { 
1922:  MOVF   xB8,F
1924:  BNZ   19CE
....................                      
....................                         // Copy the data from ADC_Buffer[] into TX FIFO2 
....................                         // 32 samples of 16 bits each = 64 bytes 
....................                         for (i=0; i<32; i++) { 
1926:  CLRF   xC1
1928:  MOVF   xC1,W
192A:  SUBLW  1F
192C:  BNC   19A0
....................                             // Little endian order for Intel PC 
....................                             j = (ADC_Buffer[i] & 0x00FF); 
192E:  BCF    FD8.0
1930:  RLCF   xC1,W
1932:  CLRF   03
1934:  ADDLW  39
1936:  MOVWF  FE9
1938:  MOVLW  00
193A:  ADDWFC 03,W
193C:  MOVWF  FEA
193E:  MOVFF  FEC,C8
1942:  MOVF   FED,F
1944:  MOVFF  FEF,C7
1948:  MOVFF  C7,C2
194C:  CLRF   18
194E:  BTFSC  FF2.7
1950:  BSF    18.7
1952:  BCF    FF2.7
....................                             usbn_write(TXD2, j); 
1954:  MOVLW  31
1956:  MOVWF  xDE
1958:  MOVFF  C2,DF
195C:  CALL   038E
1960:  BTFSC  18.7
1962:  BSF    FF2.7
....................      
....................                             j = (ADC_Buffer[i] & 0xFF00) >> 8; 
1964:  BCF    FD8.0
1966:  RLCF   xC1,W
1968:  CLRF   03
196A:  ADDLW  39
196C:  MOVWF  FE9
196E:  MOVLW  00
1970:  ADDWFC 03,W
1972:  MOVWF  FEA
1974:  MOVFF  FEC,C8
1978:  MOVF   FED,F
197A:  MOVFF  FEF,C7
197E:  CLRF   xC9
1980:  MOVFF  C8,C2
1984:  CLRF   18
1986:  BTFSC  FF2.7
1988:  BSF    18.7
198A:  BCF    FF2.7
....................                             usbn_write(TXD2, j);                         
198C:  MOVLW  31
198E:  MOVWF  xDE
1990:  MOVFF  C2,DF
1994:  CALL   038E
1998:  BTFSC  18.7
199A:  BSF    FF2.7
....................                         } 
199C:  INCF   xC1,F
199E:  BRA    1928
....................                          
....................                         // Waiting for ACK state from PC Host 
....................                         endpoint_stat[2].FIFO_status = WAIT_FOR_ACK; 
19A0:  MOVLW  02
19A2:  MOVWF  xB8
....................      
....................                         // Enable TX for EP1 (TX FIFO2) - includes DATAPID 
....................                         i = endpoint_stat[2].toggle_bit << 2; 
19A4:  RLCF   xB7,W
19A6:  MOVWF  xC1
19A8:  RLCF   xC1,F
19AA:  MOVLW  FC
19AC:  ANDWF  xC1,F
....................                         usbn_write(TXC2, TX_EN | TX_LAST | i); 
19AE:  MOVF   xC1,W
19B0:  IORLW  03
19B2:  MOVWF  xC7
19B4:  CLRF   18
19B6:  BTFSC  FF2.7
19B8:  BSF    18.7
19BA:  BCF    FF2.7
19BC:  MOVLW  33
19BE:  MOVWF  xDE
19C0:  MOVFF  C7,DF
19C4:  CALL   038E
19C8:  BTFSC  18.7
19CA:  BSF    FF2.7
....................                         bWaitingTxFifoEmpty = 0; 
19CC:  CLRF   2C
....................                     } // if (endpoint_stat[2].FIFO_status == EMPTY) { 
....................                 }  
....................             } // if (StreamFlag) { 
....................  
....................             continue; 
19CE:  BRA    1884
19D0:  CLRF   18
19D2:  BTFSC  FF2.7
19D4:  BSF    18.7
19D6:  BCF    FF2.7
....................         } // if (CommandBuffer[0] == 0) { 
....................  
....................         // Flush TX FIFO1 
....................         usbn_write(TXC1, FLUSH); 
19D8:  MOVLW  2B
19DA:  MOVWF  xDE
19DC:  MOVLW  08
19DE:  MOVWF  xDF
19E0:  CALL   038E
19E4:  BTFSC  18.7
19E6:  BSF    FF2.7
....................  
....................         i = strlen(CommandBuffer);                  // Used to check correct command length 
19E8:  CLRF   xC8
19EA:  MOVLW  79
19EC:  MOVWF  xC7
19EE:  RCALL  159E
19F0:  MOVFF  01,C1
....................  
....................         switch (CommandBuffer[0]) { 
19F4:  MOVF   x79,W
19F6:  XORLW  56
19F8:  BZ    1A40
19FA:  XORLW  1F
19FC:  BZ    1A6C
19FE:  XORLW  06
1A00:  BZ    1AA0
1A02:  XORLW  1B
1A04:  BTFSC  FD8.2
1A06:  BRA    1AF4
1A08:  XORLW  13
1A0A:  BTFSC  FD8.2
1A0C:  BRA    1B48
1A0E:  XORLW  09
1A10:  BTFSC  FD8.2
1A12:  BRA    1B7C
1A14:  XORLW  03
1A16:  BTFSC  FD8.2
1A18:  BRA    1BE6
1A1A:  XORLW  18
1A1C:  BTFSC  FD8.2
1A1E:  BRA    1C1E
1A20:  XORLW  19
1A22:  BTFSC  FD8.2
1A24:  BRA    1C84
1A26:  XORLW  1B
1A28:  BTFSC  FD8.2
1A2A:  BRA    1D06
1A2C:  XORLW  05
1A2E:  BTFSC  FD8.2
1A30:  BRA    1D5A
1A32:  XORLW  01
1A34:  BTFSC  FD8.2
1A36:  BRA    1DAC
1A38:  XORLW  1B
1A3A:  BTFSC  FD8.2
1A3C:  BRA    1DDC
1A3E:  BRA    1E0A
....................             case 'V': 
....................                 // 
....................                 // Version string 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1A40:  DECFSZ xC1,W
1A42:  BRA    1A46
1A44:  BRA    1A48
....................                     goto error_rsp; 
1A46:  BRA    1E0A
....................                 strcpy(ResponseBuffer, "V15"); 
1A48:  CLRF   FEA
1A4A:  MOVLW  81
1A4C:  MOVWF  FE9
1A4E:  MOVFF  FF2,C7
1A52:  BCF    FF2.7
1A54:  MOVLW  00
1A56:  CALL   020A
1A5A:  TBLRD*-
1A5C:  TBLRD*+
1A5E:  MOVF   FF5,W
1A60:  MOVWF  FEE
1A62:  IORLW  00
1A64:  BNZ   1A5C
1A66:  BTFSC  xC7.7
1A68:  BSF    FF2.7
....................                 break; 
1A6A:  BRA    1E2E
....................  
....................             case 'I': 
....................                 // 
....................                 // Input digital port 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1A6C:  DECFSZ xC1,W
1A6E:  BRA    1A72
1A70:  BRA    1A74
....................                     goto error_rsp; 
1A72:  BRA    1E0A
....................                 ResponseBuffer[0] = 'I'; 
1A74:  MOVLW  49
1A76:  MOVWF  x81
....................                 i = read_port1(); 
1A78:  BRA    15D2
1A7A:  MOVFF  01,C1
....................                 bin_to_hex(i, &ResponseBuffer[1]); 
1A7E:  MOVFF  C1,C7
1A82:  CLRF   xC9
1A84:  MOVLW  82
1A86:  MOVWF  xC8
1A88:  RCALL  15E6
....................                 j = read_port2(); 
1A8A:  BRA    164C
1A8C:  MOVFF  01,C2
....................                 bin_to_hex(j, &ResponseBuffer[3]); 
1A90:  MOVFF  C2,C7
1A94:  CLRF   xC9
1A96:  MOVLW  84
1A98:  MOVWF  xC8
1A9A:  RCALL  15E6
....................                 ResponseBuffer[5] = 0;              // Null terminate 
1A9C:  CLRF   x86
....................                 break; 
1A9E:  BRA    1E2E
....................  
....................             case 'O': 
....................                 // 
....................                 // Output digital port 
....................                 // 
....................                 if (i != 5)                         // Check for correct command length 
1AA0:  MOVF   xC1,W
1AA2:  SUBLW  05
1AA4:  BZ    1AA8
....................                     goto error_rsp; 
1AA6:  BRA    1E0A
....................                 i = hex_to_bin(&CommandBuffer[1]);  // PORT1 
1AA8:  CLRF   xC8
1AAA:  MOVLW  7A
1AAC:  MOVWF  xC7
1AAE:  RCALL  1660
1AB0:  MOVFF  01,C1
....................                 write_port1(i); 
1AB4:  MOVFF  C1,C7
1AB8:  CALL   1218
....................                 j = hex_to_bin(&CommandBuffer[3]);  // PORT2 
1ABC:  CLRF   xC8
1ABE:  MOVLW  7C
1AC0:  MOVWF  xC7
1AC2:  RCALL  1660
1AC4:  MOVFF  01,C2
....................                 write_port2(j); 
1AC8:  MOVFF  C2,C7
1ACC:  CALL   1226
....................                 strcpy(ResponseBuffer, "O"); 
1AD0:  CLRF   FEA
1AD2:  MOVLW  81
1AD4:  MOVWF  FE9
1AD6:  MOVFF  FF2,C7
1ADA:  BCF    FF2.7
1ADC:  MOVLW  00
1ADE:  CALL   0228
1AE2:  TBLRD*-
1AE4:  TBLRD*+
1AE6:  MOVF   FF5,W
1AE8:  MOVWF  FEE
1AEA:  IORLW  00
1AEC:  BNZ   1AE4
1AEE:  BTFSC  xC7.7
1AF0:  BSF    FF2.7
....................                 break; 
1AF2:  BRA    1E2E
....................  
....................             case 'T': 
....................                 // 
....................                 // Set digital port direction 
....................                 // 
....................                 if (i != 5)                         // Check for correct command length 
1AF4:  MOVF   xC1,W
1AF6:  SUBLW  05
1AF8:  BZ    1AFC
....................                     goto error_rsp; 
1AFA:  BRA    1E0A
....................                 i = hex_to_bin(&CommandBuffer[1]);  // PORT1 
1AFC:  CLRF   xC8
1AFE:  MOVLW  7A
1B00:  MOVWF  xC7
1B02:  RCALL  1660
1B04:  MOVFF  01,C1
....................                 set_dir_port1(i); 
1B08:  MOVFF  C1,C7
1B0C:  CALL   11F0
....................                 j = hex_to_bin(&CommandBuffer[3]);  // PORT2 
1B10:  CLRF   xC8
1B12:  MOVLW  7C
1B14:  MOVWF  xC7
1B16:  RCALL  1660
1B18:  MOVFF  01,C2
....................                 set_dir_port2(j); 
1B1C:  MOVFF  C2,C7
1B20:  CALL   1204
....................                 strcpy(ResponseBuffer, "T"); 
1B24:  CLRF   FEA
1B26:  MOVLW  81
1B28:  MOVWF  FE9
1B2A:  MOVFF  FF2,C7
1B2E:  BCF    FF2.7
1B30:  MOVLW  00
1B32:  CALL   0244
1B36:  TBLRD*-
1B38:  TBLRD*+
1B3A:  MOVF   FF5,W
1B3C:  MOVWF  FEE
1B3E:  IORLW  00
1B40:  BNZ   1B38
1B42:  BTFSC  xC7.7
1B44:  BSF    FF2.7
....................                 break; 
1B46:  BRA    1E2E
....................  
....................             case 'G': 
....................                 // 
....................                 // Get digital port direction 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1B48:  DECFSZ xC1,W
1B4A:  BRA    1B4E
1B4C:  BRA    1B50
....................                     goto error_rsp; 
1B4E:  BRA    1E0A
....................                 ResponseBuffer[0] = 'G'; 
1B50:  MOVLW  47
1B52:  MOVWF  x81
....................                 i = get_dir_port1(); 
1B54:  BRA    16E8
1B56:  MOVFF  01,C1
....................                 bin_to_hex(i, &ResponseBuffer[1]); 
1B5A:  MOVFF  C1,C7
1B5E:  CLRF   xC9
1B60:  MOVLW  82
1B62:  MOVWF  xC8
1B64:  RCALL  15E6
....................                 j = get_dir_port2(); 
1B66:  BRA    16F0
1B68:  MOVFF  01,C2
....................                 bin_to_hex(j, &ResponseBuffer[3]); 
1B6C:  MOVFF  C2,C7
1B70:  CLRF   xC9
1B72:  MOVLW  84
1B74:  MOVWF  xC8
1B76:  RCALL  15E6
....................                 ResponseBuffer[5] = 0;              // Null terminate 
1B78:  CLRF   x86
....................                 break; 
1B7A:  BRA    1E2E
....................  
....................             case 'N': 
....................                 // 
....................                 // Get pulse counter 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1B7C:  DECFSZ xC1,W
1B7E:  BRA    1B82
1B80:  BRA    1B84
....................                     goto error_rsp; 
1B82:  BRA    1E0A
....................                 ResponseBuffer[0] = 'N'; 
1B84:  MOVLW  4E
1B86:  MOVWF  x81
....................  
....................                 i = ((PulseCount & 0xFF000000) >> 24); 
1B88:  CLRF   xC7
1B8A:  CLRF   xC8
1B8C:  CLRF   xC9
1B8E:  MOVFF  38,C1
....................                 bin_to_hex(i, &ResponseBuffer[1]); 
1B92:  MOVFF  C1,C7
1B96:  CLRF   xC9
1B98:  MOVLW  82
1B9A:  MOVWF  xC8
1B9C:  RCALL  15E6
....................  
....................                 i = ((PulseCount & 0xFF0000) >> 16); 
1B9E:  CLRF   xC7
1BA0:  CLRF   xC8
1BA2:  CLRF   xCA
1BA4:  MOVFF  37,C1
....................                 bin_to_hex(i, &ResponseBuffer[3]); 
1BA8:  MOVFF  C1,C7
1BAC:  CLRF   xC9
1BAE:  MOVLW  84
1BB0:  MOVWF  xC8
1BB2:  RCALL  15E6
....................  
....................                 i = ((PulseCount & 0xFF00) >> 8); 
1BB4:  CLRF   xC7
1BB6:  CLRF   xC9
1BB8:  CLRF   xCA
1BBA:  MOVFF  36,C1
....................                 bin_to_hex(i, &ResponseBuffer[5]); 
1BBE:  MOVFF  C1,C7
1BC2:  CLRF   xC9
1BC4:  MOVLW  86
1BC6:  MOVWF  xC8
1BC8:  RCALL  15E6
....................  
....................                 j = PulseCount & 0xFF; 
1BCA:  MOVFF  35,C2
....................                 i = get_timer0(); 
1BCE:  MOVF   FD6,W
1BD0:  MOVWF  xC1
....................                 i = i + j; 
1BD2:  MOVF   xC2,W
1BD4:  ADDWF  xC1,F
....................                 bin_to_hex(i, &ResponseBuffer[7]); 
1BD6:  MOVFF  C1,C7
1BDA:  CLRF   xC9
1BDC:  MOVLW  88
1BDE:  MOVWF  xC8
1BE0:  RCALL  15E6
....................  
....................                 ResponseBuffer[9] = 0;              // Null terminate 
1BE2:  CLRF   x8A
....................                 break; 
1BE4:  BRA    1E2E
....................  
....................             case 'M': 
....................                 // 
....................                 // Clear pulse counter 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1BE6:  DECFSZ xC1,W
1BE8:  BRA    1BEC
1BEA:  BRA    1BEE
....................                     goto error_rsp; 
1BEC:  BRA    1E0A
....................                 set_timer0(0);                      // Clear Timer0 and the count 
1BEE:  CLRF   FD7
1BF0:  CLRF   FD6
....................                 PulseCount = 0; 
1BF2:  CLRF   38
1BF4:  CLRF   37
1BF6:  CLRF   36
1BF8:  CLRF   35
....................                 strcpy(ResponseBuffer, "M"); 
1BFA:  CLRF   FEA
1BFC:  MOVLW  81
1BFE:  MOVWF  FE9
1C00:  MOVFF  FF2,C7
1C04:  BCF    FF2.7
1C06:  MOVLW  00
1C08:  CALL   0260
1C0C:  TBLRD*-
1C0E:  TBLRD*+
1C10:  MOVF   FF5,W
1C12:  MOVWF  FEE
1C14:  IORLW  00
1C16:  BNZ   1C0E
1C18:  BTFSC  xC7.7
1C1A:  BSF    FF2.7
....................                 break; 
1C1C:  BRA    1E2E
....................  
....................             case 'U': 
....................                 // 
....................                 // Unipolar A/D sample 
....................                 // 
....................                 if (i != 3)                         // Check for correct command length 
1C1E:  MOVF   xC1,W
1C20:  SUBLW  03
1C22:  BZ    1C26
....................                     goto error_rsp; 
1C24:  BRA    1E0A
....................                 i = hex_to_bin(&CommandBuffer[1]);  // Control byte 
1C26:  CLRF   xC8
1C28:  MOVLW  7A
1C2A:  MOVWF  xC7
1C2C:  RCALL  1660
1C2E:  MOVFF  01,C1
....................                 temp = acquire_adc(i);              // Flush out the previous conversion 
1C32:  MOVFF  C1,C9
1C36:  RCALL  1512
1C38:  MOVFF  02,C6
1C3C:  MOVFF  01,C5
....................                 temp = acquire_adc(i);              // Get the current (new) conversion results 
1C40:  MOVFF  C1,C9
1C44:  RCALL  1512
1C46:  MOVFF  02,C6
1C4A:  MOVFF  01,C5
....................                 ResponseBuffer[0] = 'U'; 
1C4E:  MOVLW  55
1C50:  MOVWF  x81
....................                 bin_to_hex(i, &ResponseBuffer[1]);  // Control byte 
1C52:  MOVFF  C1,C7
1C56:  CLRF   xC9
1C58:  MOVLW  82
1C5A:  MOVWF  xC8
1C5C:  RCALL  15E6
....................                 j = ((temp & 0xFF00) >> 8); 
1C5E:  CLRF   xC7
1C60:  MOVFF  C6,C2
....................                 bin_to_hex(j, &ResponseBuffer[3]);  // MSB of ADC value 
1C64:  MOVFF  C2,C7
1C68:  CLRF   xC9
1C6A:  MOVLW  84
1C6C:  MOVWF  xC8
1C6E:  RCALL  15E6
....................                 j = (temp & 0x00FF); 
1C70:  MOVFF  C5,C2
....................                 bin_to_hex(j, &ResponseBuffer[5]);  // LSB of ADC value 
1C74:  MOVFF  C2,C7
1C78:  CLRF   xC9
1C7A:  MOVLW  86
1C7C:  MOVWF  xC8
1C7E:  RCALL  15E6
....................                 ResponseBuffer[7] = 0;              // Null terminate 
1C80:  CLRF   x88
....................                 break; 
1C82:  BRA    1E2E
....................  
....................             case 'L': 
....................                 // 
....................                 // Output D/A value 
....................                 // 
....................                 if (i != 5)                         // Check for correct command length 
1C84:  MOVF   xC1,W
1C86:  SUBLW  05
1C88:  BZ    1C8C
....................                     goto error_rsp; 
1C8A:  BRA    1E0A
....................                 CommandBuffer[0] = '0';             // Add leading 0 since hex_to_bin() converts two bytes 
1C8C:  MOVLW  30
1C8E:  MOVWF  x79
....................                 i = hex_to_bin(&CommandBuffer[0]);  // Control nibble (channel number 0 or 1) 
1C90:  CLRF   xC8
1C92:  MOVLW  79
1C94:  MOVWF  xC7
1C96:  RCALL  1660
1C98:  MOVFF  01,C1
....................                 CommandBuffer[1] = '0';             // Zero the control nibble since hex_to_bin() converts two bytes 
1C9C:  MOVLW  30
1C9E:  MOVWF  x7A
....................                 j = hex_to_bin(&CommandBuffer[1]);  // MSB (nibble) of the D/A value 
1CA0:  CLRF   xC8
1CA2:  MOVLW  7A
1CA4:  MOVWF  xC7
1CA6:  RCALL  1660
1CA8:  MOVFF  01,C2
....................                 temp = j; 
1CAC:  CLRF   xC6
1CAE:  MOVFF  C2,C5
....................                 temp = temp << 8; 
1CB2:  MOVFF  C5,C6
1CB6:  CLRF   xC5
....................                 j = hex_to_bin(&CommandBuffer[3]);  // LSB (byte) of the D/A value 
1CB8:  CLRF   xC8
1CBA:  MOVLW  7C
1CBC:  MOVWF  xC7
1CBE:  RCALL  1660
1CC0:  MOVFF  01,C2
....................                 temp = temp | j; 
1CC4:  MOVF   xC2,W
1CC6:  IORWF  xC5,F
....................                 if (i == 0) {                       // Channel 0 
1CC8:  MOVF   xC1,F
1CCA:  BNZ   1CD6
....................                     DAC_CH0 = temp; 
1CCC:  MOVFF  C6,32
1CD0:  MOVFF  C5,31
....................                 } else {                            // Channel 1 
1CD4:  BRA    1CDE
....................                     DAC_CH1 = temp; 
1CD6:  MOVFF  C6,34
1CDA:  MOVFF  C5,33
....................                 } 
....................                 update_dac();                       // Send the new values to the D/A converter 
1CDE:  CALL   1262
....................                 strcpy(ResponseBuffer, "L"); 
1CE2:  CLRF   FEA
1CE4:  MOVLW  81
1CE6:  MOVWF  FE9
1CE8:  MOVFF  FF2,C7
1CEC:  BCF    FF2.7
1CEE:  MOVLW  00
1CF0:  CALL   027C
1CF4:  TBLRD*-
1CF6:  TBLRD*+
1CF8:  MOVF   FF5,W
1CFA:  MOVWF  FEE
1CFC:  IORLW  00
1CFE:  BNZ   1CF6
1D00:  BTFSC  xC7.7
1D02:  BSF    FF2.7
....................                 break; 
1D04:  BRA    1E2E
....................  
....................             case 'W': 
....................                 // 
....................                 // Write EEPROM 
....................                 // 
....................                 if (i != 5)                         // Check for correct command length 
1D06:  MOVF   xC1,W
1D08:  SUBLW  05
1D0A:  BZ    1D0E
....................                     goto error_rsp; 
1D0C:  BRA    1E0A
....................                 i = hex_to_bin(&CommandBuffer[1]);  // EEPROM Address 
1D0E:  CLRF   xC8
1D10:  MOVLW  7A
1D12:  MOVWF  xC7
1D14:  RCALL  1660
1D16:  MOVFF  01,C1
....................                 j = hex_to_bin(&CommandBuffer[3]);  // EEPROM Value 
1D1A:  CLRF   xC8
1D1C:  MOVLW  7C
1D1E:  MOVWF  xC7
1D20:  RCALL  1660
1D22:  MOVFF  01,C2
....................                 wr_eeprom(i, j); 
1D26:  MOVFF  C1,C8
1D2A:  MOVFF  C2,C9
1D2E:  CALL   11C0
....................  
....................                 // Get new EEPROM settings 
....................                 update_eesettings(); 
1D32:  CALL   10E6
....................  
....................                 strcpy(ResponseBuffer, "W"); 
1D36:  CLRF   FEA
1D38:  MOVLW  81
1D3A:  MOVWF  FE9
1D3C:  MOVFF  FF2,C7
1D40:  BCF    FF2.7
1D42:  MOVLW  00
1D44:  CALL   0298
1D48:  TBLRD*-
1D4A:  TBLRD*+
1D4C:  MOVF   FF5,W
1D4E:  MOVWF  FEE
1D50:  IORLW  00
1D52:  BNZ   1D4A
1D54:  BTFSC  xC7.7
1D56:  BSF    FF2.7
....................                 break; 
1D58:  BRA    1E2E
....................  
....................             case 'R': 
....................                 // 
....................                 // Read EEPROM 
....................                 // 
....................                 if (i != 3)                         // Check for correct command length 
1D5A:  MOVF   xC1,W
1D5C:  SUBLW  03
1D5E:  BZ    1D62
....................                     goto error_rsp; 
1D60:  BRA    1E0A
....................                 i = hex_to_bin(&CommandBuffer[1]);  // EEPROM Address 
1D62:  CLRF   xC8
1D64:  MOVLW  7A
1D66:  MOVWF  xC7
1D68:  RCALL  1660
1D6A:  MOVFF  01,C1
....................                 j = rd_eeprom(i); 
1D6E:  MOVFF  C1,CC
1D72:  CALL   10D0
1D76:  MOVFF  01,C2
....................                 strcpy(ResponseBuffer, "R"); 
1D7A:  CLRF   FEA
1D7C:  MOVLW  81
1D7E:  MOVWF  FE9
1D80:  MOVFF  FF2,C7
1D84:  BCF    FF2.7
1D86:  MOVLW  00
1D88:  CALL   02B4
1D8C:  TBLRD*-
1D8E:  TBLRD*+
1D90:  MOVF   FF5,W
1D92:  MOVWF  FEE
1D94:  IORLW  00
1D96:  BNZ   1D8E
1D98:  BTFSC  xC7.7
1D9A:  BSF    FF2.7
....................                 bin_to_hex(j, &ResponseBuffer[1]); 
1D9C:  MOVFF  C2,C7
1DA0:  CLRF   xC9
1DA2:  MOVLW  82
1DA4:  MOVWF  xC8
1DA6:  RCALL  15E6
....................                 ResponseBuffer[3] = 0;              // Null terminate 
1DA8:  CLRF   x84
....................                 break; 
1DAA:  BRA    1E2E
....................  
....................             case 'S': 
....................                 // 
....................                 // Start stream mode 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1DAC:  DECFSZ xC1,W
1DAE:  BRA    1DB2
1DB0:  BRA    1DB4
....................                     goto error_rsp; 
1DB2:  BRA    1E0A
....................                 StreamFlag = 1; 
1DB4:  MOVLW  01
1DB6:  MOVWF  2B
....................                 strcpy(ResponseBuffer, "S"); 
1DB8:  CLRF   FEA
1DBA:  MOVLW  81
1DBC:  MOVWF  FE9
1DBE:  MOVFF  FF2,C7
1DC2:  BCF    FF2.7
1DC4:  MOVLW  00
1DC6:  CALL   02D0
1DCA:  TBLRD*-
1DCC:  TBLRD*+
1DCE:  MOVF   FF5,W
1DD0:  MOVWF  FEE
1DD2:  IORLW  00
1DD4:  BNZ   1DCC
1DD6:  BTFSC  xC7.7
1DD8:  BSF    FF2.7
....................                 break; 
1DDA:  BRA    1E2E
....................  
....................             case 'H': 
....................                 // 
....................                 // Halt stream mode 
....................                 // 
....................                 if (i != 1)                         // Check for correct command length 
1DDC:  DECFSZ xC1,W
1DDE:  BRA    1DE2
1DE0:  BRA    1DE4
....................                     goto error_rsp; 
1DE2:  BRA    1E0A
....................                 StreamFlag = 0; 
1DE4:  CLRF   2B
....................                 strcpy(ResponseBuffer, "H"); 
1DE6:  CLRF   FEA
1DE8:  MOVLW  81
1DEA:  MOVWF  FE9
1DEC:  MOVFF  FF2,C7
1DF0:  BCF    FF2.7
1DF2:  MOVLW  00
1DF4:  CALL   02EC
1DF8:  TBLRD*-
1DFA:  TBLRD*+
1DFC:  MOVF   FF5,W
1DFE:  MOVWF  FEE
1E00:  IORLW  00
1E02:  BNZ   1DFA
1E04:  BTFSC  xC7.7
1E06:  BSF    FF2.7
....................                 break; 
1E08:  BRA    1E2E
....................  
....................             default: 
....................                 // 
....................                 // Unknown command 
....................                 // 
.................... error_rsp:      // ERROR response 
....................                 strcpy(ResponseBuffer, "X"); 
1E0A:  CLRF   FEA
1E0C:  MOVLW  81
1E0E:  MOVWF  FE9
1E10:  MOVFF  FF2,C7
1E14:  BCF    FF2.7
1E16:  MOVLW  00
1E18:  CALL   0308
1E1C:  TBLRD*-
1E1E:  TBLRD*+
1E20:  MOVF   FF5,W
1E22:  MOVWF  FEE
1E24:  IORLW  00
1E26:  BNZ   1E1E
1E28:  BTFSC  xC7.7
1E2A:  BSF    FF2.7
....................                 break; 
1E2C:  BRA    1E2E
....................  
....................         } // switch (CommandChar) 
....................  
....................         // Clear the command buffer for next receive 
....................         for (i=0; i<8; i++) { 
1E2E:  CLRF   xC1
1E30:  MOVF   xC1,W
1E32:  SUBLW  07
1E34:  BNC   1E4A
....................             CommandBuffer[i] = 0; 
1E36:  CLRF   03
1E38:  MOVF   xC1,W
1E3A:  ADDLW  79
1E3C:  MOVWF  FE9
1E3E:  MOVLW  00
1E40:  ADDWFC 03,W
1E42:  MOVWF  FEA
1E44:  CLRF   FEF
....................         } 
1E46:  INCF   xC1,F
1E48:  BRA    1E30
....................  
....................         // Write response string to the TX FIFO1 
....................         j = strlen(ResponseBuffer); 
1E4A:  CLRF   xC8
1E4C:  MOVLW  81
1E4E:  MOVWF  xC7
1E50:  CALL   159E
1E54:  MOVFF  01,C2
....................         for (i=0; i<j; i++) { 
1E58:  CLRF   xC1
1E5A:  MOVF   xC2,W
1E5C:  SUBWF  xC1,W
1E5E:  BC    1E8E
....................             usbn_write(TXD1, ResponseBuffer[i]); 
1E60:  CLRF   03
1E62:  MOVF   xC1,W
1E64:  ADDLW  81
1E66:  MOVWF  FE9
1E68:  MOVLW  00
1E6A:  ADDWFC 03,W
1E6C:  MOVWF  FEA
1E6E:  MOVFF  FEF,C7
1E72:  CLRF   18
1E74:  BTFSC  FF2.7
1E76:  BSF    18.7
1E78:  BCF    FF2.7
1E7A:  MOVLW  29
1E7C:  MOVWF  xDE
1E7E:  MOVFF  C7,DF
1E82:  CALL   038E
1E86:  BTFSC  18.7
1E88:  BSF    FF2.7
....................         } 
1E8A:  INCF   xC1,F
1E8C:  BRA    1E5A
....................  
....................         // Enable TX for EP1 (TX FIFO1) - includes DATAPID 
....................         i = endpoint_stat[1].toggle_bit << 2; 
1E8E:  RLCF   xB5,W
1E90:  MOVWF  xC1
1E92:  RLCF   xC1,F
1E94:  MOVLW  FC
1E96:  ANDWF  xC1,F
....................         usbn_write(TXC1, TX_EN | TX_LAST | i); 
1E98:  MOVF   xC1,W
1E9A:  IORLW  03
1E9C:  MOVWF  xC7
1E9E:  CLRF   18
1EA0:  BTFSC  FF2.7
1EA2:  BSF    18.7
1EA4:  BCF    FF2.7
1EA6:  MOVLW  2B
1EA8:  MOVWF  xDE
1EAA:  MOVFF  C7,DF
1EAE:  CALL   038E
1EB2:  BTFSC  18.7
1EB4:  BSF    FF2.7
1EB6:  CLRF   18
1EB8:  BTFSC  FF2.7
1EBA:  BSF    18.7
1EBC:  BCF    FF2.7
....................  
....................         // Re-enable RX 
....................         usbn_write(RXC1,FLUSH);     // Flush  RX1 
1EBE:  MOVLW  2F
1EC0:  MOVWF  xDE
1EC2:  MOVLW  08
1EC4:  MOVWF  xDF
1EC6:  CALL   038E
1ECA:  BTFSC  18.7
1ECC:  BSF    FF2.7
1ECE:  CLRF   18
1ED0:  BTFSC  FF2.7
1ED2:  BSF    18.7
1ED4:  BCF    FF2.7
....................         usbn_write(RXC1,RX_EN);     // Enable command receive (EP2) 
1ED6:  MOVLW  2F
1ED8:  MOVWF  xDE
1EDA:  MOVLW  01
1EDC:  MOVWF  xDF
1EDE:  CALL   038E
1EE2:  BTFSC  18.7
1EE4:  BSF    FF2.7
....................     } // While (TRUE) 
1EE6:  BRA    1884
....................      
....................     // We should never get here 
....................     return; 
.................... } 
1EE8:  SLEEP 

Configuration Fuses:
   Word  1: 2600   H4 NOOSCSEN
   Word  2: 0E06   BROWNOUT WDT128 NOWDT BORV42 PUT
   Word  3: 0383   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
